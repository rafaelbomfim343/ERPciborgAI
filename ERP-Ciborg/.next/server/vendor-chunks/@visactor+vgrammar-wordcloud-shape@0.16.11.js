"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@visactor+vgrammar-wordcloud-shape@0.16.11";
exports.ids = ["vendor-chunks/@visactor+vgrammar-wordcloud-shape@0.16.11"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _segmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./segmentation */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js\");\n/* harmony import */ var _wordle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wordle */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js\");\n/* harmony import */ var _filling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filling */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js\");\n\n\n\n\n\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(words, layoutConfig, segmentationOutput) {\n    (0,_segmentation__WEBPACK_IMPORTED_MODULE_0__.allocateWords)(words, segmentationOutput), \"ensureMapping\" === layoutConfig.layoutMode ? (0,_wordle__WEBPACK_IMPORTED_MODULE_1__.layoutGlobalShrink)(words, layoutConfig, segmentationOutput) : \"ensureMappingEnlarge\" === layoutConfig.layoutMode ? (0,_wordle__WEBPACK_IMPORTED_MODULE_1__.layoutSelfEnlarge)(words, layoutConfig, segmentationOutput) : (0,_wordle__WEBPACK_IMPORTED_MODULE_1__.layout)(words, layoutConfig, segmentationOutput);\n    const fillingWords = (0,_filling__WEBPACK_IMPORTED_MODULE_2__.filling)(words, layoutConfig, segmentationOutput), failedWords = [], successedWords = [];\n    for (let i = 0; i < words.length; i++) words[i].hasPlaced ? successedWords.push(words[i]) : failedWords.push(words[i]);\n    return failedWords.forEach((word => word.visible = !1)), {\n        fillingWords: fillingWords,\n        successedWords: successedWords,\n        failedWords: failedWords\n    };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2Nsb3VkLXNoYXBlLWxheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStDOztBQUUwQjs7QUFFckM7O0FBRXBDLDZCQUFlLG9DQUFTO0FBQ3hCLElBQUksNERBQWEsMkVBQTJFLDJEQUFrQixpR0FBaUcsMERBQWlCLDRDQUE0QywrQ0FBTTtBQUNsUix5QkFBeUIsaURBQU87QUFDaEMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci13b3JkY2xvdWQtc2hhcGVAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZS9lcy9jbG91ZC1zaGFwZS1sYXlvdXQuanM/Y2U1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhbGxvY2F0ZVdvcmRzIH0gZnJvbSBcIi4vc2VnbWVudGF0aW9uXCI7XG5cbmltcG9ydCB7IGxheW91dCwgbGF5b3V0R2xvYmFsU2hyaW5rLCBsYXlvdXRTZWxmRW5sYXJnZSB9IGZyb20gXCIuL3dvcmRsZVwiO1xuXG5pbXBvcnQgeyBmaWxsaW5nIH0gZnJvbSBcIi4vZmlsbGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBhbGxvY2F0ZVdvcmRzKHdvcmRzLCBzZWdtZW50YXRpb25PdXRwdXQpLCBcImVuc3VyZU1hcHBpbmdcIiA9PT0gbGF5b3V0Q29uZmlnLmxheW91dE1vZGUgPyBsYXlvdXRHbG9iYWxTaHJpbmsod29yZHMsIGxheW91dENvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KSA6IFwiZW5zdXJlTWFwcGluZ0VubGFyZ2VcIiA9PT0gbGF5b3V0Q29uZmlnLmxheW91dE1vZGUgPyBsYXlvdXRTZWxmRW5sYXJnZSh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpIDogbGF5b3V0KHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCk7XG4gICAgY29uc3QgZmlsbGluZ1dvcmRzID0gZmlsbGluZyh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpLCBmYWlsZWRXb3JkcyA9IFtdLCBzdWNjZXNzZWRXb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHdvcmRzW2ldLmhhc1BsYWNlZCA/IHN1Y2Nlc3NlZFdvcmRzLnB1c2god29yZHNbaV0pIDogZmFpbGVkV29yZHMucHVzaCh3b3Jkc1tpXSk7XG4gICAgcmV0dXJuIGZhaWxlZFdvcmRzLmZvckVhY2goKHdvcmQgPT4gd29yZC52aXNpYmxlID0gITEpKSwge1xuICAgICAgICBmaWxsaW5nV29yZHM6IGZpbGxpbmdXb3JkcyxcbiAgICAgICAgc3VjY2Vzc2VkV29yZHM6IHN1Y2Nlc3NlZFdvcmRzLFxuICAgICAgICBmYWlsZWRXb3JkczogZmFpbGVkV29yZHNcbiAgICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filling: () => (/* binding */ filling)\n/* harmony export */ });\n/* harmony import */ var _wordle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordle */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js\");\n\n\nfunction filling(words, layoutConfig, segmentationOutput) {\n    const {size: size, fillingTimes: fillingTimes, fillingXStep: fillingXStep, fillingYStep: fillingYStep, getFillingFontStyle: getFillingFontStyle, getFillingFontWeight: getFillingFontWeight, getFillingFontFamily: getFillingFontFamily, fillingInitialFontSize: fillingInitialFontSize, fillingDeltaFontSize: fillingDeltaFontSize, fillingInitialOpacity: fillingInitialOpacity, fillingDeltaOpacity: fillingDeltaOpacity, fillingRotateList: fillingRotateList, getFillingPadding: getFillingPadding, random: random, board: board, minFillFontSize: minFillFontSize} = layoutConfig, {boardSize: boardSize, shapeBounds: shapeBounds, tempCanvas: canvas, randomGenerator: randomGenerator} = segmentationOutput, ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    let fontSize = fillingInitialFontSize, opacity = fillingInitialOpacity;\n    const placedFillingWords = [];\n    for (let i = 0; i < fillingTimes; i++) filling1Time(fontSize, opacity), fontSize = Math.max(fontSize > fillingDeltaFontSize ? fontSize - fillingDeltaFontSize : fillingDeltaFontSize, minFillFontSize), \n    opacity = opacity > fillingDeltaOpacity ? opacity - fillingDeltaOpacity : fillingDeltaOpacity;\n    return placedFillingWords;\n    function filling1Time(fontSize, opacity) {\n        const fillingWords = words.map((word => {\n            const {text: text, color: color, fillingColor: fillingColor, hasPlaced: hasPlaced, datum: datum} = word;\n            return {\n                x: 0,\n                y: 0,\n                weight: 0,\n                text: text,\n                fontFamily: getFillingFontFamily(datum),\n                fontStyle: getFillingFontStyle(datum),\n                fontWeight: getFillingFontWeight(datum),\n                fontSize: fontSize,\n                rotate: fillingRotateList[~~(randomGenerator() * fillingRotateList.length)],\n                padding: getFillingPadding(datum),\n                opacity: opacity,\n                visible: !0,\n                color: color,\n                fillingColor: fillingColor,\n                hasPlaced: hasPlaced,\n                datum: datum\n            };\n        }));\n        randomArray(fillingWords);\n        let wi = 0;\n        const {x1: x1, y1: y1, x2: x2, y2: y2} = shapeBounds, [startX, startY] = [ x1 + ~~(randomGenerator() * fillingXStep * 2), y1 + ~~(randomGenerator() * fillingYStep * 2) ];\n        for (let y = startY; y <= y2; y += fillingYStep) for (let x = startX; x <= x2; x += fillingXStep) {\n            (0,_wordle__WEBPACK_IMPORTED_MODULE_0__.measureSprite)(canvas, ctx, fillingWords, wi);\n            const word = fillingWords[wi];\n            word.x = x, word.y = y;\n            const {wordSize: wordSize, bounds: bounds, hasPlaced: hasPlaced} = word;\n            if (!hasPlaced || !bounds) {\n                ++wi === fillingWords.length && (wi = 0, random && randomArray(fillingWords));\n                continue;\n            }\n            const {dTop: dTop, dBottom: dBottom, dLeft: dLeft, dRight: dRight} = bounds;\n            word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || word.hasText && word.sprite && !(0,_wordle__WEBPACK_IMPORTED_MODULE_0__.isCollideWithBoard)(word, board, boardSize) && ((0,_wordle__WEBPACK_IMPORTED_MODULE_0__.placeWordOnBoard)(word, board, boardSize), \n            placedFillingWords.push(Object.assign({}, word)), ++wi === fillingWords.length && (wi = 0, \n            random && randomArray(fillingWords)));\n        }\n    }\n    function randomArray(words) {\n        return words.sort((() => randomGenerator() - .5));\n    }\n}\n//# sourceMappingURL=filling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2ZpbGxpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0U7O0FBRXhFO0FBQ1AsV0FBVyxraUJBQWtpQixpQkFBaUIsc0dBQXNHO0FBQ3BxQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwRkFBMEY7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyw2QkFBNkIsU0FBUyx3Q0FBd0MsU0FBUztBQUN2RixZQUFZLHNEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUIsMERBQTBEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUE0RDtBQUMvRSxrSkFBa0osMkRBQWtCLDZCQUE2Qix5REFBZ0I7QUFDak4sb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci13b3JkY2xvdWQtc2hhcGVAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZS9lcy9maWxsaW5nLmpzPzhiZTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVhc3VyZVNwcml0ZSwgaXNDb2xsaWRlV2l0aEJvYXJkLCBwbGFjZVdvcmRPbkJvYXJkIH0gZnJvbSBcIi4vd29yZGxlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsaW5nKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtzaXplOiBzaXplLCBmaWxsaW5nVGltZXM6IGZpbGxpbmdUaW1lcywgZmlsbGluZ1hTdGVwOiBmaWxsaW5nWFN0ZXAsIGZpbGxpbmdZU3RlcDogZmlsbGluZ1lTdGVwLCBnZXRGaWxsaW5nRm9udFN0eWxlOiBnZXRGaWxsaW5nRm9udFN0eWxlLCBnZXRGaWxsaW5nRm9udFdlaWdodDogZ2V0RmlsbGluZ0ZvbnRXZWlnaHQsIGdldEZpbGxpbmdGb250RmFtaWx5OiBnZXRGaWxsaW5nRm9udEZhbWlseSwgZmlsbGluZ0luaXRpYWxGb250U2l6ZTogZmlsbGluZ0luaXRpYWxGb250U2l6ZSwgZmlsbGluZ0RlbHRhRm9udFNpemU6IGZpbGxpbmdEZWx0YUZvbnRTaXplLCBmaWxsaW5nSW5pdGlhbE9wYWNpdHk6IGZpbGxpbmdJbml0aWFsT3BhY2l0eSwgZmlsbGluZ0RlbHRhT3BhY2l0eTogZmlsbGluZ0RlbHRhT3BhY2l0eSwgZmlsbGluZ1JvdGF0ZUxpc3Q6IGZpbGxpbmdSb3RhdGVMaXN0LCBnZXRGaWxsaW5nUGFkZGluZzogZ2V0RmlsbGluZ1BhZGRpbmcsIHJhbmRvbTogcmFuZG9tLCBib2FyZDogYm9hcmQsIG1pbkZpbGxGb250U2l6ZTogbWluRmlsbEZvbnRTaXplfSA9IGxheW91dENvbmZpZywge2JvYXJkU2l6ZTogYm9hcmRTaXplLCBzaGFwZUJvdW5kczogc2hhcGVCb3VuZHMsIHRlbXBDYW52YXM6IGNhbnZhcywgcmFuZG9tR2VuZXJhdG9yOiByYW5kb21HZW5lcmF0b3J9ID0gc2VnbWVudGF0aW9uT3V0cHV0LCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxuICAgIH0pO1xuICAgIGxldCBmb250U2l6ZSA9IGZpbGxpbmdJbml0aWFsRm9udFNpemUsIG9wYWNpdHkgPSBmaWxsaW5nSW5pdGlhbE9wYWNpdHk7XG4gICAgY29uc3QgcGxhY2VkRmlsbGluZ1dvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsaW5nVGltZXM7IGkrKykgZmlsbGluZzFUaW1lKGZvbnRTaXplLCBvcGFjaXR5KSwgZm9udFNpemUgPSBNYXRoLm1heChmb250U2l6ZSA+IGZpbGxpbmdEZWx0YUZvbnRTaXplID8gZm9udFNpemUgLSBmaWxsaW5nRGVsdGFGb250U2l6ZSA6IGZpbGxpbmdEZWx0YUZvbnRTaXplLCBtaW5GaWxsRm9udFNpemUpLCBcbiAgICBvcGFjaXR5ID0gb3BhY2l0eSA+IGZpbGxpbmdEZWx0YU9wYWNpdHkgPyBvcGFjaXR5IC0gZmlsbGluZ0RlbHRhT3BhY2l0eSA6IGZpbGxpbmdEZWx0YU9wYWNpdHk7XG4gICAgcmV0dXJuIHBsYWNlZEZpbGxpbmdXb3JkcztcbiAgICBmdW5jdGlvbiBmaWxsaW5nMVRpbWUoZm9udFNpemUsIG9wYWNpdHkpIHtcbiAgICAgICAgY29uc3QgZmlsbGluZ1dvcmRzID0gd29yZHMubWFwKCh3b3JkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHt0ZXh0OiB0ZXh0LCBjb2xvcjogY29sb3IsIGZpbGxpbmdDb2xvcjogZmlsbGluZ0NvbG9yLCBoYXNQbGFjZWQ6IGhhc1BsYWNlZCwgZGF0dW06IGRhdHVtfSA9IHdvcmQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBnZXRGaWxsaW5nRm9udEZhbWlseShkYXR1bSksXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiBnZXRGaWxsaW5nRm9udFN0eWxlKGRhdHVtKSxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBnZXRGaWxsaW5nRm9udFdlaWdodChkYXR1bSksXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgIHJvdGF0ZTogZmlsbGluZ1JvdGF0ZUxpc3Rbfn4ocmFuZG9tR2VuZXJhdG9yKCkgKiBmaWxsaW5nUm90YXRlTGlzdC5sZW5ndGgpXSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBnZXRGaWxsaW5nUGFkZGluZyhkYXR1bSksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgZmlsbGluZ0NvbG9yOiBmaWxsaW5nQ29sb3IsXG4gICAgICAgICAgICAgICAgaGFzUGxhY2VkOiBoYXNQbGFjZWQsXG4gICAgICAgICAgICAgICAgZGF0dW06IGRhdHVtXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICAgIHJhbmRvbUFycmF5KGZpbGxpbmdXb3Jkcyk7XG4gICAgICAgIGxldCB3aSA9IDA7XG4gICAgICAgIGNvbnN0IHt4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTJ9ID0gc2hhcGVCb3VuZHMsIFtzdGFydFgsIHN0YXJ0WV0gPSBbIHgxICsgfn4ocmFuZG9tR2VuZXJhdG9yKCkgKiBmaWxsaW5nWFN0ZXAgKiAyKSwgeTEgKyB+fihyYW5kb21HZW5lcmF0b3IoKSAqIGZpbGxpbmdZU3RlcCAqIDIpIF07XG4gICAgICAgIGZvciAobGV0IHkgPSBzdGFydFk7IHkgPD0geTI7IHkgKz0gZmlsbGluZ1lTdGVwKSBmb3IgKGxldCB4ID0gc3RhcnRYOyB4IDw9IHgyOyB4ICs9IGZpbGxpbmdYU3RlcCkge1xuICAgICAgICAgICAgbWVhc3VyZVNwcml0ZShjYW52YXMsIGN0eCwgZmlsbGluZ1dvcmRzLCB3aSk7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gZmlsbGluZ1dvcmRzW3dpXTtcbiAgICAgICAgICAgIHdvcmQueCA9IHgsIHdvcmQueSA9IHk7XG4gICAgICAgICAgICBjb25zdCB7d29yZFNpemU6IHdvcmRTaXplLCBib3VuZHM6IGJvdW5kcywgaGFzUGxhY2VkOiBoYXNQbGFjZWR9ID0gd29yZDtcbiAgICAgICAgICAgIGlmICghaGFzUGxhY2VkIHx8ICFib3VuZHMpIHtcbiAgICAgICAgICAgICAgICArK3dpID09PSBmaWxsaW5nV29yZHMubGVuZ3RoICYmICh3aSA9IDAsIHJhbmRvbSAmJiByYW5kb21BcnJheShmaWxsaW5nV29yZHMpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHtkVG9wOiBkVG9wLCBkQm90dG9tOiBkQm90dG9tLCBkTGVmdDogZExlZnQsIGRSaWdodDogZFJpZ2h0fSA9IGJvdW5kcztcbiAgICAgICAgICAgIHdvcmQueCAtIGRMZWZ0IDwgMCB8fCB3b3JkLnggKyBkUmlnaHQgPiBzaXplWzBdIHx8IHdvcmQueSAtIGRUb3AgPCAwIHx8IHdvcmQueSArIGRCb3R0b20gPiBzaXplWzFdIHx8IHdvcmQuaGFzVGV4dCAmJiB3b3JkLnNwcml0ZSAmJiAhaXNDb2xsaWRlV2l0aEJvYXJkKHdvcmQsIGJvYXJkLCBib2FyZFNpemUpICYmIChwbGFjZVdvcmRPbkJvYXJkKHdvcmQsIGJvYXJkLCBib2FyZFNpemUpLCBcbiAgICAgICAgICAgIHBsYWNlZEZpbGxpbmdXb3Jkcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIHdvcmQpKSwgKyt3aSA9PT0gZmlsbGluZ1dvcmRzLmxlbmd0aCAmJiAod2kgPSAwLCBcbiAgICAgICAgICAgIHJhbmRvbSAmJiByYW5kb21BcnJheShmaWxsaW5nV29yZHMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZG9tQXJyYXkod29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHdvcmRzLnNvcnQoKCgpID0+IHJhbmRvbUdlbmVyYXRvcigpIC0gLjUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxsaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/filling.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WORDCLOUD_SHAPE_HOOK_EVENT: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.WORDCLOUD_SHAPE_HOOK_EVENT),\n/* harmony export */   registerWordCloudShapeTransforms: () => (/* binding */ registerWordCloudShapeTransforms),\n/* harmony export */   wordcloudShapeTransform: () => (/* binding */ wordcloudShapeTransform)\n/* harmony export */ });\n/* harmony import */ var _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vgrammar-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-core@0.16.11/node_modules/@visactor/vgrammar-core/es/core/factory.js\");\n/* harmony import */ var _wordcloud_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wordcloud-shape */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\");\n\n\n\n\n\n\nconst registerWordCloudShapeTransforms = () => {\n    _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_1__.Factory.registerTransform(\"wordcloudShape\", {\n        transform: _wordcloud_shape__WEBPACK_IMPORTED_MODULE_2__.transform,\n        markPhase: \"beforeJoin\"\n    }, !0);\n};\n\nconst wordcloudShapeTransform = _wordcloud_shape__WEBPACK_IMPORTED_MODULE_2__.transform;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrRDs7QUFFSjs7QUFFTTs7QUFFN0M7QUFDUCxJQUFJLDREQUFPO0FBQ1gsbUJBQW1CLHVEQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVPLGdDQUFnQyx1REFBUztBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2FjdG9yLW5leHQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2luZGV4LmpzPzQ3ODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRmFjdG9yeSB9IGZyb20gXCJAdmlzYWN0b3IvdmdyYW1tYXItY29yZVwiO1xuXG5pbXBvcnQgeyB0cmFuc2Zvcm0gfSBmcm9tIFwiLi93b3JkY2xvdWQtc2hhcGVcIjtcblxuZXhwb3J0IHsgV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcldvcmRDbG91ZFNoYXBlVHJhbnNmb3JtcyA9ICgpID0+IHtcbiAgICBGYWN0b3J5LnJlZ2lzdGVyVHJhbnNmb3JtKFwid29yZGNsb3VkU2hhcGVcIiwge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgbWFya1BoYXNlOiBcImJlZm9yZUpvaW5cIlxuICAgIH0sICEwKTtcbn07XG5cbmV4cG9ydCBjb25zdCB3b3JkY2xvdWRTaGFwZVRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ Layout)\n/* harmony export */ });\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isString.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/array.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/angle.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isFunction.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/toNumber.js\");\n/* harmony import */ var _segmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./segmentation */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\");\n/* harmony import */ var _visactor_vscale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @visactor/vscale */ \"(ssr)/./node_modules/.pnpm/@visactor+vscale@0.19.7/node_modules/@visactor/vscale/es/ordinal-scale.js\");\n/* harmony import */ var _visactor_vscale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @visactor/vscale */ \"(ssr)/./node_modules/.pnpm/@visactor+vscale@0.19.7/node_modules/@visactor/vscale/es/linear-scale.js\");\n/* harmony import */ var _visactor_vscale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @visactor/vscale */ \"(ssr)/./node_modules/.pnpm/@visactor+vscale@0.19.7/node_modules/@visactor/vscale/es/sqrt-scale.js\");\n/* harmony import */ var _cloud_shape_layout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cloud-shape-layout */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/cloud-shape-layout.js\");\n/* harmony import */ var _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vrender-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vrender-core@0.22.16/node_modules/@visactor/vrender-core/es/modules.js\");\n/* harmony import */ var _visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @visactor/vgrammar-util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-util@0.16.11/node_modules/@visactor/vgrammar-util/es/image.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst OUTPUT = {\n    x: \"x\",\n    y: \"y\",\n    fontFamily: \"fontFamily\",\n    fontSize: \"fontSize\",\n    fontStyle: \"fontStyle\",\n    fontWeight: \"fontWeight\",\n    angle: \"angle\",\n    opacity: \"opacity\",\n    visible: \"visible\",\n    isFillingWord: \"isFillingWord\",\n    color: \"color\"\n};\n\nclass Layout {\n    constructor(options, view) {\n        this.progressiveResult = [], this.options = options, this.view = view;\n    }\n    layout(data) {\n        this.data = data;\n        const options = this.options, segmentationInput = {\n            shapeUrl: options.shape,\n            size: options.size,\n            ratio: options.ratio || .8,\n            tempCanvas: void 0,\n            boardSize: [ 0, 0 ],\n            random: !1,\n            randomGenerator: void 0\n        }, tempCanvas = _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_0__.vglobal.createCanvas({\n            width: options.size[0],\n            height: options.size[1]\n        }), tempCtx = tempCanvas.getContext(\"2d\", {\n            willReadFrequently: !0\n        });\n        tempCtx.textAlign = \"center\", tempCtx.textBaseline = \"middle\", segmentationInput.tempCanvas = tempCanvas;\n        const boardW = options.size[0] + 31 >> 5 << 5;\n        if (segmentationInput.boardSize = [ boardW, options.size[1] ], segmentationInput.random ? segmentationInput.randomGenerator = Math.random : segmentationInput.randomGenerator = (0,_util__WEBPACK_IMPORTED_MODULE_1__.fakeRandom)(), \n        this.segmentationInput = segmentationInput, (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(segmentationInput.shapeUrl)) {\n            segmentationInput.isEmptyPixel = (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__.generateIsEmptyPixel)();\n            const imagePromise = (0,_util__WEBPACK_IMPORTED_MODULE_1__.loadImage)(segmentationInput.shapeUrl);\n            imagePromise ? (this.isImageFinished = !1, this.isLayoutFinished = !1, imagePromise.then((shapeImage => {\n                this.isImageFinished = !0;\n                const maskCanvas = _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_0__.vglobal.createCanvas({\n                    width: options.size[0],\n                    height: options.size[1],\n                    dpr: 1\n                });\n                segmentationInput.maskCanvas = maskCanvas;\n                const ctx = maskCanvas.getContext(\"2d\");\n                options.removeWhiteBorder && (0,_segmentation__WEBPACK_IMPORTED_MODULE_4__.removeBorder)(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);\n                const shapeConfig = (0,_segmentation__WEBPACK_IMPORTED_MODULE_4__.scaleAndMiddleShape)(shapeImage, options.size);\n                ctx.clearRect(0, 0, options.size[0], options.size[1]), ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height), \n                this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(segmentationInput.maskCanvas);\n            })).catch((error => {\n                this.isImageFinished = !0;\n            }))) : (this.isImageFinished = !0, this.isLayoutFinished = !0);\n        } else if (segmentationInput.shapeUrl && (\"text\" === segmentationInput.shapeUrl.type || \"geometric\" === segmentationInput.shapeUrl.type)) {\n            segmentationInput.isEmptyPixel = (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__.generateIsEmptyPixel)(segmentationInput.shapeUrl.backgroundColor);\n            const maskCanvas = (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_3__.generateMaskCanvas)(segmentationInput.shapeUrl, options.size[0], options.size[1]);\n            segmentationInput.maskCanvas = maskCanvas, this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(maskCanvas), \n            this.doLayout(), this.isImageFinished = !0, this.isLayoutFinished = !0;\n        }\n    }\n    canAnimate() {\n        return !0;\n    }\n    unfinished() {\n        return !this.isLayoutFinished;\n    }\n    output() {\n        return this.progressiveResult;\n    }\n    progressiveRun() {\n        this.isImageFinished && !this.isLayoutFinished && (this.segmentationInput.maskCanvas && this.doLayout(), \n        this.isLayoutFinished = !0);\n    }\n    progressiveOutput() {\n        return this.progressiveResult;\n    }\n    doLayout() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n        const segmentationInput = this.segmentationInput, segmentationOutput = (0,_segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentation)(segmentationInput);\n        if (!segmentationOutput.segmentation.regions.length) return;\n        const options = this.options, data = this.data, colorMode = options.colorMode || \"ordinal\", wordsConfig = {\n            getText: field(options.text),\n            getFontSize: field(options.fontSize),\n            fontSizeRange: options.fontSizeRange,\n            colorMode: colorMode,\n            getColor: options.colorField ? field(options.colorField) : field(options.text),\n            getFillingColor: field(options.fillingColorField),\n            colorList: options.colorList || (\"ordinal\" === colorMode ? [ \"#2E62F1\" ] : [ \"#537EF5\", \"#2E62F1\", \"#2358D8\", \"#184FBF\", \"#0C45A6\", \"#013B8E\" ]),\n            getColorHex: field(options.colorHexField),\n            getFontFamily: field(options.fontFamily || \"sans-serif\"),\n            rotateList: options.rotateList || [ 0 ],\n            getPadding: field(options.padding || 1),\n            getFontStyle: field(options.fontStyle || \"normal\"),\n            getFontWeight: field(options.fontWeight || \"normal\"),\n            getFontOpacity: options.fontOpacity ? field(options.fontOpacity) : () => 1\n        };\n        initFontSizeScale(data, wordsConfig, segmentationOutput);\n        const layoutConfig = {\n            size: options.size,\n            ratio: options.ratio || .8,\n            shapeUrl: options.shape,\n            random: void 0 === options.random || options.random,\n            textLayoutTimes: null !== (_a = options.textLayoutTimes) && void 0 !== _a ? _a : 3,\n            removeWhiteBorder: options.removeWhiteBorder,\n            layoutMode: null !== (_b = options.layoutMode) && void 0 !== _b ? _b : \"default\",\n            fontSizeShrinkFactor: null !== (_c = options.fontSizeShrinkFactor) && void 0 !== _c ? _c : .8,\n            stepFactor: null !== (_d = options.stepFactor) && void 0 !== _d ? _d : 1,\n            importantWordCount: null !== (_e = options.importantWordCount) && void 0 !== _e ? _e : 10,\n            globalShinkLimit: options.globalShinkLimit || .2,\n            fontSizeEnlargeFactor: null !== (_f = options.fontSizeEnlargeFactor) && void 0 !== _f ? _f : 1.5,\n            fillingRatio: null !== (_g = options.fillingRatio) && void 0 !== _g ? _g : .7,\n            fillingTimes: null !== (_h = options.fillingTimes) && void 0 !== _h ? _h : 4,\n            fillingXStep: options.fillingXRatioStep ? Math.max(Math.floor(options.size[0] * options.fillingXRatioStep), 1) : null !== (_j = options.fillingXStep) && void 0 !== _j ? _j : 4,\n            fillingYStep: options.fillingYRatioStep ? Math.max(Math.floor(options.size[1] * options.fillingYRatioStep), 1) : null !== (_k = options.fillingYStep) && void 0 !== _k ? _k : 4,\n            fillingInitialFontSize: options.fillingInitialFontSize,\n            fillingDeltaFontSize: options.fillingDeltaFontSize,\n            fillingInitialOpacity: null !== (_l = options.fillingInitialOpacity) && void 0 !== _l ? _l : .8,\n            fillingDeltaOpacity: null !== (_m = options.fillingDeltaOpacity) && void 0 !== _m ? _m : .05,\n            getFillingFontFamily: field(options.fillingFontFamily || \"sans-serif\"),\n            getFillingFontStyle: field(options.fillingFontStyle || \"normal\"),\n            getFillingFontWeight: field(options.fillingFontWeight || \"normal\"),\n            getFillingPadding: field(null !== (_o = options.fillingPadding) && void 0 !== _o ? _o : .4),\n            fillingRotateList: null !== (_p = options.fillingRotateList) && void 0 !== _p ? _p : [ 0, 90 ],\n            fillingDeltaFontSizeFactor: null !== (_q = options.fillingDeltaFontSizeFactor) && void 0 !== _q ? _q : .2,\n            fillingColorList: options.fillingColorList || [ \"#537EF5\" ],\n            sameColorList: !1,\n            minInitFontSize: null !== (_r = options.minInitFontSize) && void 0 !== _r ? _r : 10,\n            minFontSize: null !== (_s = options.minFontSize) && void 0 !== _s ? _s : 4,\n            minFillFontSize: null !== (_t = options.minFillFontSize) && void 0 !== _t ? _t : 2\n        }, sameColorList = (0,_util__WEBPACK_IMPORTED_MODULE_1__.colorListEqual)(wordsConfig.colorList, layoutConfig.fillingColorList);\n        layoutConfig.sameColorList = sameColorList, initColorScale(data, wordsConfig, layoutConfig, options), \n        initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput);\n        const {getText: getText, getFontFamily: getFontFamily, getFontStyle: getFontStyle, getFontWeight: getFontWeight, getPadding: getPadding, getColor: getColor, getFillingColor: getFillingColor, getColorHex: getColorHex, fontSizeScale: fontSizeScale, colorScale: colorScale, fillingColorScale: fillingColorScale, getFontOpacity: getFontOpacity, rotateList: rotateList} = wordsConfig, words = data.map((datum => {\n            var _a, _b;\n            return {\n                x: 0,\n                y: 0,\n                weight: 0,\n                text: getText(datum),\n                fontFamily: getFontFamily(datum),\n                fontWeight: getFontWeight(datum),\n                fontStyle: getFontStyle(datum),\n                rotate: rotateList[~~(segmentationInput.randomGenerator() * rotateList.length)],\n                fontSize: Math.max(layoutConfig.minInitFontSize, ~~fontSizeScale(datum)),\n                opacity: getFontOpacity(datum),\n                padding: getPadding(datum),\n                color: getColorHex && getColorHex(datum) || colorScale && colorScale(getColor(datum)) || \"black\",\n                fillingColor: !getFillingColor || (null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) === (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) && sameColorList ? void 0 : getColorHex && getColorHex(datum) || fillingColorScale && fillingColorScale(getFillingColor(datum)) || \"black\",\n                datum: datum,\n                visible: !0,\n                hasPlaced: !1\n            };\n        })), wordsMaxFontSize = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_5__.maxInArray)(words.map((word => word.fontSize)));\n        words.forEach((word => word.weight = word.fontSize / wordsMaxFontSize)), words.sort(((a, b) => b.weight - a.weight));\n        const {fillingWords: fillingWords, successedWords: successedWords, failedWords: failedWords} = (0,_cloud_shape_layout__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(words, layoutConfig, segmentationOutput), textKey = null !== (_v = null === (_u = options.text) || void 0 === _u ? void 0 : _u.field) && void 0 !== _v ? _v : \"textKey\", dataIndexKey = null !== (_w = options.dataIndexKey) && void 0 !== _w ? _w : \"defaultDataIndexKey\", as = options.as ? Object.assign(Object.assign({}, OUTPUT), options.as) : OUTPUT;\n        let w, t;\n        const modKeywords = [];\n        for (let i = 0; i < words.length; ++i) w = words[i], t = w.datum, t[as.x] = w.x, \n        t[as.y] = w.y, t[as.fontFamily] = w.fontFamily, t[as.fontSize] = w.fontSize, t[as.fontStyle] = w.fontStyle, \n        t[as.fontWeight] = w.fontWeight, t[as.angle] = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_7__.degreeToRadian)(w.rotate), t[as.opacity] = w.opacity, \n        t[as.visible] = w.visible, t[as.isFillingWord] = !1, t[as.color] = w.color, t[dataIndexKey] = `${w.text}_${i}_keyword`, \n        modKeywords.push(t);\n        const fillingWordsData = [];\n        if (fillingWords.forEach(((word, index) => {\n            var _a, _b;\n            const t = Object.assign({}, word.datum);\n            t[as.x] = word.x, t[as.y] = word.y, t[as.fontFamily] = word.fontFamily, t[as.fontSize] = word.fontSize, \n            t[as.fontStyle] = word.fontStyle, t[as.fontWeight] = word.fontWeight, t[as.angle] = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_7__.degreeToRadian)(word.rotate), \n            t[as.opacity] = word.opacity, t[as.visible] = word.visible, t[as.isFillingWord] = !0, \n            t[as.color] = getFillingColor ? (null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) === (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) && sameColorList ? word.color : word.fillingColor : layoutConfig.fillingColorList[~~(segmentationInput.randomGenerator() * layoutConfig.fillingColorList.length)], \n            t[textKey] = word.text, t[dataIndexKey] = `${word.text}_${index}_fillingWords`, \n            fillingWordsData.push(t);\n        })), this.view && this.view.emit) {\n            this.view.emit(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_LAYOUT, {\n                successedWords: successedWords,\n                failedWords: failedWords\n            });\n            const stage = null === (_x = this.view.renderer) || void 0 === _x ? void 0 : _x.stage();\n            stage && stage.hooks.afterRender.tap(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW, (() => {\n                this.view.emit(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW, {\n                    successedWords: successedWords,\n                    failedWords: failedWords\n                }), stage.hooks.afterRender.unTap(_util__WEBPACK_IMPORTED_MODULE_1__.WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW);\n            }));\n        }\n        this.progressiveResult = modKeywords.concat(fillingWordsData);\n    }\n    release() {\n        this.segmentationInput = null, this.data = null, this.progressiveResult = null, \n        this.options = null;\n    }\n}\n\nconst initColorScale = (data, wordsConfig, layoutConfig, options) => {\n    var _a, _b, _c, _d;\n    const {colorMode: colorMode, getColor: getColor, getFillingColor: getFillingColor} = wordsConfig, {sameColorList: sameColorList} = layoutConfig;\n    let colorScale, fillingColorScale, colorList = wordsConfig.colorList, fillingColorList = layoutConfig.fillingColorList;\n    if (\"ordinal\" === colorMode) {\n        const uniqueColorField = data.map((word => getColor(word)));\n        if (colorScale = datum => (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_8__.OrdinalScale).domain(uniqueColorField).range(colorList).scale(datum), \n        getFillingColor && ((null === (_a = options.colorField) || void 0 === _a ? void 0 : _a.field) !== (null === (_b = options.fillingColorField) || void 0 === _b ? void 0 : _b.field) || !sameColorList)) {\n            const uniquefillingColorField = data.map((datum => getFillingColor(datum)));\n            fillingColorScale = datum => (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_8__.OrdinalScale).domain(uniquefillingColorField).range(fillingColorList).scale(datum);\n        }\n    } else {\n        1 === colorList.length && (colorList = [ colorList[0], colorList[0] ]);\n        const valueScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_9__.LinearScale).domain(extent(getColor, data)).range(colorList);\n        if (colorScale = i => valueScale.scale(i), getFillingColor && ((null === (_c = options.colorField) || void 0 === _c ? void 0 : _c.field) !== (null === (_d = options.fillingColorField) || void 0 === _d ? void 0 : _d.field) || !sameColorList)) {\n            1 === fillingColorList.length && (fillingColorList = [ fillingColorList[0], fillingColorList[0] ]);\n            const fillingValueScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_9__.LinearScale).domain(extent(getFillingColor, data)).range(fillingColorList);\n            fillingColorScale = i => fillingValueScale.scale(i);\n        }\n    }\n    Object.assign(wordsConfig, {\n        colorScale: colorScale,\n        fillingColorScale: fillingColorScale\n    });\n}, initFontSizeScale = (data, wordsConfig, segmentationOutput) => {\n    let {fontSizeRange: range} = wordsConfig;\n    const {getFontSize: getFontSize, getText: getText} = wordsConfig;\n    let fontSizeScale;\n    if (getFontSize) {\n        if (getFontSize && range) {\n            const sizeScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_10__.SqrtScale).domain(extent(getFontSize, data)).range(range);\n            fontSizeScale = datum => sizeScale.scale(getFontSize(datum));\n        } else if (getFontSize && (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(getFontSize) && !range) {\n            const a = .5, [min, max] = extent(getFontSize, data), words = data.map((datum => ({\n                text: getText(datum),\n                value: getFontSize(datum),\n                weight: max === min ? 1 : (getFontSize(datum) - min) / (max - min)\n            }))), x = getInitialFontSize(words, segmentationOutput, !0);\n            range = [ ~~(a * x), ~~x ];\n            const sizeScale = (new _visactor_vscale__WEBPACK_IMPORTED_MODULE_10__.SqrtScale).domain(extent(getFontSize, data)).range(range);\n            fontSizeScale = datum => sizeScale.scale(getFontSize(datum));\n        }\n    } else {\n        const words = data.map((word => ({\n            text: getText(word)\n        }))), x = getInitialFontSize(words, segmentationOutput, !1);\n        fontSizeScale = (0,_util__WEBPACK_IMPORTED_MODULE_1__.functor)(x);\n    }\n    Object.assign(wordsConfig, {\n        getFontSize: getFontSize,\n        fontSizeRange: range,\n        fontSizeScale: fontSizeScale\n    });\n}, getInitialFontSize = (words, segmentationOutput, weight) => {\n    const shapeArea = segmentationOutput.shapeArea, ratio = segmentationOutput.ratio, regions = segmentationOutput.segmentation.regions, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(shapeArea) / 12), wordArea = words.reduce(((acc, word) => {\n        const textLength = (0,_util__WEBPACK_IMPORTED_MODULE_1__.calTextLength)(word.text);\n        return textLength < shapeSizeLimitTextLength ? acc + textLength * (weight ? (.5 + .5 * word.weight) ** 2 : 1) : acc;\n    }), 0);\n    if (0 === wordArea) return 12;\n    let x = 20;\n    if (1 === regions.length) x = Math.sqrt(ratio * (shapeArea / (1.7 * wordArea))); else {\n        const xArr = [];\n        for (let i = 0; i < regions.length; i++) {\n            const regionArea = regions[i].area, regionAspect = regions[i].ratio, regionRatio = regionArea / shapeArea;\n            if (regionRatio < .1) continue;\n            const regionWordArea = regionRatio * (wordArea * (regionAspect < 1 ? 2.7 - regionAspect : 1.7)), x = Math.sqrt(ratio * (regionArea / regionWordArea));\n            xArr.push(x);\n        }\n        x = xArr.length ? Math.min(...xArr) : Math.sqrt(ratio * (shapeArea / (1.7 * wordArea)));\n    }\n    return x;\n};\n\nfunction initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput) {\n    const {getText: getText} = wordsConfig;\n    let {fillingInitialFontSize: fillingInitialFontSize, fillingDeltaFontSize: fillingDeltaFontSize} = layoutConfig;\n    const {fillingRatio: fillingRatio} = layoutConfig, shapeSizeLimitTextLength = Math.ceil(Math.sqrt(segmentationOutput.shapeArea) / 4);\n    if (!fillingInitialFontSize || !fillingDeltaFontSize) {\n        const a = fillingRatio / 100, averageLength = data.reduce(((acc, word) => {\n            const length = (0,_util__WEBPACK_IMPORTED_MODULE_1__.calTextLength)(getText(word));\n            return length > shapeSizeLimitTextLength ? acc : acc + length;\n        }), 0) / data.length;\n        let fontSize;\n        if (0 === averageLength) fontSize = 8; else {\n            const area = .2 * segmentationOutput.shapeArea;\n            fontSize = Math.sqrt(a * (area / averageLength));\n        }\n        fillingInitialFontSize = ~~fontSize, fillingDeltaFontSize = fontSize * layoutConfig.fillingDeltaFontSizeFactor, \n        Object.assign(layoutConfig, {\n            fillingInitialFontSize: fillingInitialFontSize,\n            fillingDeltaFontSize: fillingDeltaFontSize\n        });\n    }\n}\n\nconst extent = (field, data) => {\n    let min = 1 / 0, max = -1 / 0;\n    const n = data.length;\n    let v;\n    for (let i = 0; i < n; ++i) v = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_12__.toNumber)(field(data[i])), v < min && (min = v), \n    v > max && (max = v);\n    return 1 === data.length && min === max && (min -= 1e4), [ min, max ];\n}, field = option => option ? \"string\" == typeof option || \"number\" == typeof option ? () => option : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(option) ? option : datum => datum[option.field] : null;\n//# sourceMappingURL=layout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL2xheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4Rjs7QUFFYjs7QUFFa0M7O0FBRTNDOztBQUUvQjs7QUFFUTs7QUFFa0M7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWUsMkRBQU87QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0xBQXdMLGlEQUFVO0FBQ2xNLG9EQUFvRCw0REFBUTtBQUM1RCw2Q0FBNkMsNkVBQW9CO0FBQ2pFLGlDQUFpQyxnREFBUztBQUMxQztBQUNBO0FBQ0EsbUNBQW1DLDJEQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkNBQTZDLDJEQUFZO0FBQ3pELG9DQUFvQyxrRUFBbUI7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1YsNkNBQTZDLDZFQUFvQjtBQUNqRSwrQkFBK0IsMkVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDJEQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQixxREFBYztBQUN6QztBQUNBO0FBQ0EsZUFBZSxzV0FBc1c7QUFDclg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVCQUF1Qiw0REFBVTtBQUMxQztBQUNBLGVBQWUsc0ZBQXNGLEVBQUUsK0RBQUssNlRBQTZUO0FBQ3phO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0EsdURBQXVELGdFQUFjO0FBQ3JFLHlHQUF5RyxPQUFPLEdBQUcsRUFBRTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGdHQUFnRyxnRUFBYztBQUM5RztBQUNBO0FBQ0EseURBQXlELFVBQVUsR0FBRyxNQUFNO0FBQzVFO0FBQ0EsU0FBUztBQUNULDJCQUEyQiw2REFBMEI7QUFDckQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlEQUFpRCw2REFBMEI7QUFDM0UsK0JBQStCLDZEQUEwQjtBQUN6RDtBQUNBO0FBQ0EsaUJBQWlCLGlDQUFpQyw2REFBMEI7QUFDNUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNEVBQTRFLGdCQUFnQiw4QkFBOEI7QUFDckk7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBEQUFZO0FBQ25EO0FBQ0E7QUFDQSw4Q0FBOEMsMERBQVk7QUFDMUQ7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MseURBQVc7QUFDM0M7QUFDQTtBQUNBLDJDQUEyQyx5REFBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFNBQVMsc0JBQXNCO0FBQy9CLFdBQVcsNENBQTRDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3REFBUztBQUM1QztBQUNBLFVBQVUsd0JBQXdCLDZEQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUNBQW1DLHdEQUFTO0FBQzVDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVM7QUFDVCx3QkFBd0IsOENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwyQkFBMkIsb0RBQWE7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsU0FBUyw0RkFBNEY7QUFDckcsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBLDJCQUEyQixvREFBYTtBQUN4QztBQUNBLFNBQVM7QUFDVDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sU0FBUywyREFBUTtBQUM1QztBQUNBO0FBQ0EsQ0FBQyxxR0FBcUcsNkRBQVU7QUFDaEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci13b3JkY2xvdWQtc2hhcGVAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZS9lcy9sYXlvdXQuanM/YzlkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWdyZWVUb1JhZGlhbiwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIG1heEluQXJyYXksIHRvTnVtYmVyIH0gZnJvbSBcIkB2aXNhY3Rvci92dXRpbHNcIjtcblxuaW1wb3J0IHsgcmVtb3ZlQm9yZGVyLCBzY2FsZUFuZE1pZGRsZVNoYXBlLCBzZWdtZW50YXRpb24gfSBmcm9tIFwiLi9zZWdtZW50YXRpb25cIjtcblxuaW1wb3J0IHsgV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQsIGNhbFRleHRMZW5ndGgsIGNvbG9yTGlzdEVxdWFsLCBmYWtlUmFuZG9tLCBmdW5jdG9yLCBsb2FkSW1hZ2UgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmltcG9ydCB7IExpbmVhclNjYWxlLCBPcmRpbmFsU2NhbGUsIFNxcnRTY2FsZSB9IGZyb20gXCJAdmlzYWN0b3IvdnNjYWxlXCI7XG5cbmltcG9ydCBjbG91ZCBmcm9tIFwiLi9jbG91ZC1zaGFwZS1sYXlvdXRcIjtcblxuaW1wb3J0IHsgdmdsb2JhbCB9IGZyb20gXCJAdmlzYWN0b3IvdnJlbmRlci1jb3JlXCI7XG5cbmltcG9ydCB7IGdlbmVyYXRlSXNFbXB0eVBpeGVsLCBnZW5lcmF0ZU1hc2tDYW52YXMgfSBmcm9tIFwiQHZpc2FjdG9yL3ZncmFtbWFyLXV0aWxcIjtcblxuY29uc3QgT1VUUFVUID0ge1xuICAgIHg6IFwieFwiLFxuICAgIHk6IFwieVwiLFxuICAgIGZvbnRGYW1pbHk6IFwiZm9udEZhbWlseVwiLFxuICAgIGZvbnRTaXplOiBcImZvbnRTaXplXCIsXG4gICAgZm9udFN0eWxlOiBcImZvbnRTdHlsZVwiLFxuICAgIGZvbnRXZWlnaHQ6IFwiZm9udFdlaWdodFwiLFxuICAgIGFuZ2xlOiBcImFuZ2xlXCIsXG4gICAgb3BhY2l0eTogXCJvcGFjaXR5XCIsXG4gICAgdmlzaWJsZTogXCJ2aXNpYmxlXCIsXG4gICAgaXNGaWxsaW5nV29yZDogXCJpc0ZpbGxpbmdXb3JkXCIsXG4gICAgY29sb3I6IFwiY29sb3JcIlxufTtcblxuZXhwb3J0IGNsYXNzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgdmlldykge1xuICAgICAgICB0aGlzLnByb2dyZXNzaXZlUmVzdWx0ID0gW10sIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMsIHRoaXMudmlldyA9IHZpZXc7XG4gICAgfVxuICAgIGxheW91dChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIHNlZ21lbnRhdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgc2hhcGVVcmw6IG9wdGlvbnMuc2hhcGUsXG4gICAgICAgICAgICBzaXplOiBvcHRpb25zLnNpemUsXG4gICAgICAgICAgICByYXRpbzogb3B0aW9ucy5yYXRpbyB8fCAuOCxcbiAgICAgICAgICAgIHRlbXBDYW52YXM6IHZvaWQgMCxcbiAgICAgICAgICAgIGJvYXJkU2l6ZTogWyAwLCAwIF0sXG4gICAgICAgICAgICByYW5kb206ICExLFxuICAgICAgICAgICAgcmFuZG9tR2VuZXJhdG9yOiB2b2lkIDBcbiAgICAgICAgfSwgdGVtcENhbnZhcyA9IHZnbG9iYWwuY3JlYXRlQ2FudmFzKHtcbiAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLnNpemVbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuc2l6ZVsxXVxuICAgICAgICB9KSwgdGVtcEN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogITBcbiAgICAgICAgfSk7XG4gICAgICAgIHRlbXBDdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIiwgdGVtcEN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCBzZWdtZW50YXRpb25JbnB1dC50ZW1wQ2FudmFzID0gdGVtcENhbnZhcztcbiAgICAgICAgY29uc3QgYm9hcmRXID0gb3B0aW9ucy5zaXplWzBdICsgMzEgPj4gNSA8PCA1O1xuICAgICAgICBpZiAoc2VnbWVudGF0aW9uSW5wdXQuYm9hcmRTaXplID0gWyBib2FyZFcsIG9wdGlvbnMuc2l6ZVsxXSBdLCBzZWdtZW50YXRpb25JbnB1dC5yYW5kb20gPyBzZWdtZW50YXRpb25JbnB1dC5yYW5kb21HZW5lcmF0b3IgPSBNYXRoLnJhbmRvbSA6IHNlZ21lbnRhdGlvbklucHV0LnJhbmRvbUdlbmVyYXRvciA9IGZha2VSYW5kb20oKSwgXG4gICAgICAgIHRoaXMuc2VnbWVudGF0aW9uSW5wdXQgPSBzZWdtZW50YXRpb25JbnB1dCwgaXNTdHJpbmcoc2VnbWVudGF0aW9uSW5wdXQuc2hhcGVVcmwpKSB7XG4gICAgICAgICAgICBzZWdtZW50YXRpb25JbnB1dC5pc0VtcHR5UGl4ZWwgPSBnZW5lcmF0ZUlzRW1wdHlQaXhlbCgpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbG9hZEltYWdlKHNlZ21lbnRhdGlvbklucHV0LnNoYXBlVXJsKTtcbiAgICAgICAgICAgIGltYWdlUHJvbWlzZSA/ICh0aGlzLmlzSW1hZ2VGaW5pc2hlZCA9ICExLCB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSAhMSwgaW1hZ2VQcm9taXNlLnRoZW4oKHNoYXBlSW1hZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJbWFnZUZpbmlzaGVkID0gITA7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFza0NhbnZhcyA9IHZnbG9iYWwuY3JlYXRlQ2FudmFzKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMuc2l6ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLnNpemVbMV0sXG4gICAgICAgICAgICAgICAgICAgIGRwcjogMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRhdGlvbklucHV0Lm1hc2tDYW52YXMgPSBtYXNrQ2FudmFzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IG1hc2tDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVtb3ZlV2hpdGVCb3JkZXIgJiYgcmVtb3ZlQm9yZGVyKHNoYXBlSW1hZ2UsIG1hc2tDYW52YXMsIHNlZ21lbnRhdGlvbklucHV0LmlzRW1wdHlQaXhlbCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcGVDb25maWcgPSBzY2FsZUFuZE1pZGRsZVNoYXBlKHNoYXBlSW1hZ2UsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBvcHRpb25zLnNpemVbMF0sIG9wdGlvbnMuc2l6ZVsxXSksIGN0eC5kcmF3SW1hZ2Uoc2hhcGVJbWFnZSwgc2hhcGVDb25maWcueCwgc2hhcGVDb25maWcueSwgc2hhcGVDb25maWcud2lkdGgsIHNoYXBlQ29uZmlnLmhlaWdodCksIFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZU1hc2tDYW52YXMgJiYgdGhpcy5vcHRpb25zLm9uVXBkYXRlTWFza0NhbnZhcyhzZWdtZW50YXRpb25JbnB1dC5tYXNrQ2FudmFzKTtcbiAgICAgICAgICAgIH0pKS5jYXRjaCgoZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJbWFnZUZpbmlzaGVkID0gITA7XG4gICAgICAgICAgICB9KSkpIDogKHRoaXMuaXNJbWFnZUZpbmlzaGVkID0gITAsIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9ICEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWdtZW50YXRpb25JbnB1dC5zaGFwZVVybCAmJiAoXCJ0ZXh0XCIgPT09IHNlZ21lbnRhdGlvbklucHV0LnNoYXBlVXJsLnR5cGUgfHwgXCJnZW9tZXRyaWNcIiA9PT0gc2VnbWVudGF0aW9uSW5wdXQuc2hhcGVVcmwudHlwZSkpIHtcbiAgICAgICAgICAgIHNlZ21lbnRhdGlvbklucHV0LmlzRW1wdHlQaXhlbCA9IGdlbmVyYXRlSXNFbXB0eVBpeGVsKHNlZ21lbnRhdGlvbklucHV0LnNoYXBlVXJsLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICBjb25zdCBtYXNrQ2FudmFzID0gZ2VuZXJhdGVNYXNrQ2FudmFzKHNlZ21lbnRhdGlvbklucHV0LnNoYXBlVXJsLCBvcHRpb25zLnNpemVbMF0sIG9wdGlvbnMuc2l6ZVsxXSk7XG4gICAgICAgICAgICBzZWdtZW50YXRpb25JbnB1dC5tYXNrQ2FudmFzID0gbWFza0NhbnZhcywgdGhpcy5vcHRpb25zLm9uVXBkYXRlTWFza0NhbnZhcyAmJiB0aGlzLm9wdGlvbnMub25VcGRhdGVNYXNrQ2FudmFzKG1hc2tDYW52YXMpLCBcbiAgICAgICAgICAgIHRoaXMuZG9MYXlvdXQoKSwgdGhpcy5pc0ltYWdlRmluaXNoZWQgPSAhMCwgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gITA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuQW5pbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICB1bmZpbmlzaGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNMYXlvdXRGaW5pc2hlZDtcbiAgICB9XG4gICAgb3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmVzc2l2ZVJlc3VsdDtcbiAgICB9XG4gICAgcHJvZ3Jlc3NpdmVSdW4oKSB7XG4gICAgICAgIHRoaXMuaXNJbWFnZUZpbmlzaGVkICYmICF0aGlzLmlzTGF5b3V0RmluaXNoZWQgJiYgKHRoaXMuc2VnbWVudGF0aW9uSW5wdXQubWFza0NhbnZhcyAmJiB0aGlzLmRvTGF5b3V0KCksIFxuICAgICAgICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSAhMCk7XG4gICAgfVxuICAgIHByb2dyZXNzaXZlT3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmVzc2l2ZVJlc3VsdDtcbiAgICB9XG4gICAgZG9MYXlvdXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeDtcbiAgICAgICAgY29uc3Qgc2VnbWVudGF0aW9uSW5wdXQgPSB0aGlzLnNlZ21lbnRhdGlvbklucHV0LCBzZWdtZW50YXRpb25PdXRwdXQgPSBzZWdtZW50YXRpb24oc2VnbWVudGF0aW9uSW5wdXQpO1xuICAgICAgICBpZiAoIXNlZ21lbnRhdGlvbk91dHB1dC5zZWdtZW50YXRpb24ucmVnaW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgZGF0YSA9IHRoaXMuZGF0YSwgY29sb3JNb2RlID0gb3B0aW9ucy5jb2xvck1vZGUgfHwgXCJvcmRpbmFsXCIsIHdvcmRzQ29uZmlnID0ge1xuICAgICAgICAgICAgZ2V0VGV4dDogZmllbGQob3B0aW9ucy50ZXh0KSxcbiAgICAgICAgICAgIGdldEZvbnRTaXplOiBmaWVsZChvcHRpb25zLmZvbnRTaXplKSxcbiAgICAgICAgICAgIGZvbnRTaXplUmFuZ2U6IG9wdGlvbnMuZm9udFNpemVSYW5nZSxcbiAgICAgICAgICAgIGNvbG9yTW9kZTogY29sb3JNb2RlLFxuICAgICAgICAgICAgZ2V0Q29sb3I6IG9wdGlvbnMuY29sb3JGaWVsZCA/IGZpZWxkKG9wdGlvbnMuY29sb3JGaWVsZCkgOiBmaWVsZChvcHRpb25zLnRleHQpLFxuICAgICAgICAgICAgZ2V0RmlsbGluZ0NvbG9yOiBmaWVsZChvcHRpb25zLmZpbGxpbmdDb2xvckZpZWxkKSxcbiAgICAgICAgICAgIGNvbG9yTGlzdDogb3B0aW9ucy5jb2xvckxpc3QgfHwgKFwib3JkaW5hbFwiID09PSBjb2xvck1vZGUgPyBbIFwiIzJFNjJGMVwiIF0gOiBbIFwiIzUzN0VGNVwiLCBcIiMyRTYyRjFcIiwgXCIjMjM1OEQ4XCIsIFwiIzE4NEZCRlwiLCBcIiMwQzQ1QTZcIiwgXCIjMDEzQjhFXCIgXSksXG4gICAgICAgICAgICBnZXRDb2xvckhleDogZmllbGQob3B0aW9ucy5jb2xvckhleEZpZWxkKSxcbiAgICAgICAgICAgIGdldEZvbnRGYW1pbHk6IGZpZWxkKG9wdGlvbnMuZm9udEZhbWlseSB8fCBcInNhbnMtc2VyaWZcIiksXG4gICAgICAgICAgICByb3RhdGVMaXN0OiBvcHRpb25zLnJvdGF0ZUxpc3QgfHwgWyAwIF0sXG4gICAgICAgICAgICBnZXRQYWRkaW5nOiBmaWVsZChvcHRpb25zLnBhZGRpbmcgfHwgMSksXG4gICAgICAgICAgICBnZXRGb250U3R5bGU6IGZpZWxkKG9wdGlvbnMuZm9udFN0eWxlIHx8IFwibm9ybWFsXCIpLFxuICAgICAgICAgICAgZ2V0Rm9udFdlaWdodDogZmllbGQob3B0aW9ucy5mb250V2VpZ2h0IHx8IFwibm9ybWFsXCIpLFxuICAgICAgICAgICAgZ2V0Rm9udE9wYWNpdHk6IG9wdGlvbnMuZm9udE9wYWNpdHkgPyBmaWVsZChvcHRpb25zLmZvbnRPcGFjaXR5KSA6ICgpID0+IDFcbiAgICAgICAgfTtcbiAgICAgICAgaW5pdEZvbnRTaXplU2NhbGUoZGF0YSwgd29yZHNDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCk7XG4gICAgICAgIGNvbnN0IGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgIHNpemU6IG9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgIHJhdGlvOiBvcHRpb25zLnJhdGlvIHx8IC44LFxuICAgICAgICAgICAgc2hhcGVVcmw6IG9wdGlvbnMuc2hhcGUsXG4gICAgICAgICAgICByYW5kb206IHZvaWQgMCA9PT0gb3B0aW9ucy5yYW5kb20gfHwgb3B0aW9ucy5yYW5kb20sXG4gICAgICAgICAgICB0ZXh0TGF5b3V0VGltZXM6IG51bGwgIT09IChfYSA9IG9wdGlvbnMudGV4dExheW91dFRpbWVzKSAmJiB2b2lkIDAgIT09IF9hID8gX2EgOiAzLFxuICAgICAgICAgICAgcmVtb3ZlV2hpdGVCb3JkZXI6IG9wdGlvbnMucmVtb3ZlV2hpdGVCb3JkZXIsXG4gICAgICAgICAgICBsYXlvdXRNb2RlOiBudWxsICE9PSAoX2IgPSBvcHRpb25zLmxheW91dE1vZGUpICYmIHZvaWQgMCAhPT0gX2IgPyBfYiA6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgZm9udFNpemVTaHJpbmtGYWN0b3I6IG51bGwgIT09IChfYyA9IG9wdGlvbnMuZm9udFNpemVTaHJpbmtGYWN0b3IpICYmIHZvaWQgMCAhPT0gX2MgPyBfYyA6IC44LFxuICAgICAgICAgICAgc3RlcEZhY3RvcjogbnVsbCAhPT0gKF9kID0gb3B0aW9ucy5zdGVwRmFjdG9yKSAmJiB2b2lkIDAgIT09IF9kID8gX2QgOiAxLFxuICAgICAgICAgICAgaW1wb3J0YW50V29yZENvdW50OiBudWxsICE9PSAoX2UgPSBvcHRpb25zLmltcG9ydGFudFdvcmRDb3VudCkgJiYgdm9pZCAwICE9PSBfZSA/IF9lIDogMTAsXG4gICAgICAgICAgICBnbG9iYWxTaGlua0xpbWl0OiBvcHRpb25zLmdsb2JhbFNoaW5rTGltaXQgfHwgLjIsXG4gICAgICAgICAgICBmb250U2l6ZUVubGFyZ2VGYWN0b3I6IG51bGwgIT09IChfZiA9IG9wdGlvbnMuZm9udFNpemVFbmxhcmdlRmFjdG9yKSAmJiB2b2lkIDAgIT09IF9mID8gX2YgOiAxLjUsXG4gICAgICAgICAgICBmaWxsaW5nUmF0aW86IG51bGwgIT09IChfZyA9IG9wdGlvbnMuZmlsbGluZ1JhdGlvKSAmJiB2b2lkIDAgIT09IF9nID8gX2cgOiAuNyxcbiAgICAgICAgICAgIGZpbGxpbmdUaW1lczogbnVsbCAhPT0gKF9oID0gb3B0aW9ucy5maWxsaW5nVGltZXMpICYmIHZvaWQgMCAhPT0gX2ggPyBfaCA6IDQsXG4gICAgICAgICAgICBmaWxsaW5nWFN0ZXA6IG9wdGlvbnMuZmlsbGluZ1hSYXRpb1N0ZXAgPyBNYXRoLm1heChNYXRoLmZsb29yKG9wdGlvbnMuc2l6ZVswXSAqIG9wdGlvbnMuZmlsbGluZ1hSYXRpb1N0ZXApLCAxKSA6IG51bGwgIT09IChfaiA9IG9wdGlvbnMuZmlsbGluZ1hTdGVwKSAmJiB2b2lkIDAgIT09IF9qID8gX2ogOiA0LFxuICAgICAgICAgICAgZmlsbGluZ1lTdGVwOiBvcHRpb25zLmZpbGxpbmdZUmF0aW9TdGVwID8gTWF0aC5tYXgoTWF0aC5mbG9vcihvcHRpb25zLnNpemVbMV0gKiBvcHRpb25zLmZpbGxpbmdZUmF0aW9TdGVwKSwgMSkgOiBudWxsICE9PSAoX2sgPSBvcHRpb25zLmZpbGxpbmdZU3RlcCkgJiYgdm9pZCAwICE9PSBfayA/IF9rIDogNCxcbiAgICAgICAgICAgIGZpbGxpbmdJbml0aWFsRm9udFNpemU6IG9wdGlvbnMuZmlsbGluZ0luaXRpYWxGb250U2l6ZSxcbiAgICAgICAgICAgIGZpbGxpbmdEZWx0YUZvbnRTaXplOiBvcHRpb25zLmZpbGxpbmdEZWx0YUZvbnRTaXplLFxuICAgICAgICAgICAgZmlsbGluZ0luaXRpYWxPcGFjaXR5OiBudWxsICE9PSAoX2wgPSBvcHRpb25zLmZpbGxpbmdJbml0aWFsT3BhY2l0eSkgJiYgdm9pZCAwICE9PSBfbCA/IF9sIDogLjgsXG4gICAgICAgICAgICBmaWxsaW5nRGVsdGFPcGFjaXR5OiBudWxsICE9PSAoX20gPSBvcHRpb25zLmZpbGxpbmdEZWx0YU9wYWNpdHkpICYmIHZvaWQgMCAhPT0gX20gPyBfbSA6IC4wNSxcbiAgICAgICAgICAgIGdldEZpbGxpbmdGb250RmFtaWx5OiBmaWVsZChvcHRpb25zLmZpbGxpbmdGb250RmFtaWx5IHx8IFwic2Fucy1zZXJpZlwiKSxcbiAgICAgICAgICAgIGdldEZpbGxpbmdGb250U3R5bGU6IGZpZWxkKG9wdGlvbnMuZmlsbGluZ0ZvbnRTdHlsZSB8fCBcIm5vcm1hbFwiKSxcbiAgICAgICAgICAgIGdldEZpbGxpbmdGb250V2VpZ2h0OiBmaWVsZChvcHRpb25zLmZpbGxpbmdGb250V2VpZ2h0IHx8IFwibm9ybWFsXCIpLFxuICAgICAgICAgICAgZ2V0RmlsbGluZ1BhZGRpbmc6IGZpZWxkKG51bGwgIT09IChfbyA9IG9wdGlvbnMuZmlsbGluZ1BhZGRpbmcpICYmIHZvaWQgMCAhPT0gX28gPyBfbyA6IC40KSxcbiAgICAgICAgICAgIGZpbGxpbmdSb3RhdGVMaXN0OiBudWxsICE9PSAoX3AgPSBvcHRpb25zLmZpbGxpbmdSb3RhdGVMaXN0KSAmJiB2b2lkIDAgIT09IF9wID8gX3AgOiBbIDAsIDkwIF0sXG4gICAgICAgICAgICBmaWxsaW5nRGVsdGFGb250U2l6ZUZhY3RvcjogbnVsbCAhPT0gKF9xID0gb3B0aW9ucy5maWxsaW5nRGVsdGFGb250U2l6ZUZhY3RvcikgJiYgdm9pZCAwICE9PSBfcSA/IF9xIDogLjIsXG4gICAgICAgICAgICBmaWxsaW5nQ29sb3JMaXN0OiBvcHRpb25zLmZpbGxpbmdDb2xvckxpc3QgfHwgWyBcIiM1MzdFRjVcIiBdLFxuICAgICAgICAgICAgc2FtZUNvbG9yTGlzdDogITEsXG4gICAgICAgICAgICBtaW5Jbml0Rm9udFNpemU6IG51bGwgIT09IChfciA9IG9wdGlvbnMubWluSW5pdEZvbnRTaXplKSAmJiB2b2lkIDAgIT09IF9yID8gX3IgOiAxMCxcbiAgICAgICAgICAgIG1pbkZvbnRTaXplOiBudWxsICE9PSAoX3MgPSBvcHRpb25zLm1pbkZvbnRTaXplKSAmJiB2b2lkIDAgIT09IF9zID8gX3MgOiA0LFxuICAgICAgICAgICAgbWluRmlsbEZvbnRTaXplOiBudWxsICE9PSAoX3QgPSBvcHRpb25zLm1pbkZpbGxGb250U2l6ZSkgJiYgdm9pZCAwICE9PSBfdCA/IF90IDogMlxuICAgICAgICB9LCBzYW1lQ29sb3JMaXN0ID0gY29sb3JMaXN0RXF1YWwod29yZHNDb25maWcuY29sb3JMaXN0LCBsYXlvdXRDb25maWcuZmlsbGluZ0NvbG9yTGlzdCk7XG4gICAgICAgIGxheW91dENvbmZpZy5zYW1lQ29sb3JMaXN0ID0gc2FtZUNvbG9yTGlzdCwgaW5pdENvbG9yU2NhbGUoZGF0YSwgd29yZHNDb25maWcsIGxheW91dENvbmZpZywgb3B0aW9ucyksIFxuICAgICAgICBpbml0RmlsbGluZ1dvcmRzRm9udFNpemUoZGF0YSwgd29yZHNDb25maWcsIGxheW91dENvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KTtcbiAgICAgICAgY29uc3Qge2dldFRleHQ6IGdldFRleHQsIGdldEZvbnRGYW1pbHk6IGdldEZvbnRGYW1pbHksIGdldEZvbnRTdHlsZTogZ2V0Rm9udFN0eWxlLCBnZXRGb250V2VpZ2h0OiBnZXRGb250V2VpZ2h0LCBnZXRQYWRkaW5nOiBnZXRQYWRkaW5nLCBnZXRDb2xvcjogZ2V0Q29sb3IsIGdldEZpbGxpbmdDb2xvcjogZ2V0RmlsbGluZ0NvbG9yLCBnZXRDb2xvckhleDogZ2V0Q29sb3JIZXgsIGZvbnRTaXplU2NhbGU6IGZvbnRTaXplU2NhbGUsIGNvbG9yU2NhbGU6IGNvbG9yU2NhbGUsIGZpbGxpbmdDb2xvclNjYWxlOiBmaWxsaW5nQ29sb3JTY2FsZSwgZ2V0Rm9udE9wYWNpdHk6IGdldEZvbnRPcGFjaXR5LCByb3RhdGVMaXN0OiByb3RhdGVMaXN0fSA9IHdvcmRzQ29uZmlnLCB3b3JkcyA9IGRhdGEubWFwKChkYXR1bSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRleHQ6IGdldFRleHQoZGF0dW0pLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGdldEZvbnRGYW1pbHkoZGF0dW0pLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGdldEZvbnRXZWlnaHQoZGF0dW0pLFxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogZ2V0Rm9udFN0eWxlKGRhdHVtKSxcbiAgICAgICAgICAgICAgICByb3RhdGU6IHJvdGF0ZUxpc3Rbfn4oc2VnbWVudGF0aW9uSW5wdXQucmFuZG9tR2VuZXJhdG9yKCkgKiByb3RhdGVMaXN0Lmxlbmd0aCldLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBNYXRoLm1heChsYXlvdXRDb25maWcubWluSW5pdEZvbnRTaXplLCB+fmZvbnRTaXplU2NhbGUoZGF0dW0pKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBnZXRGb250T3BhY2l0eShkYXR1bSksXG4gICAgICAgICAgICAgICAgcGFkZGluZzogZ2V0UGFkZGluZyhkYXR1bSksXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldENvbG9ySGV4ICYmIGdldENvbG9ySGV4KGRhdHVtKSB8fCBjb2xvclNjYWxlICYmIGNvbG9yU2NhbGUoZ2V0Q29sb3IoZGF0dW0pKSB8fCBcImJsYWNrXCIsXG4gICAgICAgICAgICAgICAgZmlsbGluZ0NvbG9yOiAhZ2V0RmlsbGluZ0NvbG9yIHx8IChudWxsID09PSAoX2EgPSBvcHRpb25zLmNvbG9yRmllbGQpIHx8IHZvaWQgMCA9PT0gX2EgPyB2b2lkIDAgOiBfYS5maWVsZCkgPT09IChudWxsID09PSAoX2IgPSBvcHRpb25zLmZpbGxpbmdDb2xvckZpZWxkKSB8fCB2b2lkIDAgPT09IF9iID8gdm9pZCAwIDogX2IuZmllbGQpICYmIHNhbWVDb2xvckxpc3QgPyB2b2lkIDAgOiBnZXRDb2xvckhleCAmJiBnZXRDb2xvckhleChkYXR1bSkgfHwgZmlsbGluZ0NvbG9yU2NhbGUgJiYgZmlsbGluZ0NvbG9yU2NhbGUoZ2V0RmlsbGluZ0NvbG9yKGRhdHVtKSkgfHwgXCJibGFja1wiLFxuICAgICAgICAgICAgICAgIGRhdHVtOiBkYXR1bSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBoYXNQbGFjZWQ6ICExXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSksIHdvcmRzTWF4Rm9udFNpemUgPSBtYXhJbkFycmF5KHdvcmRzLm1hcCgod29yZCA9PiB3b3JkLmZvbnRTaXplKSkpO1xuICAgICAgICB3b3Jkcy5mb3JFYWNoKCh3b3JkID0+IHdvcmQud2VpZ2h0ID0gd29yZC5mb250U2l6ZSAvIHdvcmRzTWF4Rm9udFNpemUpKSwgd29yZHMuc29ydCgoKGEsIGIpID0+IGIud2VpZ2h0IC0gYS53ZWlnaHQpKTtcbiAgICAgICAgY29uc3Qge2ZpbGxpbmdXb3JkczogZmlsbGluZ1dvcmRzLCBzdWNjZXNzZWRXb3Jkczogc3VjY2Vzc2VkV29yZHMsIGZhaWxlZFdvcmRzOiBmYWlsZWRXb3Jkc30gPSBjbG91ZCh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpLCB0ZXh0S2V5ID0gbnVsbCAhPT0gKF92ID0gbnVsbCA9PT0gKF91ID0gb3B0aW9ucy50ZXh0KSB8fCB2b2lkIDAgPT09IF91ID8gdm9pZCAwIDogX3UuZmllbGQpICYmIHZvaWQgMCAhPT0gX3YgPyBfdiA6IFwidGV4dEtleVwiLCBkYXRhSW5kZXhLZXkgPSBudWxsICE9PSAoX3cgPSBvcHRpb25zLmRhdGFJbmRleEtleSkgJiYgdm9pZCAwICE9PSBfdyA/IF93IDogXCJkZWZhdWx0RGF0YUluZGV4S2V5XCIsIGFzID0gb3B0aW9ucy5hcyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgT1VUUFVUKSwgb3B0aW9ucy5hcykgOiBPVVRQVVQ7XG4gICAgICAgIGxldCB3LCB0O1xuICAgICAgICBjb25zdCBtb2RLZXl3b3JkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB3ID0gd29yZHNbaV0sIHQgPSB3LmRhdHVtLCB0W2FzLnhdID0gdy54LCBcbiAgICAgICAgdFthcy55XSA9IHcueSwgdFthcy5mb250RmFtaWx5XSA9IHcuZm9udEZhbWlseSwgdFthcy5mb250U2l6ZV0gPSB3LmZvbnRTaXplLCB0W2FzLmZvbnRTdHlsZV0gPSB3LmZvbnRTdHlsZSwgXG4gICAgICAgIHRbYXMuZm9udFdlaWdodF0gPSB3LmZvbnRXZWlnaHQsIHRbYXMuYW5nbGVdID0gZGVncmVlVG9SYWRpYW4ody5yb3RhdGUpLCB0W2FzLm9wYWNpdHldID0gdy5vcGFjaXR5LCBcbiAgICAgICAgdFthcy52aXNpYmxlXSA9IHcudmlzaWJsZSwgdFthcy5pc0ZpbGxpbmdXb3JkXSA9ICExLCB0W2FzLmNvbG9yXSA9IHcuY29sb3IsIHRbZGF0YUluZGV4S2V5XSA9IGAke3cudGV4dH1fJHtpfV9rZXl3b3JkYCwgXG4gICAgICAgIG1vZEtleXdvcmRzLnB1c2godCk7XG4gICAgICAgIGNvbnN0IGZpbGxpbmdXb3Jkc0RhdGEgPSBbXTtcbiAgICAgICAgaWYgKGZpbGxpbmdXb3Jkcy5mb3JFYWNoKCgod29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB0ID0gT2JqZWN0LmFzc2lnbih7fSwgd29yZC5kYXR1bSk7XG4gICAgICAgICAgICB0W2FzLnhdID0gd29yZC54LCB0W2FzLnldID0gd29yZC55LCB0W2FzLmZvbnRGYW1pbHldID0gd29yZC5mb250RmFtaWx5LCB0W2FzLmZvbnRTaXplXSA9IHdvcmQuZm9udFNpemUsIFxuICAgICAgICAgICAgdFthcy5mb250U3R5bGVdID0gd29yZC5mb250U3R5bGUsIHRbYXMuZm9udFdlaWdodF0gPSB3b3JkLmZvbnRXZWlnaHQsIHRbYXMuYW5nbGVdID0gZGVncmVlVG9SYWRpYW4od29yZC5yb3RhdGUpLCBcbiAgICAgICAgICAgIHRbYXMub3BhY2l0eV0gPSB3b3JkLm9wYWNpdHksIHRbYXMudmlzaWJsZV0gPSB3b3JkLnZpc2libGUsIHRbYXMuaXNGaWxsaW5nV29yZF0gPSAhMCwgXG4gICAgICAgICAgICB0W2FzLmNvbG9yXSA9IGdldEZpbGxpbmdDb2xvciA/IChudWxsID09PSAoX2EgPSBvcHRpb25zLmNvbG9yRmllbGQpIHx8IHZvaWQgMCA9PT0gX2EgPyB2b2lkIDAgOiBfYS5maWVsZCkgPT09IChudWxsID09PSAoX2IgPSBvcHRpb25zLmZpbGxpbmdDb2xvckZpZWxkKSB8fCB2b2lkIDAgPT09IF9iID8gdm9pZCAwIDogX2IuZmllbGQpICYmIHNhbWVDb2xvckxpc3QgPyB3b3JkLmNvbG9yIDogd29yZC5maWxsaW5nQ29sb3IgOiBsYXlvdXRDb25maWcuZmlsbGluZ0NvbG9yTGlzdFt+fihzZWdtZW50YXRpb25JbnB1dC5yYW5kb21HZW5lcmF0b3IoKSAqIGxheW91dENvbmZpZy5maWxsaW5nQ29sb3JMaXN0Lmxlbmd0aCldLCBcbiAgICAgICAgICAgIHRbdGV4dEtleV0gPSB3b3JkLnRleHQsIHRbZGF0YUluZGV4S2V5XSA9IGAke3dvcmQudGV4dH1fJHtpbmRleH1fZmlsbGluZ1dvcmRzYCwgXG4gICAgICAgICAgICBmaWxsaW5nV29yZHNEYXRhLnB1c2godCk7XG4gICAgICAgIH0pKSwgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZW1pdChXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVC5BRlRFUl9XT1JEQ0xPVURfU0hBUEVfTEFZT1VULCB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc2VkV29yZHM6IHN1Y2Nlc3NlZFdvcmRzLFxuICAgICAgICAgICAgICAgIGZhaWxlZFdvcmRzOiBmYWlsZWRXb3Jkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGFnZSA9IG51bGwgPT09IChfeCA9IHRoaXMudmlldy5yZW5kZXJlcikgfHwgdm9pZCAwID09PSBfeCA/IHZvaWQgMCA6IF94LnN0YWdlKCk7XG4gICAgICAgICAgICBzdGFnZSAmJiBzdGFnZS5ob29rcy5hZnRlclJlbmRlci50YXAoV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQuQUZURVJfV09SRENMT1VEX1NIQVBFX0RSQVcsICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmVtaXQoV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQuQUZURVJfV09SRENMT1VEX1NIQVBFX0RSQVcsIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VkV29yZHM6IHN1Y2Nlc3NlZFdvcmRzLFxuICAgICAgICAgICAgICAgICAgICBmYWlsZWRXb3JkczogZmFpbGVkV29yZHNcbiAgICAgICAgICAgICAgICB9KSwgc3RhZ2UuaG9va3MuYWZ0ZXJSZW5kZXIudW5UYXAoV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQuQUZURVJfV09SRENMT1VEX1NIQVBFX0RSQVcpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NpdmVSZXN1bHQgPSBtb2RLZXl3b3Jkcy5jb25jYXQoZmlsbGluZ1dvcmRzRGF0YSk7XG4gICAgfVxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudGF0aW9uSW5wdXQgPSBudWxsLCB0aGlzLmRhdGEgPSBudWxsLCB0aGlzLnByb2dyZXNzaXZlUmVzdWx0ID0gbnVsbCwgXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gICAgfVxufVxuXG5jb25zdCBpbml0Q29sb3JTY2FsZSA9IChkYXRhLCB3b3Jkc0NvbmZpZywgbGF5b3V0Q29uZmlnLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHtjb2xvck1vZGU6IGNvbG9yTW9kZSwgZ2V0Q29sb3I6IGdldENvbG9yLCBnZXRGaWxsaW5nQ29sb3I6IGdldEZpbGxpbmdDb2xvcn0gPSB3b3Jkc0NvbmZpZywge3NhbWVDb2xvckxpc3Q6IHNhbWVDb2xvckxpc3R9ID0gbGF5b3V0Q29uZmlnO1xuICAgIGxldCBjb2xvclNjYWxlLCBmaWxsaW5nQ29sb3JTY2FsZSwgY29sb3JMaXN0ID0gd29yZHNDb25maWcuY29sb3JMaXN0LCBmaWxsaW5nQ29sb3JMaXN0ID0gbGF5b3V0Q29uZmlnLmZpbGxpbmdDb2xvckxpc3Q7XG4gICAgaWYgKFwib3JkaW5hbFwiID09PSBjb2xvck1vZGUpIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29sb3JGaWVsZCA9IGRhdGEubWFwKCh3b3JkID0+IGdldENvbG9yKHdvcmQpKSk7XG4gICAgICAgIGlmIChjb2xvclNjYWxlID0gZGF0dW0gPT4gKG5ldyBPcmRpbmFsU2NhbGUpLmRvbWFpbih1bmlxdWVDb2xvckZpZWxkKS5yYW5nZShjb2xvckxpc3QpLnNjYWxlKGRhdHVtKSwgXG4gICAgICAgIGdldEZpbGxpbmdDb2xvciAmJiAoKG51bGwgPT09IChfYSA9IG9wdGlvbnMuY29sb3JGaWVsZCkgfHwgdm9pZCAwID09PSBfYSA/IHZvaWQgMCA6IF9hLmZpZWxkKSAhPT0gKG51bGwgPT09IChfYiA9IG9wdGlvbnMuZmlsbGluZ0NvbG9yRmllbGQpIHx8IHZvaWQgMCA9PT0gX2IgPyB2b2lkIDAgOiBfYi5maWVsZCkgfHwgIXNhbWVDb2xvckxpc3QpKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVmaWxsaW5nQ29sb3JGaWVsZCA9IGRhdGEubWFwKChkYXR1bSA9PiBnZXRGaWxsaW5nQ29sb3IoZGF0dW0pKSk7XG4gICAgICAgICAgICBmaWxsaW5nQ29sb3JTY2FsZSA9IGRhdHVtID0+IChuZXcgT3JkaW5hbFNjYWxlKS5kb21haW4odW5pcXVlZmlsbGluZ0NvbG9yRmllbGQpLnJhbmdlKGZpbGxpbmdDb2xvckxpc3QpLnNjYWxlKGRhdHVtKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIDEgPT09IGNvbG9yTGlzdC5sZW5ndGggJiYgKGNvbG9yTGlzdCA9IFsgY29sb3JMaXN0WzBdLCBjb2xvckxpc3RbMF0gXSk7XG4gICAgICAgIGNvbnN0IHZhbHVlU2NhbGUgPSAobmV3IExpbmVhclNjYWxlKS5kb21haW4oZXh0ZW50KGdldENvbG9yLCBkYXRhKSkucmFuZ2UoY29sb3JMaXN0KTtcbiAgICAgICAgaWYgKGNvbG9yU2NhbGUgPSBpID0+IHZhbHVlU2NhbGUuc2NhbGUoaSksIGdldEZpbGxpbmdDb2xvciAmJiAoKG51bGwgPT09IChfYyA9IG9wdGlvbnMuY29sb3JGaWVsZCkgfHwgdm9pZCAwID09PSBfYyA/IHZvaWQgMCA6IF9jLmZpZWxkKSAhPT0gKG51bGwgPT09IChfZCA9IG9wdGlvbnMuZmlsbGluZ0NvbG9yRmllbGQpIHx8IHZvaWQgMCA9PT0gX2QgPyB2b2lkIDAgOiBfZC5maWVsZCkgfHwgIXNhbWVDb2xvckxpc3QpKSB7XG4gICAgICAgICAgICAxID09PSBmaWxsaW5nQ29sb3JMaXN0Lmxlbmd0aCAmJiAoZmlsbGluZ0NvbG9yTGlzdCA9IFsgZmlsbGluZ0NvbG9yTGlzdFswXSwgZmlsbGluZ0NvbG9yTGlzdFswXSBdKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGxpbmdWYWx1ZVNjYWxlID0gKG5ldyBMaW5lYXJTY2FsZSkuZG9tYWluKGV4dGVudChnZXRGaWxsaW5nQ29sb3IsIGRhdGEpKS5yYW5nZShmaWxsaW5nQ29sb3JMaXN0KTtcbiAgICAgICAgICAgIGZpbGxpbmdDb2xvclNjYWxlID0gaSA9PiBmaWxsaW5nVmFsdWVTY2FsZS5zY2FsZShpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHdvcmRzQ29uZmlnLCB7XG4gICAgICAgIGNvbG9yU2NhbGU6IGNvbG9yU2NhbGUsXG4gICAgICAgIGZpbGxpbmdDb2xvclNjYWxlOiBmaWxsaW5nQ29sb3JTY2FsZVxuICAgIH0pO1xufSwgaW5pdEZvbnRTaXplU2NhbGUgPSAoZGF0YSwgd29yZHNDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkgPT4ge1xuICAgIGxldCB7Zm9udFNpemVSYW5nZTogcmFuZ2V9ID0gd29yZHNDb25maWc7XG4gICAgY29uc3Qge2dldEZvbnRTaXplOiBnZXRGb250U2l6ZSwgZ2V0VGV4dDogZ2V0VGV4dH0gPSB3b3Jkc0NvbmZpZztcbiAgICBsZXQgZm9udFNpemVTY2FsZTtcbiAgICBpZiAoZ2V0Rm9udFNpemUpIHtcbiAgICAgICAgaWYgKGdldEZvbnRTaXplICYmIHJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplU2NhbGUgPSAobmV3IFNxcnRTY2FsZSkuZG9tYWluKGV4dGVudChnZXRGb250U2l6ZSwgZGF0YSkpLnJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGZvbnRTaXplU2NhbGUgPSBkYXR1bSA9PiBzaXplU2NhbGUuc2NhbGUoZ2V0Rm9udFNpemUoZGF0dW0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChnZXRGb250U2l6ZSAmJiBpc0Z1bmN0aW9uKGdldEZvbnRTaXplKSAmJiAhcmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSAuNSwgW21pbiwgbWF4XSA9IGV4dGVudChnZXRGb250U2l6ZSwgZGF0YSksIHdvcmRzID0gZGF0YS5tYXAoKGRhdHVtID0+ICh7XG4gICAgICAgICAgICAgICAgdGV4dDogZ2V0VGV4dChkYXR1bSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGdldEZvbnRTaXplKGRhdHVtKSxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IG1heCA9PT0gbWluID8gMSA6IChnZXRGb250U2l6ZShkYXR1bSkgLSBtaW4pIC8gKG1heCAtIG1pbilcbiAgICAgICAgICAgIH0pKSksIHggPSBnZXRJbml0aWFsRm9udFNpemUod29yZHMsIHNlZ21lbnRhdGlvbk91dHB1dCwgITApO1xuICAgICAgICAgICAgcmFuZ2UgPSBbIH5+KGEgKiB4KSwgfn54IF07XG4gICAgICAgICAgICBjb25zdCBzaXplU2NhbGUgPSAobmV3IFNxcnRTY2FsZSkuZG9tYWluKGV4dGVudChnZXRGb250U2l6ZSwgZGF0YSkpLnJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGZvbnRTaXplU2NhbGUgPSBkYXR1bSA9PiBzaXplU2NhbGUuc2NhbGUoZ2V0Rm9udFNpemUoZGF0dW0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gZGF0YS5tYXAoKHdvcmQgPT4gKHtcbiAgICAgICAgICAgIHRleHQ6IGdldFRleHQod29yZClcbiAgICAgICAgfSkpKSwgeCA9IGdldEluaXRpYWxGb250U2l6ZSh3b3Jkcywgc2VnbWVudGF0aW9uT3V0cHV0LCAhMSk7XG4gICAgICAgIGZvbnRTaXplU2NhbGUgPSBmdW5jdG9yKHgpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHdvcmRzQ29uZmlnLCB7XG4gICAgICAgIGdldEZvbnRTaXplOiBnZXRGb250U2l6ZSxcbiAgICAgICAgZm9udFNpemVSYW5nZTogcmFuZ2UsXG4gICAgICAgIGZvbnRTaXplU2NhbGU6IGZvbnRTaXplU2NhbGVcbiAgICB9KTtcbn0sIGdldEluaXRpYWxGb250U2l6ZSA9ICh3b3Jkcywgc2VnbWVudGF0aW9uT3V0cHV0LCB3ZWlnaHQpID0+IHtcbiAgICBjb25zdCBzaGFwZUFyZWEgPSBzZWdtZW50YXRpb25PdXRwdXQuc2hhcGVBcmVhLCByYXRpbyA9IHNlZ21lbnRhdGlvbk91dHB1dC5yYXRpbywgcmVnaW9ucyA9IHNlZ21lbnRhdGlvbk91dHB1dC5zZWdtZW50YXRpb24ucmVnaW9ucywgc2hhcGVTaXplTGltaXRUZXh0TGVuZ3RoID0gTWF0aC5jZWlsKE1hdGguc3FydChzaGFwZUFyZWEpIC8gMTIpLCB3b3JkQXJlYSA9IHdvcmRzLnJlZHVjZSgoKGFjYywgd29yZCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gY2FsVGV4dExlbmd0aCh3b3JkLnRleHQpO1xuICAgICAgICByZXR1cm4gdGV4dExlbmd0aCA8IHNoYXBlU2l6ZUxpbWl0VGV4dExlbmd0aCA/IGFjYyArIHRleHRMZW5ndGggKiAod2VpZ2h0ID8gKC41ICsgLjUgKiB3b3JkLndlaWdodCkgKiogMiA6IDEpIDogYWNjO1xuICAgIH0pLCAwKTtcbiAgICBpZiAoMCA9PT0gd29yZEFyZWEpIHJldHVybiAxMjtcbiAgICBsZXQgeCA9IDIwO1xuICAgIGlmICgxID09PSByZWdpb25zLmxlbmd0aCkgeCA9IE1hdGguc3FydChyYXRpbyAqIChzaGFwZUFyZWEgLyAoMS43ICogd29yZEFyZWEpKSk7IGVsc2Uge1xuICAgICAgICBjb25zdCB4QXJyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVnaW9uQXJlYSA9IHJlZ2lvbnNbaV0uYXJlYSwgcmVnaW9uQXNwZWN0ID0gcmVnaW9uc1tpXS5yYXRpbywgcmVnaW9uUmF0aW8gPSByZWdpb25BcmVhIC8gc2hhcGVBcmVhO1xuICAgICAgICAgICAgaWYgKHJlZ2lvblJhdGlvIDwgLjEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgcmVnaW9uV29yZEFyZWEgPSByZWdpb25SYXRpbyAqICh3b3JkQXJlYSAqIChyZWdpb25Bc3BlY3QgPCAxID8gMi43IC0gcmVnaW9uQXNwZWN0IDogMS43KSksIHggPSBNYXRoLnNxcnQocmF0aW8gKiAocmVnaW9uQXJlYSAvIHJlZ2lvbldvcmRBcmVhKSk7XG4gICAgICAgICAgICB4QXJyLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IHhBcnIubGVuZ3RoID8gTWF0aC5taW4oLi4ueEFycikgOiBNYXRoLnNxcnQocmF0aW8gKiAoc2hhcGVBcmVhIC8gKDEuNyAqIHdvcmRBcmVhKSkpO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIGluaXRGaWxsaW5nV29yZHNGb250U2l6ZShkYXRhLCB3b3Jkc0NvbmZpZywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBjb25zdCB7Z2V0VGV4dDogZ2V0VGV4dH0gPSB3b3Jkc0NvbmZpZztcbiAgICBsZXQge2ZpbGxpbmdJbml0aWFsRm9udFNpemU6IGZpbGxpbmdJbml0aWFsRm9udFNpemUsIGZpbGxpbmdEZWx0YUZvbnRTaXplOiBmaWxsaW5nRGVsdGFGb250U2l6ZX0gPSBsYXlvdXRDb25maWc7XG4gICAgY29uc3Qge2ZpbGxpbmdSYXRpbzogZmlsbGluZ1JhdGlvfSA9IGxheW91dENvbmZpZywgc2hhcGVTaXplTGltaXRUZXh0TGVuZ3RoID0gTWF0aC5jZWlsKE1hdGguc3FydChzZWdtZW50YXRpb25PdXRwdXQuc2hhcGVBcmVhKSAvIDQpO1xuICAgIGlmICghZmlsbGluZ0luaXRpYWxGb250U2l6ZSB8fCAhZmlsbGluZ0RlbHRhRm9udFNpemUpIHtcbiAgICAgICAgY29uc3QgYSA9IGZpbGxpbmdSYXRpbyAvIDEwMCwgYXZlcmFnZUxlbmd0aCA9IGRhdGEucmVkdWNlKCgoYWNjLCB3b3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxUZXh0TGVuZ3RoKGdldFRleHQod29yZCkpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA+IHNoYXBlU2l6ZUxpbWl0VGV4dExlbmd0aCA/IGFjYyA6IGFjYyArIGxlbmd0aDtcbiAgICAgICAgfSksIDApIC8gZGF0YS5sZW5ndGg7XG4gICAgICAgIGxldCBmb250U2l6ZTtcbiAgICAgICAgaWYgKDAgPT09IGF2ZXJhZ2VMZW5ndGgpIGZvbnRTaXplID0gODsgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gLjIgKiBzZWdtZW50YXRpb25PdXRwdXQuc2hhcGVBcmVhO1xuICAgICAgICAgICAgZm9udFNpemUgPSBNYXRoLnNxcnQoYSAqIChhcmVhIC8gYXZlcmFnZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGxpbmdJbml0aWFsRm9udFNpemUgPSB+fmZvbnRTaXplLCBmaWxsaW5nRGVsdGFGb250U2l6ZSA9IGZvbnRTaXplICogbGF5b3V0Q29uZmlnLmZpbGxpbmdEZWx0YUZvbnRTaXplRmFjdG9yLCBcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsYXlvdXRDb25maWcsIHtcbiAgICAgICAgICAgIGZpbGxpbmdJbml0aWFsRm9udFNpemU6IGZpbGxpbmdJbml0aWFsRm9udFNpemUsXG4gICAgICAgICAgICBmaWxsaW5nRGVsdGFGb250U2l6ZTogZmlsbGluZ0RlbHRhRm9udFNpemVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBleHRlbnQgPSAoZmllbGQsIGRhdGEpID0+IHtcbiAgICBsZXQgbWluID0gMSAvIDAsIG1heCA9IC0xIC8gMDtcbiAgICBjb25zdCBuID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHYgPSB0b051bWJlcihmaWVsZChkYXRhW2ldKSksIHYgPCBtaW4gJiYgKG1pbiA9IHYpLCBcbiAgICB2ID4gbWF4ICYmIChtYXggPSB2KTtcbiAgICByZXR1cm4gMSA9PT0gZGF0YS5sZW5ndGggJiYgbWluID09PSBtYXggJiYgKG1pbiAtPSAxZTQpLCBbIG1pbiwgbWF4IF07XG59LCBmaWVsZCA9IG9wdGlvbiA9PiBvcHRpb24gPyBcInN0cmluZ1wiID09IHR5cGVvZiBvcHRpb24gfHwgXCJudW1iZXJcIiA9PSB0eXBlb2Ygb3B0aW9uID8gKCkgPT4gb3B0aW9uIDogaXNGdW5jdGlvbihvcHRpb24pID8gb3B0aW9uIDogZGF0dW0gPT4gZGF0dW1bb3B0aW9uLmZpZWxkXSA6IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allocateWords: () => (/* binding */ allocateWords),\n/* harmony export */   removeBorder: () => (/* binding */ removeBorder),\n/* harmony export */   scaleAndMiddleShape: () => (/* binding */ scaleAndMiddleShape),\n/* harmony export */   segmentation: () => (/* binding */ segmentation)\n/* harmony export */ });\nfunction segmentation(segmentationInput) {\n    const {size: size, maskCanvas: maskCanvas} = segmentationInput, imageData = maskCanvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    }).getImageData(0, 0, maskCanvas.width, maskCanvas.height), labels = new Array(size[0] * size[1]).fill(0);\n    let curLabel = 1;\n    const offset = [ [ 0, 1 ], [ 1, 0 ], [ -1, 0 ], [ 0, -1 ] ];\n    let queue = [];\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) if (0 === labels[i * size[0] + j] && !segmentationInput.isEmptyPixel(imageData, i, j)) {\n        labels[i * size[0] + j] = curLabel, queue.push([ i, j ]);\n        for (let k = 0; k < queue.length; k++) for (let m = 0; m < 4; m++) {\n            let row = queue[k][0] + offset[m][0], col = queue[k][1] + offset[m][1];\n            row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, \n            0 !== labels[row * size[0] + col] || segmentationInput.isEmptyPixel(imageData, row, col) || (labels[row * size[0] + col] = curLabel, \n            queue.push([ row, col ]));\n        }\n        curLabel++, queue = [];\n    }\n    const boundaries = {}, areas = {}, centers = {}, maxPoints = {}, maxR = {}, ratios = {}, shapeBounds = {\n        x1: 1 / 0,\n        x2: -1 / 0,\n        y1: 1 / 0,\n        y2: -1 / 0,\n        width: 0,\n        height: 0\n    };\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {\n        const label = labels[i * size[0] + j];\n        0 !== label && (isBoundaryPixel(i, j) && (boundaries[label] = boundaries[label] || [], \n        boundaries[label].push([ j, i ]), maxPoints[label] || (maxPoints[label] = [ 1 / 0, -1 / 0, 1 / 0, -1 / 0 ]), \n        i < maxPoints[label][0] && (maxPoints[label][0] = i), i > maxPoints[label][1] && (maxPoints[label][1] = i), \n        j < maxPoints[label][2] && (maxPoints[label][2] = j), j > maxPoints[label][3] && (maxPoints[label][3] = j), \n        j < shapeBounds.x1 && (shapeBounds.x1 = j), j > shapeBounds.x2 && (shapeBounds.x2 = j), \n        i < shapeBounds.y1 && (shapeBounds.y1 = i), i > shapeBounds.y2 && (shapeBounds.y2 = i)), \n        areas[label] = areas[label] || 0, areas[label]++);\n    }\n    const allBoundaries = [];\n    for (const label in boundaries) {\n        const boundary = boundaries[label], x = ~~(boundary.reduce(((acc, cur) => acc + cur[0]), 0) / boundary.length), y = ~~(boundary.reduce(((acc, cur) => acc + cur[1]), 0) / boundary.length);\n        centers[label] = [ x, y ], allBoundaries.push(...boundary);\n        const [yMin, yMax, xMin, xMax] = maxPoints[label];\n        maxR[label] = ~~Math.max(Math.sqrt((x - xMin) ** 2 + (y - yMin) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMin) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMin) ** 2)), \n        ratios[label] = (xMax - xMin) / (yMax - yMin);\n    }\n    const regions = Object.keys(centers).map((key => ({\n        label: key - 1,\n        boundary: boundaries[key],\n        area: areas[key],\n        center: centers[key],\n        maxPoint: maxPoints[key],\n        maxR: maxR[key],\n        ratio: ratios[key]\n    })));\n    shapeBounds.width = shapeBounds.x2 - shapeBounds.x1 + 1, shapeBounds.height = shapeBounds.y2 - shapeBounds.y1 + 1;\n    const x = ~~(allBoundaries.reduce(((acc, cur) => acc + cur[0]), 0) / allBoundaries.length), y = ~~(allBoundaries.reduce(((acc, cur) => acc + cur[1]), 0) / allBoundaries.length), shapeMaxR = ~~Math.max(Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y1) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y1) ** 2)), shapeRatio = shapeBounds.width / shapeBounds.height, shapeArea = Object.keys(areas).reduce(((acc, key) => acc + areas[key]), 0), segmentation = {\n        regions: regions,\n        labels: labels,\n        labelNumber: curLabel - 1\n    };\n    return Object.assign(segmentationInput, {\n        segmentation: segmentation,\n        shapeBounds: shapeBounds,\n        shapeMaxR: shapeMaxR,\n        shapeRatio: shapeRatio,\n        shapeCenter: [ x, y ],\n        shapeArea: shapeArea\n    });\n    function isBoundaryPixel(i, j) {\n        const offset = [ [ 0, 1 ], [ 1, 0 ], [ -1, 0 ], [ 0, -1 ] ];\n        if (0 === i || 0 === j || i === size[1] - 1 || j === size[0] - 1) return !0;\n        for (let k = 0; k < 4; k++) {\n            let row = i + offset[k][0], col = j + offset[k][1];\n            if (row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, \n            0 === labels[row * size[0] + col]) return !0;\n        }\n        return !1;\n    }\n}\n\nfunction removeBorder(image, canvas, isEmptyPixel) {\n    canvas.width = image.width, canvas.height = image.height;\n    const ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.drawImage(image, 0, 0);\n    const width = canvas.width, imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    let top = 0, bottom = imageData.height, left = 0, right = imageData.width;\n    const rowBlank = (width, y) => {\n        for (let x = 0; x < width; ++x) if (!isEmptyPixel(imageData, y, x)) return !1;\n        return !0;\n    }, columnBlank = (x, y0, y1) => {\n        for (let y = y0; y < y1; ++y) if (!isEmptyPixel(imageData, y, x)) return !1;\n        return !0;\n    };\n    for (;top < bottom && rowBlank(width, top); ) ++top;\n    for (;bottom - 1 > top && rowBlank(width, bottom - 1); ) --bottom;\n    for (;left < right && columnBlank(left, top, bottom); ) ++left;\n    for (;right - 1 > left && columnBlank(right - 1, top, bottom); ) --right;\n    const trimmed = ctx.getImageData(left, top, right - left, bottom - top);\n    return canvas.width = trimmed.width, canvas.height = trimmed.height, ctx.clearRect(0, 0, canvas.width, canvas.height), \n    ctx.putImageData(trimmed, 0, 0), canvas;\n}\n\nfunction scaleAndMiddleShape(image, size) {\n    const width = image.width, height = image.height;\n    let scale = size[0] / width;\n    height * scale > size[1] && (scale = size[1] / height);\n    const newWidth = Math.floor(scale * width), newHeight = Math.floor(scale * height);\n    return {\n        x: (size[0] - newWidth) / 2,\n        y: (size[1] - newHeight) / 2,\n        width: newWidth,\n        height: newHeight,\n        scale: scale\n    };\n}\n\nfunction allocateWords(words, segmentationOutput) {\n    const {segmentation: {regions: regions}} = segmentationOutput;\n    let areaMax = -1 / 0, totalArea = 0, areaMaxIndex = 0;\n    regions.forEach(((region, index) => {\n        const area = region.area;\n        area > areaMax && (areaMax = area, areaMaxIndex = index), totalArea += area;\n    }));\n    let wordsSum = 0;\n    regions.forEach((region => {\n        const area = region.area, regionNum = Math.ceil(area / totalArea * words.length), regionWeight = area / areaMax;\n        region.words = [], region.regionNum = regionNum, region.regionWeight = regionWeight, \n        wordsSum += regionNum;\n    })), wordsSum < words.length && (regions[areaMaxIndex].wordsNum += words.length - wordsSum);\n    let currIndex = areaMaxIndex;\n    const regionNums = regions.map((region => region.regionNum));\n    words.forEach((word => {\n        let failCounter = 0, updateCounter = 0;\n        word.regionIndex = -1;\n        do {\n            if (regionNums[currIndex] > 0 && word.weight <= regions[currIndex].regionWeight) {\n                word.regionIndex = currIndex, regions[currIndex].words.push(word), regionNums[currIndex]--, \n                currIndex = (currIndex + 1) % regions.length;\n                break;\n            }\n            currIndex = (currIndex + 1) % regions.length, failCounter++, updateCounter++, updateCounter > regions.length + 1 && (regions.forEach((region => {\n                region.regionWeight += .15;\n            })), updateCounter = 0);\n        } while (-1 === word.regionIndex && failCounter < 3 * regions.length);\n        -1 === word.regionIndex && (word.regionIndex = areaMaxIndex, regions[areaMaxIndex].words.push(word), \n        regionNums[areaMaxIndex]--);\n    })), regions.forEach((region => {\n        region.words.sort(((a, b) => b.weight - a.weight));\n    }));\n}\n//# sourceMappingURL=segmentation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3NlZ21lbnRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU87QUFDUCxXQUFXLG9DQUFvQztBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBLHdCQUF3QixrQkFBa0IscUJBQXFCLE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxjQUFjLGdCQUFnQixXQUFXLGFBQWE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRCxVQUFVLGlEQUFpRDtBQUMzRCxVQUFVLGdEQUFnRDtBQUMxRCxVQUFVLHlEQUF5RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFdBQVcsZUFBZSxtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlzYWN0b3ItbmV4dC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdmlzYWN0b3IrdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlQDAuMTYuMTEvbm9kZV9tb2R1bGVzL0B2aXNhY3Rvci92Z3JhbW1hci13b3JkY2xvdWQtc2hhcGUvZXMvc2VnbWVudGF0aW9uLmpzPzYzYmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHNlZ21lbnRhdGlvbihzZWdtZW50YXRpb25JbnB1dCkge1xuICAgIGNvbnN0IHtzaXplOiBzaXplLCBtYXNrQ2FudmFzOiBtYXNrQ2FudmFzfSA9IHNlZ21lbnRhdGlvbklucHV0LCBpbWFnZURhdGEgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogITBcbiAgICB9KS5nZXRJbWFnZURhdGEoMCwgMCwgbWFza0NhbnZhcy53aWR0aCwgbWFza0NhbnZhcy5oZWlnaHQpLCBsYWJlbHMgPSBuZXcgQXJyYXkoc2l6ZVswXSAqIHNpemVbMV0pLmZpbGwoMCk7XG4gICAgbGV0IGN1ckxhYmVsID0gMTtcbiAgICBjb25zdCBvZmZzZXQgPSBbIFsgMCwgMSBdLCBbIDEsIDAgXSwgWyAtMSwgMCBdLCBbIDAsIC0xIF0gXTtcbiAgICBsZXQgcXVldWUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVbMV07IGkrKykgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplWzBdOyBqKyspIGlmICgwID09PSBsYWJlbHNbaSAqIHNpemVbMF0gKyBqXSAmJiAhc2VnbWVudGF0aW9uSW5wdXQuaXNFbXB0eVBpeGVsKGltYWdlRGF0YSwgaSwgaikpIHtcbiAgICAgICAgbGFiZWxzW2kgKiBzaXplWzBdICsgal0gPSBjdXJMYWJlbCwgcXVldWUucHVzaChbIGksIGogXSk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcXVldWUubGVuZ3RoOyBrKyspIGZvciAobGV0IG0gPSAwOyBtIDwgNDsgbSsrKSB7XG4gICAgICAgICAgICBsZXQgcm93ID0gcXVldWVba11bMF0gKyBvZmZzZXRbbV1bMF0sIGNvbCA9IHF1ZXVlW2tdWzFdICsgb2Zmc2V0W21dWzFdO1xuICAgICAgICAgICAgcm93ID0gcm93IDwgMCA/IDAgOiByb3cgPj0gc2l6ZVsxXSA/IHNpemVbMV0gLSAxIDogcm93LCBjb2wgPSBjb2wgPCAwID8gMCA6IGNvbCA+PSBzaXplWzBdID8gc2l6ZVswXSAtIDEgOiBjb2wsIFxuICAgICAgICAgICAgMCAhPT0gbGFiZWxzW3JvdyAqIHNpemVbMF0gKyBjb2xdIHx8IHNlZ21lbnRhdGlvbklucHV0LmlzRW1wdHlQaXhlbChpbWFnZURhdGEsIHJvdywgY29sKSB8fCAobGFiZWxzW3JvdyAqIHNpemVbMF0gKyBjb2xdID0gY3VyTGFiZWwsIFxuICAgICAgICAgICAgcXVldWUucHVzaChbIHJvdywgY29sIF0pKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJMYWJlbCsrLCBxdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBib3VuZGFyaWVzID0ge30sIGFyZWFzID0ge30sIGNlbnRlcnMgPSB7fSwgbWF4UG9pbnRzID0ge30sIG1heFIgPSB7fSwgcmF0aW9zID0ge30sIHNoYXBlQm91bmRzID0ge1xuICAgICAgICB4MTogMSAvIDAsXG4gICAgICAgIHgyOiAtMSAvIDAsXG4gICAgICAgIHkxOiAxIC8gMCxcbiAgICAgICAgeTI6IC0xIC8gMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplWzFdOyBpKyspIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZVswXTsgaisrKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxzW2kgKiBzaXplWzBdICsgal07XG4gICAgICAgIDAgIT09IGxhYmVsICYmIChpc0JvdW5kYXJ5UGl4ZWwoaSwgaikgJiYgKGJvdW5kYXJpZXNbbGFiZWxdID0gYm91bmRhcmllc1tsYWJlbF0gfHwgW10sIFxuICAgICAgICBib3VuZGFyaWVzW2xhYmVsXS5wdXNoKFsgaiwgaSBdKSwgbWF4UG9pbnRzW2xhYmVsXSB8fCAobWF4UG9pbnRzW2xhYmVsXSA9IFsgMSAvIDAsIC0xIC8gMCwgMSAvIDAsIC0xIC8gMCBdKSwgXG4gICAgICAgIGkgPCBtYXhQb2ludHNbbGFiZWxdWzBdICYmIChtYXhQb2ludHNbbGFiZWxdWzBdID0gaSksIGkgPiBtYXhQb2ludHNbbGFiZWxdWzFdICYmIChtYXhQb2ludHNbbGFiZWxdWzFdID0gaSksIFxuICAgICAgICBqIDwgbWF4UG9pbnRzW2xhYmVsXVsyXSAmJiAobWF4UG9pbnRzW2xhYmVsXVsyXSA9IGopLCBqID4gbWF4UG9pbnRzW2xhYmVsXVszXSAmJiAobWF4UG9pbnRzW2xhYmVsXVszXSA9IGopLCBcbiAgICAgICAgaiA8IHNoYXBlQm91bmRzLngxICYmIChzaGFwZUJvdW5kcy54MSA9IGopLCBqID4gc2hhcGVCb3VuZHMueDIgJiYgKHNoYXBlQm91bmRzLngyID0gaiksIFxuICAgICAgICBpIDwgc2hhcGVCb3VuZHMueTEgJiYgKHNoYXBlQm91bmRzLnkxID0gaSksIGkgPiBzaGFwZUJvdW5kcy55MiAmJiAoc2hhcGVCb3VuZHMueTIgPSBpKSksIFxuICAgICAgICBhcmVhc1tsYWJlbF0gPSBhcmVhc1tsYWJlbF0gfHwgMCwgYXJlYXNbbGFiZWxdKyspO1xuICAgIH1cbiAgICBjb25zdCBhbGxCb3VuZGFyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBsYWJlbCBpbiBib3VuZGFyaWVzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gYm91bmRhcmllc1tsYWJlbF0sIHggPSB+fihib3VuZGFyeS5yZWR1Y2UoKChhY2MsIGN1cikgPT4gYWNjICsgY3VyWzBdKSwgMCkgLyBib3VuZGFyeS5sZW5ndGgpLCB5ID0gfn4oYm91bmRhcnkucmVkdWNlKCgoYWNjLCBjdXIpID0+IGFjYyArIGN1clsxXSksIDApIC8gYm91bmRhcnkubGVuZ3RoKTtcbiAgICAgICAgY2VudGVyc1tsYWJlbF0gPSBbIHgsIHkgXSwgYWxsQm91bmRhcmllcy5wdXNoKC4uLmJvdW5kYXJ5KTtcbiAgICAgICAgY29uc3QgW3lNaW4sIHlNYXgsIHhNaW4sIHhNYXhdID0gbWF4UG9pbnRzW2xhYmVsXTtcbiAgICAgICAgbWF4UltsYWJlbF0gPSB+fk1hdGgubWF4KE1hdGguc3FydCgoeCAtIHhNaW4pICoqIDIgKyAoeSAtIHlNaW4pICoqIDIpLCBNYXRoLnNxcnQoKHggLSB4TWF4KSAqKiAyICsgKHkgLSB5TWF4KSAqKiAyKSwgTWF0aC5zcXJ0KCh4IC0geE1pbikgKiogMiArICh5IC0geU1heCkgKiogMiksIE1hdGguc3FydCgoeCAtIHhNYXgpICoqIDIgKyAoeSAtIHlNaW4pICoqIDIpKSwgXG4gICAgICAgIHJhdGlvc1tsYWJlbF0gPSAoeE1heCAtIHhNaW4pIC8gKHlNYXggLSB5TWluKTtcbiAgICB9XG4gICAgY29uc3QgcmVnaW9ucyA9IE9iamVjdC5rZXlzKGNlbnRlcnMpLm1hcCgoa2V5ID0+ICh7XG4gICAgICAgIGxhYmVsOiBrZXkgLSAxLFxuICAgICAgICBib3VuZGFyeTogYm91bmRhcmllc1trZXldLFxuICAgICAgICBhcmVhOiBhcmVhc1trZXldLFxuICAgICAgICBjZW50ZXI6IGNlbnRlcnNba2V5XSxcbiAgICAgICAgbWF4UG9pbnQ6IG1heFBvaW50c1trZXldLFxuICAgICAgICBtYXhSOiBtYXhSW2tleV0sXG4gICAgICAgIHJhdGlvOiByYXRpb3Nba2V5XVxuICAgIH0pKSk7XG4gICAgc2hhcGVCb3VuZHMud2lkdGggPSBzaGFwZUJvdW5kcy54MiAtIHNoYXBlQm91bmRzLngxICsgMSwgc2hhcGVCb3VuZHMuaGVpZ2h0ID0gc2hhcGVCb3VuZHMueTIgLSBzaGFwZUJvdW5kcy55MSArIDE7XG4gICAgY29uc3QgeCA9IH5+KGFsbEJvdW5kYXJpZXMucmVkdWNlKCgoYWNjLCBjdXIpID0+IGFjYyArIGN1clswXSksIDApIC8gYWxsQm91bmRhcmllcy5sZW5ndGgpLCB5ID0gfn4oYWxsQm91bmRhcmllcy5yZWR1Y2UoKChhY2MsIGN1cikgPT4gYWNjICsgY3VyWzFdKSwgMCkgLyBhbGxCb3VuZGFyaWVzLmxlbmd0aCksIHNoYXBlTWF4UiA9IH5+TWF0aC5tYXgoTWF0aC5zcXJ0KCh4IC0gc2hhcGVCb3VuZHMueDEpICoqIDIgKyAoeSAtIHNoYXBlQm91bmRzLnkxKSAqKiAyKSwgTWF0aC5zcXJ0KCh4IC0gc2hhcGVCb3VuZHMueDIpICoqIDIgKyAoeSAtIHNoYXBlQm91bmRzLnkyKSAqKiAyKSwgTWF0aC5zcXJ0KCh4IC0gc2hhcGVCb3VuZHMueDEpICoqIDIgKyAoeSAtIHNoYXBlQm91bmRzLnkyKSAqKiAyKSwgTWF0aC5zcXJ0KCh4IC0gc2hhcGVCb3VuZHMueDIpICoqIDIgKyAoeSAtIHNoYXBlQm91bmRzLnkxKSAqKiAyKSksIHNoYXBlUmF0aW8gPSBzaGFwZUJvdW5kcy53aWR0aCAvIHNoYXBlQm91bmRzLmhlaWdodCwgc2hhcGVBcmVhID0gT2JqZWN0LmtleXMoYXJlYXMpLnJlZHVjZSgoKGFjYywga2V5KSA9PiBhY2MgKyBhcmVhc1trZXldKSwgMCksIHNlZ21lbnRhdGlvbiA9IHtcbiAgICAgICAgcmVnaW9uczogcmVnaW9ucyxcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICAgIGxhYmVsTnVtYmVyOiBjdXJMYWJlbCAtIDFcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHNlZ21lbnRhdGlvbklucHV0LCB7XG4gICAgICAgIHNlZ21lbnRhdGlvbjogc2VnbWVudGF0aW9uLFxuICAgICAgICBzaGFwZUJvdW5kczogc2hhcGVCb3VuZHMsXG4gICAgICAgIHNoYXBlTWF4Ujogc2hhcGVNYXhSLFxuICAgICAgICBzaGFwZVJhdGlvOiBzaGFwZVJhdGlvLFxuICAgICAgICBzaGFwZUNlbnRlcjogWyB4LCB5IF0sXG4gICAgICAgIHNoYXBlQXJlYTogc2hhcGVBcmVhXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXNCb3VuZGFyeVBpeGVsKGksIGopIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gWyBbIDAsIDEgXSwgWyAxLCAwIF0sIFsgLTEsIDAgXSwgWyAwLCAtMSBdIF07XG4gICAgICAgIGlmICgwID09PSBpIHx8IDAgPT09IGogfHwgaSA9PT0gc2l6ZVsxXSAtIDEgfHwgaiA9PT0gc2l6ZVswXSAtIDEpIHJldHVybiAhMDtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCA0OyBrKyspIHtcbiAgICAgICAgICAgIGxldCByb3cgPSBpICsgb2Zmc2V0W2tdWzBdLCBjb2wgPSBqICsgb2Zmc2V0W2tdWzFdO1xuICAgICAgICAgICAgaWYgKHJvdyA9IHJvdyA8IDAgPyAwIDogcm93ID49IHNpemVbMV0gPyBzaXplWzFdIC0gMSA6IHJvdywgY29sID0gY29sIDwgMCA/IDAgOiBjb2wgPj0gc2l6ZVswXSA/IHNpemVbMF0gLSAxIDogY29sLCBcbiAgICAgICAgICAgIDAgPT09IGxhYmVsc1tyb3cgKiBzaXplWzBdICsgY29sXSkgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVCb3JkZXIoaW1hZ2UsIGNhbnZhcywgaXNFbXB0eVBpeGVsKSB7XG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGgsIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogITBcbiAgICB9KTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCksIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoLCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgbGV0IHRvcCA9IDAsIGJvdHRvbSA9IGltYWdlRGF0YS5oZWlnaHQsIGxlZnQgPSAwLCByaWdodCA9IGltYWdlRGF0YS53aWR0aDtcbiAgICBjb25zdCByb3dCbGFuayA9ICh3aWR0aCwgeSkgPT4ge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIGlmICghaXNFbXB0eVBpeGVsKGltYWdlRGF0YSwgeSwgeCkpIHJldHVybiAhMTtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGNvbHVtbkJsYW5rID0gKHgsIHkwLCB5MSkgPT4ge1xuICAgICAgICBmb3IgKGxldCB5ID0geTA7IHkgPCB5MTsgKyt5KSBpZiAoIWlzRW1wdHlQaXhlbChpbWFnZURhdGEsIHksIHgpKSByZXR1cm4gITE7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICAgIGZvciAoO3RvcCA8IGJvdHRvbSAmJiByb3dCbGFuayh3aWR0aCwgdG9wKTsgKSArK3RvcDtcbiAgICBmb3IgKDtib3R0b20gLSAxID4gdG9wICYmIHJvd0JsYW5rKHdpZHRoLCBib3R0b20gLSAxKTsgKSAtLWJvdHRvbTtcbiAgICBmb3IgKDtsZWZ0IDwgcmlnaHQgJiYgY29sdW1uQmxhbmsobGVmdCwgdG9wLCBib3R0b20pOyApICsrbGVmdDtcbiAgICBmb3IgKDtyaWdodCAtIDEgPiBsZWZ0ICYmIGNvbHVtbkJsYW5rKHJpZ2h0IC0gMSwgdG9wLCBib3R0b20pOyApIC0tcmlnaHQ7XG4gICAgY29uc3QgdHJpbW1lZCA9IGN0eC5nZXRJbWFnZURhdGEobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgcmV0dXJuIGNhbnZhcy53aWR0aCA9IHRyaW1tZWQud2lkdGgsIGNhbnZhcy5oZWlnaHQgPSB0cmltbWVkLmhlaWdodCwgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLCBcbiAgICBjdHgucHV0SW1hZ2VEYXRhKHRyaW1tZWQsIDAsIDApLCBjYW52YXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZE1pZGRsZVNoYXBlKGltYWdlLCBzaXplKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZS53aWR0aCwgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGxldCBzY2FsZSA9IHNpemVbMF0gLyB3aWR0aDtcbiAgICBoZWlnaHQgKiBzY2FsZSA+IHNpemVbMV0gJiYgKHNjYWxlID0gc2l6ZVsxXSAvIGhlaWdodCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLmZsb29yKHNjYWxlICogd2lkdGgpLCBuZXdIZWlnaHQgPSBNYXRoLmZsb29yKHNjYWxlICogaGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAoc2l6ZVswXSAtIG5ld1dpZHRoKSAvIDIsXG4gICAgICAgIHk6IChzaXplWzFdIC0gbmV3SGVpZ2h0KSAvIDIsXG4gICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQsXG4gICAgICAgIHNjYWxlOiBzY2FsZVxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxvY2F0ZVdvcmRzKHdvcmRzLCBzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBjb25zdCB7c2VnbWVudGF0aW9uOiB7cmVnaW9uczogcmVnaW9uc319ID0gc2VnbWVudGF0aW9uT3V0cHV0O1xuICAgIGxldCBhcmVhTWF4ID0gLTEgLyAwLCB0b3RhbEFyZWEgPSAwLCBhcmVhTWF4SW5kZXggPSAwO1xuICAgIHJlZ2lvbnMuZm9yRWFjaCgoKHJlZ2lvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgYXJlYSA9IHJlZ2lvbi5hcmVhO1xuICAgICAgICBhcmVhID4gYXJlYU1heCAmJiAoYXJlYU1heCA9IGFyZWEsIGFyZWFNYXhJbmRleCA9IGluZGV4KSwgdG90YWxBcmVhICs9IGFyZWE7XG4gICAgfSkpO1xuICAgIGxldCB3b3Jkc1N1bSA9IDA7XG4gICAgcmVnaW9ucy5mb3JFYWNoKChyZWdpb24gPT4ge1xuICAgICAgICBjb25zdCBhcmVhID0gcmVnaW9uLmFyZWEsIHJlZ2lvbk51bSA9IE1hdGguY2VpbChhcmVhIC8gdG90YWxBcmVhICogd29yZHMubGVuZ3RoKSwgcmVnaW9uV2VpZ2h0ID0gYXJlYSAvIGFyZWFNYXg7XG4gICAgICAgIHJlZ2lvbi53b3JkcyA9IFtdLCByZWdpb24ucmVnaW9uTnVtID0gcmVnaW9uTnVtLCByZWdpb24ucmVnaW9uV2VpZ2h0ID0gcmVnaW9uV2VpZ2h0LCBcbiAgICAgICAgd29yZHNTdW0gKz0gcmVnaW9uTnVtO1xuICAgIH0pKSwgd29yZHNTdW0gPCB3b3Jkcy5sZW5ndGggJiYgKHJlZ2lvbnNbYXJlYU1heEluZGV4XS53b3Jkc051bSArPSB3b3Jkcy5sZW5ndGggLSB3b3Jkc1N1bSk7XG4gICAgbGV0IGN1cnJJbmRleCA9IGFyZWFNYXhJbmRleDtcbiAgICBjb25zdCByZWdpb25OdW1zID0gcmVnaW9ucy5tYXAoKHJlZ2lvbiA9PiByZWdpb24ucmVnaW9uTnVtKSk7XG4gICAgd29yZHMuZm9yRWFjaCgod29yZCA9PiB7XG4gICAgICAgIGxldCBmYWlsQ291bnRlciA9IDAsIHVwZGF0ZUNvdW50ZXIgPSAwO1xuICAgICAgICB3b3JkLnJlZ2lvbkluZGV4ID0gLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25OdW1zW2N1cnJJbmRleF0gPiAwICYmIHdvcmQud2VpZ2h0IDw9IHJlZ2lvbnNbY3VyckluZGV4XS5yZWdpb25XZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB3b3JkLnJlZ2lvbkluZGV4ID0gY3VyckluZGV4LCByZWdpb25zW2N1cnJJbmRleF0ud29yZHMucHVzaCh3b3JkKSwgcmVnaW9uTnVtc1tjdXJySW5kZXhdLS0sIFxuICAgICAgICAgICAgICAgIGN1cnJJbmRleCA9IChjdXJySW5kZXggKyAxKSAlIHJlZ2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckluZGV4ID0gKGN1cnJJbmRleCArIDEpICUgcmVnaW9ucy5sZW5ndGgsIGZhaWxDb3VudGVyKyssIHVwZGF0ZUNvdW50ZXIrKywgdXBkYXRlQ291bnRlciA+IHJlZ2lvbnMubGVuZ3RoICsgMSAmJiAocmVnaW9ucy5mb3JFYWNoKChyZWdpb24gPT4ge1xuICAgICAgICAgICAgICAgIHJlZ2lvbi5yZWdpb25XZWlnaHQgKz0gLjE1O1xuICAgICAgICAgICAgfSkpLCB1cGRhdGVDb3VudGVyID0gMCk7XG4gICAgICAgIH0gd2hpbGUgKC0xID09PSB3b3JkLnJlZ2lvbkluZGV4ICYmIGZhaWxDb3VudGVyIDwgMyAqIHJlZ2lvbnMubGVuZ3RoKTtcbiAgICAgICAgLTEgPT09IHdvcmQucmVnaW9uSW5kZXggJiYgKHdvcmQucmVnaW9uSW5kZXggPSBhcmVhTWF4SW5kZXgsIHJlZ2lvbnNbYXJlYU1heEluZGV4XS53b3Jkcy5wdXNoKHdvcmQpLCBcbiAgICAgICAgcmVnaW9uTnVtc1thcmVhTWF4SW5kZXhdLS0pO1xuICAgIH0pKSwgcmVnaW9ucy5mb3JFYWNoKChyZWdpb24gPT4ge1xuICAgICAgICByZWdpb24ud29yZHMuc29ydCgoKGEsIGIpID0+IGIud2VpZ2h0IC0gYS53ZWlnaHQpKTtcbiAgICB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWdtZW50YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/segmentation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WORDCLOUD_SHAPE_HOOK_EVENT: () => (/* binding */ WORDCLOUD_SHAPE_HOOK_EVENT),\n/* harmony export */   calTextLength: () => (/* binding */ calTextLength),\n/* harmony export */   colorListEqual: () => (/* binding */ colorListEqual),\n/* harmony export */   draw: () => (/* binding */ draw),\n/* harmony export */   drawSpiral: () => (/* binding */ drawSpiral),\n/* harmony export */   fakeRandom: () => (/* binding */ fakeRandom),\n/* harmony export */   functor: () => (/* binding */ functor),\n/* harmony export */   isChinese: () => (/* binding */ isChinese),\n/* harmony export */   loadImage: () => (/* binding */ loadImage),\n/* harmony export */   paint: () => (/* binding */ paint),\n/* harmony export */   paintLabels: () => (/* binding */ paintLabels)\n/* harmony export */ });\n/* harmony import */ var _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @visactor/vrender-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vrender-core@0.22.16/node_modules/@visactor/vrender-core/es/graphic/image.js\");\n/* harmony import */ var _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @visactor/vrender-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vrender-core@0.22.16/node_modules/@visactor/vrender-core/es/modules.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isNil.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isValidUrl.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isBase64.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/logger.js\");\n\n\n\n\nvar WORDCLOUD_SHAPE_HOOK_EVENT;\n\n!function(WORDCLOUD_SHAPE_HOOK_EVENT) {\n    WORDCLOUD_SHAPE_HOOK_EVENT.BEFORE_WORDCLOUD_SHAPE_LAYOUT = \"beforeWordcloudShapeLayout\", \n    WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_LAYOUT = \"afterWordcloudShapeLayout\", \n    WORDCLOUD_SHAPE_HOOK_EVENT.AFTER_WORDCLOUD_SHAPE_DRAW = \"afterWordcloudShapeDraw\";\n}(WORDCLOUD_SHAPE_HOOK_EVENT || (WORDCLOUD_SHAPE_HOOK_EVENT = {}));\n\nconst colorListEqual = (arr0, arr1) => {\n    if (1 === arr1.length && \"#537EF5\" === arr1[0]) return !0;\n    if (!Array.isArray(arr0) || !Array.isArray(arr1) || arr0.length !== arr1.length) return !1;\n    for (let i = 0; i < arr0.length; i++) if (arr0[i] !== arr1[i]) return !1;\n    return !0;\n};\n\nconst fakeRandom = () => {\n    let i = -1;\n    const arr = [ 0, .1, .2, .3, .4, .5, .6, .7, .8, .9 ];\n    return () => (i = (i + 1) % arr.length, arr[i]);\n};\n\nconst isChinese = text => /^[\\u4e00-\\u9fa5]+$/.test(text);\n\nconst calTextLength = (text, textLengthLimit) => {\n    if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(text)) return 0;\n    let length = 0;\n    for (const char of text) isChinese(char) ? length += 1 : length += .53;\n    return length;\n};\n\nfunction loadImage(url) {\n    return url && ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(url) || (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(url) || url.startsWith(\"<svg\")) ? new Promise(((resolve, reject) => {\n        var _a;\n        const imageMark = (0,_visactor_vrender_core__WEBPACK_IMPORTED_MODULE_3__.createImage)({\n            image: url\n        }), imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);\n        imgData && \"success\" === imgData.state && imgData.data ? resolve(imgData.data) : (imageMark.successCallback = () => {\n            var _a;\n            if (imageMark) {\n                const imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);\n                imgData && \"success\" === imgData.state && imgData.data ? resolve(imgData.data) : reject(new Error(\"image load failed\" + url));\n            } else reject(new Error(\"image load failed\" + url));\n        }, imageMark.failCallback = () => {\n            _visactor_vutils__WEBPACK_IMPORTED_MODULE_4__.Logger.getInstance().error(\"image \", url);\n        });\n    })) : null;\n}\n\nfunction paintLabels(segmentationOutput) {\n    const {size: size, segmentation: {regions: regions, labels: labels}, shapeBounds: shapeBounds, shapeCenter: shapeCenter} = segmentationOutput, paintCanvas = _visactor_vrender_core__WEBPACK_IMPORTED_MODULE_5__.vglobal.createCanvas({\n        width: size[0],\n        height: size[1]\n    }), ctx = paintCanvas.getContext(\"2d\"), colorList = [ \"#FF0000\", \"#00FF00\", \"#0000FF\", \"#FFFF00\", \"#00FFFF\", \"#FF00FF\" ];\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) 0 === labels[i * size[0] + j] ? ctx.fillStyle = \"#fff\" : ctx.fillStyle = colorList[labels[i * size[0] + j] % colorList.length], \n    ctx.fillRect(j, i, 1, 1);\n    regions.forEach((region => {\n        const {center: [x, y], area: area, boundary: boundary, maxPoint: maxPoint, label: label} = region;\n        ctx.fillStyle = \"#000\", ctx.fillRect(x, y, 3, 3), ctx.font = \"15px serif\", ctx.fillText(area, x, y);\n        for (const [x, y] of boundary) ctx.fillStyle = \"#f00\", ctx.fillRect(x, y, 1, 1);\n        const [iMin, iMax, jMin, jMax] = maxPoint;\n        ctx.fillStyle = \"#00f\", ctx.font = \"15px serif\", ctx.fillRect(jMin, iMin, 3, 3), \n        ctx.fillText(`${label}_min`, jMin, iMin), ctx.fillRect(jMax, iMax, 3, 3), ctx.fillText(`${label}_max`, jMax, iMax);\n    }));\n    const {x1: x1, y1: y1, width: width, height: height} = shapeBounds;\n    ctx.strokeStyle = \"#000\", ctx.strokeRect(x1, y1, width, height), ctx.fillStyle = \"#000\", \n    ctx.fillRect(shapeCenter[0], shapeCenter[1], 3, 3), ctx.fillText(\"shape center\", shapeCenter[0], shapeCenter[1]), \n    document.body.prepend(paintCanvas);\n}\n\nfunction paint(board, paintSize) {\n    const curSize = paintSize, imageData = new ImageData(curSize[0], curSize[1]), array = imageData.data, w32 = paintSize[0] >> 5;\n    for (let y = 0; y < curSize[1]; y++) for (let x = 0; x < w32; x++) {\n        const string = (board[y * w32 + x] >>> 0).toString(2).padStart(32, \"0\");\n        for (let k = 0; k < 32; k++) \"1\" === string[k] ? (array[4 * ((x << 5) + y * curSize[0] + k) + 0] = 255, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 1] = 255, array[4 * ((x << 5) + y * curSize[0] + k) + 2] = 255, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 3] = 255) : (array[4 * ((x << 5) + y * curSize[0] + k) + 0] = 0, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 1] = 0, array[4 * ((x << 5) + y * curSize[0] + k) + 2] = 0, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 3] = 255), 0 === k && (array[4 * ((x << 5) + y * curSize[0] + k) + 0] = 255, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 1] = 0, array[4 * ((x << 5) + y * curSize[0] + k) + 2] = 0, \n        array[4 * ((x << 5) + y * curSize[0] + k) + 3] = 255);\n    }\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = curSize[0], canvas.height = curSize[1];\n    canvas.getContext(\"2d\").putImageData(imageData, 0, 0), document.body.prepend(canvas);\n}\n\nfunction draw(words, fillingWords, layoutConfig, resizeFactor = 1) {\n    const canvas = document.createElement(\"canvas\"), {size: size} = (Math.PI, layoutConfig);\n    canvas.width = size[0] * resizeFactor, canvas.height = size[1] * resizeFactor;\n    const ctx = canvas.getContext(\"2d\");\n    function drawText(word, color) {\n        ctx.save(), ctx.textAlign = \"center\", ctx.font = word.fontStyle + \" \" + word.fontWeight + \" \" + word.fontSize * resizeFactor + \"px \" + word.fontFamily, \n        ctx.globalAlpha = word.opacity, ctx.translate(word.x * resizeFactor, word.y * resizeFactor), \n        word.rotate && ctx.rotate(word.rotate * Math.PI / 180), ctx.fillText(word.text, 0, .3 * word.fontSize * resizeFactor), \n        ctx.restore();\n    }\n    words.forEach((word => {\n        word.visible && drawText(word);\n    })), fillingWords.forEach((word => {\n        word.visible && drawText(word, \"#308ebc\");\n    })), document.body.prepend(canvas);\n}\n\nfunction drawSpiral(spiral, center, maxR, size) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = size[0], canvas.height = size[1];\n    const ctx = canvas.getContext(\"2d\");\n    let dxdy, dx, dy, t = -1;\n    for (;(dxdy = spiral(t += 1)) && (dx = dxdy[0], dy = dxdy[1], !(Math.min(Math.abs(dx), Math.abs(dy)) >= maxR)); ) ctx.fillStyle = \"#f00\", \n    ctx.fillRect(center[0] + dx, center[1] + dy, 3, 3);\n    document.body.prepend(canvas);\n}\n\nfunction functor(d) {\n    return \"function\" == typeof d ? d : function() {\n        return d;\n    };\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEQ7O0FBRVM7O0FBRWhFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywrREFBK0Q7O0FBRXpEO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBO0FBQ1AsUUFBUSw0REFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsbUJBQW1CLDREQUFVLFNBQVMsNERBQVE7QUFDOUM7QUFDQSwwQkFBMEIsbUVBQVc7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxTQUFTO0FBQ1QsWUFBWSxvREFBTTtBQUNsQixTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVPO0FBQ1AsV0FBVywyQkFBMkIsaUNBQWlDLHNEQUFzRCxvQ0FBb0MsMkRBQU87QUFDeEs7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBO0FBQ0EsZUFBZSxrRkFBa0Y7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTSxvRUFBb0UsTUFBTTtBQUN4RyxLQUFLO0FBQ0wsV0FBVyw4Q0FBOEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0IscUJBQXFCLFNBQVM7QUFDbEU7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1Asc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEdBQTBHO0FBQ3BIO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci13b3JkY2xvdWQtc2hhcGVAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZS9lcy91dGlsLmpzPzc4NTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmdsb2JhbCwgY3JlYXRlSW1hZ2UgfSBmcm9tIFwiQHZpc2FjdG9yL3ZyZW5kZXItY29yZVwiO1xuXG5pbXBvcnQgeyBpc0Jhc2U2NCwgaXNOaWwsIGlzVmFsaWRVcmwsIExvZ2dlciB9IGZyb20gXCJAdmlzYWN0b3IvdnV0aWxzXCI7XG5cbmV4cG9ydCB2YXIgV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQ7XG5cbiFmdW5jdGlvbihXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVCkge1xuICAgIFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5ULkJFRk9SRV9XT1JEQ0xPVURfU0hBUEVfTEFZT1VUID0gXCJiZWZvcmVXb3JkY2xvdWRTaGFwZUxheW91dFwiLCBcbiAgICBXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVC5BRlRFUl9XT1JEQ0xPVURfU0hBUEVfTEFZT1VUID0gXCJhZnRlcldvcmRjbG91ZFNoYXBlTGF5b3V0XCIsIFxuICAgIFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5ULkFGVEVSX1dPUkRDTE9VRF9TSEFQRV9EUkFXID0gXCJhZnRlcldvcmRjbG91ZFNoYXBlRHJhd1wiO1xufShXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVCB8fCAoV09SRENMT1VEX1NIQVBFX0hPT0tfRVZFTlQgPSB7fSkpO1xuXG5leHBvcnQgY29uc3QgY29sb3JMaXN0RXF1YWwgPSAoYXJyMCwgYXJyMSkgPT4ge1xuICAgIGlmICgxID09PSBhcnIxLmxlbmd0aCAmJiBcIiM1MzdFRjVcIiA9PT0gYXJyMVswXSkgcmV0dXJuICEwO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIwKSB8fCAhQXJyYXkuaXNBcnJheShhcnIxKSB8fCBhcnIwLmxlbmd0aCAhPT0gYXJyMS5sZW5ndGgpIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIGlmIChhcnIwW2ldICE9PSBhcnIxW2ldKSByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xufTtcblxuZXhwb3J0IGNvbnN0IGZha2VSYW5kb20gPSAoKSA9PiB7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBjb25zdCBhcnIgPSBbIDAsIC4xLCAuMiwgLjMsIC40LCAuNSwgLjYsIC43LCAuOCwgLjkgXTtcbiAgICByZXR1cm4gKCkgPT4gKGkgPSAoaSArIDEpICUgYXJyLmxlbmd0aCwgYXJyW2ldKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0NoaW5lc2UgPSB0ZXh0ID0+IC9eW1xcdTRlMDAtXFx1OWZhNV0rJC8udGVzdCh0ZXh0KTtcblxuZXhwb3J0IGNvbnN0IGNhbFRleHRMZW5ndGggPSAodGV4dCwgdGV4dExlbmd0aExpbWl0KSA9PiB7XG4gICAgaWYgKGlzTmlsKHRleHQpKSByZXR1cm4gMDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2YgdGV4dCkgaXNDaGluZXNlKGNoYXIpID8gbGVuZ3RoICs9IDEgOiBsZW5ndGggKz0gLjUzO1xuICAgIHJldHVybiBsZW5ndGg7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuICAgIHJldHVybiB1cmwgJiYgKGlzVmFsaWRVcmwodXJsKSB8fCBpc0Jhc2U2NCh1cmwpIHx8IHVybC5zdGFydHNXaXRoKFwiPHN2Z1wiKSkgPyBuZXcgUHJvbWlzZSgoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGltYWdlTWFyayA9IGNyZWF0ZUltYWdlKHtcbiAgICAgICAgICAgIGltYWdlOiB1cmxcbiAgICAgICAgfSksIGltZ0RhdGEgPSBudWxsID09PSAoX2EgPSBpbWFnZU1hcmsucmVzb3VyY2VzKSB8fCB2b2lkIDAgPT09IF9hID8gdm9pZCAwIDogX2EuZ2V0KHVybCk7XG4gICAgICAgIGltZ0RhdGEgJiYgXCJzdWNjZXNzXCIgPT09IGltZ0RhdGEuc3RhdGUgJiYgaW1nRGF0YS5kYXRhID8gcmVzb2x2ZShpbWdEYXRhLmRhdGEpIDogKGltYWdlTWFyay5zdWNjZXNzQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoaW1hZ2VNYXJrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1nRGF0YSA9IG51bGwgPT09IChfYSA9IGltYWdlTWFyay5yZXNvdXJjZXMpIHx8IHZvaWQgMCA9PT0gX2EgPyB2b2lkIDAgOiBfYS5nZXQodXJsKTtcbiAgICAgICAgICAgICAgICBpbWdEYXRhICYmIFwic3VjY2Vzc1wiID09PSBpbWdEYXRhLnN0YXRlICYmIGltZ0RhdGEuZGF0YSA/IHJlc29sdmUoaW1nRGF0YS5kYXRhKSA6IHJlamVjdChuZXcgRXJyb3IoXCJpbWFnZSBsb2FkIGZhaWxlZFwiICsgdXJsKSk7XG4gICAgICAgICAgICB9IGVsc2UgcmVqZWN0KG5ldyBFcnJvcihcImltYWdlIGxvYWQgZmFpbGVkXCIgKyB1cmwpKTtcbiAgICAgICAgfSwgaW1hZ2VNYXJrLmZhaWxDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKFwiaW1hZ2Ug5Yqg6L295aSx6LSl77yBXCIsIHVybCk7XG4gICAgICAgIH0pO1xuICAgIH0pKSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWludExhYmVscyhzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBjb25zdCB7c2l6ZTogc2l6ZSwgc2VnbWVudGF0aW9uOiB7cmVnaW9uczogcmVnaW9ucywgbGFiZWxzOiBsYWJlbHN9LCBzaGFwZUJvdW5kczogc2hhcGVCb3VuZHMsIHNoYXBlQ2VudGVyOiBzaGFwZUNlbnRlcn0gPSBzZWdtZW50YXRpb25PdXRwdXQsIHBhaW50Q2FudmFzID0gdmdsb2JhbC5jcmVhdGVDYW52YXMoe1xuICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgfSksIGN0eCA9IHBhaW50Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgY29sb3JMaXN0ID0gWyBcIiNGRjAwMDBcIiwgXCIjMDBGRjAwXCIsIFwiIzAwMDBGRlwiLCBcIiNGRkZGMDBcIiwgXCIjMDBGRkZGXCIsIFwiI0ZGMDBGRlwiIF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplWzFdOyBpKyspIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZVswXTsgaisrKSAwID09PSBsYWJlbHNbaSAqIHNpemVbMF0gKyBqXSA/IGN0eC5maWxsU3R5bGUgPSBcIiNmZmZcIiA6IGN0eC5maWxsU3R5bGUgPSBjb2xvckxpc3RbbGFiZWxzW2kgKiBzaXplWzBdICsgal0gJSBjb2xvckxpc3QubGVuZ3RoXSwgXG4gICAgY3R4LmZpbGxSZWN0KGosIGksIDEsIDEpO1xuICAgIHJlZ2lvbnMuZm9yRWFjaCgocmVnaW9uID0+IHtcbiAgICAgICAgY29uc3Qge2NlbnRlcjogW3gsIHldLCBhcmVhOiBhcmVhLCBib3VuZGFyeTogYm91bmRhcnksIG1heFBvaW50OiBtYXhQb2ludCwgbGFiZWw6IGxhYmVsfSA9IHJlZ2lvbjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiLCBjdHguZmlsbFJlY3QoeCwgeSwgMywgMyksIGN0eC5mb250ID0gXCIxNXB4IHNlcmlmXCIsIGN0eC5maWxsVGV4dChhcmVhLCB4LCB5KTtcbiAgICAgICAgZm9yIChjb25zdCBbeCwgeV0gb2YgYm91bmRhcnkpIGN0eC5maWxsU3R5bGUgPSBcIiNmMDBcIiwgY3R4LmZpbGxSZWN0KHgsIHksIDEsIDEpO1xuICAgICAgICBjb25zdCBbaU1pbiwgaU1heCwgak1pbiwgak1heF0gPSBtYXhQb2ludDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwZlwiLCBjdHguZm9udCA9IFwiMTVweCBzZXJpZlwiLCBjdHguZmlsbFJlY3Qoak1pbiwgaU1pbiwgMywgMyksIFxuICAgICAgICBjdHguZmlsbFRleHQoYCR7bGFiZWx9X21pbmAsIGpNaW4sIGlNaW4pLCBjdHguZmlsbFJlY3Qoak1heCwgaU1heCwgMywgMyksIGN0eC5maWxsVGV4dChgJHtsYWJlbH1fbWF4YCwgak1heCwgaU1heCk7XG4gICAgfSkpO1xuICAgIGNvbnN0IHt4MTogeDEsIHkxOiB5MSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodH0gPSBzaGFwZUJvdW5kcztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiMwMDBcIiwgY3R4LnN0cm9rZVJlY3QoeDEsIHkxLCB3aWR0aCwgaGVpZ2h0KSwgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiLCBcbiAgICBjdHguZmlsbFJlY3Qoc2hhcGVDZW50ZXJbMF0sIHNoYXBlQ2VudGVyWzFdLCAzLCAzKSwgY3R4LmZpbGxUZXh0KFwic2hhcGUgY2VudGVyXCIsIHNoYXBlQ2VudGVyWzBdLCBzaGFwZUNlbnRlclsxXSksIFxuICAgIGRvY3VtZW50LmJvZHkucHJlcGVuZChwYWludENhbnZhcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWludChib2FyZCwgcGFpbnRTaXplKSB7XG4gICAgY29uc3QgY3VyU2l6ZSA9IHBhaW50U2l6ZSwgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShjdXJTaXplWzBdLCBjdXJTaXplWzFdKSwgYXJyYXkgPSBpbWFnZURhdGEuZGF0YSwgdzMyID0gcGFpbnRTaXplWzBdID4+IDU7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjdXJTaXplWzFdOyB5KyspIGZvciAobGV0IHggPSAwOyB4IDwgdzMyOyB4KyspIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gKGJvYXJkW3kgKiB3MzIgKyB4XSA+Pj4gMCkudG9TdHJpbmcoMikucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAzMjsgaysrKSBcIjFcIiA9PT0gc3RyaW5nW2tdID8gKGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgMF0gPSAyNTUsIFxuICAgICAgICBhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDFdID0gMjU1LCBhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDJdID0gMjU1LCBcbiAgICAgICAgYXJyYXlbNCAqICgoeCA8PCA1KSArIHkgKiBjdXJTaXplWzBdICsgaykgKyAzXSA9IDI1NSkgOiAoYXJyYXlbNCAqICgoeCA8PCA1KSArIHkgKiBjdXJTaXplWzBdICsgaykgKyAwXSA9IDAsIFxuICAgICAgICBhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDFdID0gMCwgYXJyYXlbNCAqICgoeCA8PCA1KSArIHkgKiBjdXJTaXplWzBdICsgaykgKyAyXSA9IDAsIFxuICAgICAgICBhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDNdID0gMjU1KSwgMCA9PT0gayAmJiAoYXJyYXlbNCAqICgoeCA8PCA1KSArIHkgKiBjdXJTaXplWzBdICsgaykgKyAwXSA9IDI1NSwgXG4gICAgICAgIGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgMV0gPSAwLCBhcnJheVs0ICogKCh4IDw8IDUpICsgeSAqIGN1clNpemVbMF0gKyBrKSArIDJdID0gMCwgXG4gICAgICAgIGFycmF5WzQgKiAoKHggPDwgNSkgKyB5ICogY3VyU2l6ZVswXSArIGspICsgM10gPSAyNTUpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IGN1clNpemVbMF0sIGNhbnZhcy5oZWlnaHQgPSBjdXJTaXplWzFdO1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCksIGRvY3VtZW50LmJvZHkucHJlcGVuZChjYW52YXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhdyh3b3JkcywgZmlsbGluZ1dvcmRzLCBsYXlvdXRDb25maWcsIHJlc2l6ZUZhY3RvciA9IDEpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCB7c2l6ZTogc2l6ZX0gPSAoTWF0aC5QSSwgbGF5b3V0Q29uZmlnKTtcbiAgICBjYW52YXMud2lkdGggPSBzaXplWzBdICogcmVzaXplRmFjdG9yLCBjYW52YXMuaGVpZ2h0ID0gc2l6ZVsxXSAqIHJlc2l6ZUZhY3RvcjtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGZ1bmN0aW9uIGRyYXdUZXh0KHdvcmQsIGNvbG9yKSB7XG4gICAgICAgIGN0eC5zYXZlKCksIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiLCBjdHguZm9udCA9IHdvcmQuZm9udFN0eWxlICsgXCIgXCIgKyB3b3JkLmZvbnRXZWlnaHQgKyBcIiBcIiArIHdvcmQuZm9udFNpemUgKiByZXNpemVGYWN0b3IgKyBcInB4IFwiICsgd29yZC5mb250RmFtaWx5LCBcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gd29yZC5vcGFjaXR5LCBjdHgudHJhbnNsYXRlKHdvcmQueCAqIHJlc2l6ZUZhY3Rvciwgd29yZC55ICogcmVzaXplRmFjdG9yKSwgXG4gICAgICAgIHdvcmQucm90YXRlICYmIGN0eC5yb3RhdGUod29yZC5yb3RhdGUgKiBNYXRoLlBJIC8gMTgwKSwgY3R4LmZpbGxUZXh0KHdvcmQudGV4dCwgMCwgLjMgKiB3b3JkLmZvbnRTaXplICogcmVzaXplRmFjdG9yKSwgXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHdvcmRzLmZvckVhY2goKHdvcmQgPT4ge1xuICAgICAgICB3b3JkLnZpc2libGUgJiYgZHJhd1RleHQod29yZCk7XG4gICAgfSkpLCBmaWxsaW5nV29yZHMuZm9yRWFjaCgod29yZCA9PiB7XG4gICAgICAgIHdvcmQudmlzaWJsZSAmJiBkcmF3VGV4dCh3b3JkLCBcIiMzMDhlYmNcIik7XG4gICAgfSkpLCBkb2N1bWVudC5ib2R5LnByZXBlbmQoY2FudmFzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdTcGlyYWwoc3BpcmFsLCBjZW50ZXIsIG1heFIsIHNpemUpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHNpemVbMF0sIGNhbnZhcy5oZWlnaHQgPSBzaXplWzFdO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgbGV0IGR4ZHksIGR4LCBkeSwgdCA9IC0xO1xuICAgIGZvciAoOyhkeGR5ID0gc3BpcmFsKHQgKz0gMSkpICYmIChkeCA9IGR4ZHlbMF0sIGR5ID0gZHhkeVsxXSwgIShNYXRoLm1pbihNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSkgPj0gbWF4UikpOyApIGN0eC5maWxsU3R5bGUgPSBcIiNmMDBcIiwgXG4gICAgY3R4LmZpbGxSZWN0KGNlbnRlclswXSArIGR4LCBjZW50ZXJbMV0gKyBkeSwgMywgMyk7XG4gICAgZG9jdW1lbnQuYm9keS5wcmVwZW5kKGNhbnZhcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdG9yKGQpIHtcbiAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBkID8gZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transform: () => (/* binding */ transform)\n/* harmony export */ });\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isNil.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/logger.js\");\n/* harmony import */ var _visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vgrammar-util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-util@0.16.11/node_modules/@visactor/vgrammar-util/es/error.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/util.js\");\n/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layout */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/layout.js\");\n\n\n\n\n\n\n\n\nconst transform = (options, upstreamData, parameters, view) => {\n    if (!options.size || (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(options.size[0]) || (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(options.size[1]) || options.size[0] <= 0 || options.size[1] <= 0) {\n        return _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__.Logger.getInstance().info(\"Wordcloud size dimensions must be greater than 0\"), \n        [];\n    }\n    if (options.size = [ Math.ceil(options.size[0]), Math.ceil(options.size[1]) ], options.shape || (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_2__.error)(\"WordcloudShape shape must be specified.\"), \n    options.text || (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_2__.error)(\"WordcloudShape text must be specified.\"), (null == view ? void 0 : view.emit) && view.emit(_util__WEBPACK_IMPORTED_MODULE_3__.WORDCLOUD_SHAPE_HOOK_EVENT.BEFORE_WORDCLOUD_SHAPE_LAYOUT), \n    !upstreamData || 0 === upstreamData.length) return [];\n    const layout = new _layout__WEBPACK_IMPORTED_MODULE_4__.Layout(options, view);\n    return layout.layout(upstreamData), layout.unfinished() ? {\n        progressive: layout\n    } : layout.output();\n};\n//# sourceMappingURL=wordcloud-shape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3dvcmRjbG91ZC1zaGFwZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUQ7O0FBRUQ7O0FBRUk7O0FBRWxCOztBQUUzQjtBQUNQLHlCQUF5Qiw0REFBSyxxQkFBcUIsNERBQUs7QUFDeEQsZUFBZSxvREFBTTtBQUNyQjtBQUNBO0FBQ0Esb0dBQW9HLDhEQUFLO0FBQ3pHLG9CQUFvQiw4REFBSyw2RkFBNkYsNkRBQTBCO0FBQ2hKO0FBQ0EsdUJBQXVCLDJDQUFNO0FBQzdCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2FjdG9yLW5leHQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3dvcmRjbG91ZC1zaGFwZS5qcz8yNDg5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ2dlciwgaXNOaWwgfSBmcm9tIFwiQHZpc2FjdG9yL3Z1dGlsc1wiO1xuXG5pbXBvcnQgeyBlcnJvciB9IGZyb20gXCJAdmlzYWN0b3IvdmdyYW1tYXItdXRpbFwiO1xuXG5pbXBvcnQgeyBXT1JEQ0xPVURfU0hBUEVfSE9PS19FVkVOVCB9IGZyb20gXCIuL3V0aWxcIjtcblxuaW1wb3J0IHsgTGF5b3V0IH0gZnJvbSBcIi4vbGF5b3V0XCI7XG5cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm0gPSAob3B0aW9ucywgdXBzdHJlYW1EYXRhLCBwYXJhbWV0ZXJzLCB2aWV3KSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLnNpemUgfHwgaXNOaWwob3B0aW9ucy5zaXplWzBdKSB8fCBpc05pbChvcHRpb25zLnNpemVbMV0pIHx8IG9wdGlvbnMuc2l6ZVswXSA8PSAwIHx8IG9wdGlvbnMuc2l6ZVsxXSA8PSAwKSB7XG4gICAgICAgIHJldHVybiBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKFwiV29yZGNsb3VkIHNpemUgZGltZW5zaW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpLCBcbiAgICAgICAgW107XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNpemUgPSBbIE1hdGguY2VpbChvcHRpb25zLnNpemVbMF0pLCBNYXRoLmNlaWwob3B0aW9ucy5zaXplWzFdKSBdLCBvcHRpb25zLnNoYXBlIHx8IGVycm9yKFwiV29yZGNsb3VkU2hhcGUgc2hhcGUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpLCBcbiAgICBvcHRpb25zLnRleHQgfHwgZXJyb3IoXCJXb3JkY2xvdWRTaGFwZSB0ZXh0IG11c3QgYmUgc3BlY2lmaWVkLlwiKSwgKG51bGwgPT0gdmlldyA/IHZvaWQgMCA6IHZpZXcuZW1pdCkgJiYgdmlldy5lbWl0KFdPUkRDTE9VRF9TSEFQRV9IT09LX0VWRU5ULkJFRk9SRV9XT1JEQ0xPVURfU0hBUEVfTEFZT1VUKSwgXG4gICAgIXVwc3RyZWFtRGF0YSB8fCAwID09PSB1cHN0cmVhbURhdGEubGVuZ3RoKSByZXR1cm4gW107XG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IExheW91dChvcHRpb25zLCB2aWV3KTtcbiAgICByZXR1cm4gbGF5b3V0LmxheW91dCh1cHN0cmVhbURhdGEpLCBsYXlvdXQudW5maW5pc2hlZCgpID8ge1xuICAgICAgICBwcm9ncmVzc2l2ZTogbGF5b3V0XG4gICAgfSA6IGxheW91dC5vdXRwdXQoKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkY2xvdWQtc2hhcGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordcloud-shape.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCollideWithBoard: () => (/* binding */ isCollideWithBoard),\n/* harmony export */   layout: () => (/* binding */ layout),\n/* harmony export */   layoutGlobalShrink: () => (/* binding */ layoutGlobalShrink),\n/* harmony export */   layoutSelfEnlarge: () => (/* binding */ layoutSelfEnlarge),\n/* harmony export */   layoutSelfShrink: () => (/* binding */ layoutSelfShrink),\n/* harmony export */   measureSprite: () => (/* binding */ measureSprite),\n/* harmony export */   placeWordOnBoard: () => (/* binding */ placeWordOnBoard)\n/* harmony export */ });\nfunction layout(words, layoutConfig, segmentationOutput) {\n    const {size: size, stepFactor: stepFactor} = layoutConfig, {segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize, shapeCenter: shapeCenter, shapeMaxR: shapeMaxR, shapeRatio: shapeRatio} = segmentationOutput, board = initBoardWithShape(segmentationOutput), ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    for (const region of regions) {\n        const {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            word.x = center[0], word.y = center[1], word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {\n        const failedWords = words.filter((word => (word.hasPlaced || (word.hasText = !1, \n        word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), \n        !word.hasPlaced)));\n        if (0 === failedWords.length) break;\n        for (let i = 0; i < failedWords.length; i++) {\n            const word = failedWords[i];\n            measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], \n            word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction layoutSelfShrink(words, layoutConfig, segmentationOutput) {\n    const {size: size, stepFactor: stepFactor} = layoutConfig, {segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize} = segmentationOutput, board = initBoardWithShape(segmentationOutput), ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    });\n    for (const region of regions) {\n        const {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        let fontFactor = 1;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            if (word.x = center[0], word.y = center[1], word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) word.hasPlaced = !0; else {\n                fontFactor *= layoutConfig.fontSizeShrinkFactor;\n                for (let j = i; j < regionWords.length; j++) word.hasText = !1, word.sprite = null, \n                word.fontSize = Math.max(~~(word.fontSize * fontFactor), layoutConfig.minFontSize);\n                i--;\n            }\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction layoutGlobalShrink(words, layoutConfig, segmentationOutput) {\n    const {stepFactor: stepFactor, importantWordCount: importantWordCount, globalShinkLimit: globalShinkLimit} = layoutConfig, {size: size, segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize, shapeCenter: shapeCenter, shapeMaxR: shapeMaxR, shapeRatio: shapeRatio} = segmentationOutput, ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    }), boardOrigin = initBoardWithShape(segmentationOutput);\n    let board = boardOrigin.slice(0);\n    const fontFactor = layoutConfig.fontSizeShrinkFactor;\n    let id = null, idIntialFactor = 1, globalShinkFactor = 1;\n    const importantCount = importantWordCount;\n    let weightStd = 0;\n    if (words.length > importantCount) {\n        weightStd = words.sort(((word0, word1) => word1.weight - word0.weight))[importantCount].weight;\n    }\n    for (let k = 0; k < regions.length; k++) {\n        const region = regions[k], {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        let restartTag = !1;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            if (word.x = center[0], word.y = center[1], !word.skip && word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) word.hasPlaced = !0; else {\n                if (!word.skip && word.weight > weightStd && globalShinkFactor > globalShinkLimit) {\n                    const wordId = word.datum[Symbol.for(\"vGrammar_id\")];\n                    wordId !== id && (id = wordId, idIntialFactor = globalShinkFactor), globalShinkFactor *= fontFactor, \n                    words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize * fontFactor;\n                    })), board = boardOrigin.slice(0), restartTag = !0;\n                    break;\n                }\n                if (!word.skip && word.datum[Symbol.for(\"vGrammar_id\")] === id) {\n                    words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize / globalShinkFactor;\n                    })), word.skip = !0, globalShinkFactor = idIntialFactor, id = null, board = boardOrigin.slice(0), \n                    restartTag = !0;\n                    break;\n                }\n            }\n        }\n        restartTag && (k = -1);\n    }\n    for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {\n        const failedWords = words.filter((word => (word.hasPlaced || (word.hasText = !1, \n        word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), \n        !word.hasPlaced)));\n        if (0 === failedWords.length) break;\n        for (let i = 0; i < failedWords.length; i++) {\n            const word = failedWords[i];\n            measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], \n            word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction layoutSelfEnlarge(words, layoutConfig, segmentationOutput) {\n    const {size: size, stepFactor: stepFactor, importantWordCount: importantWordCount} = layoutConfig, {segmentation: {regions: regions}, tempCanvas: canvas, boardSize: boardSize, shapeCenter: shapeCenter, shapeMaxR: shapeMaxR, shapeRatio: shapeRatio} = segmentationOutput, ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: !0\n    }), boardOrigin = initBoardWithShape(segmentationOutput);\n    let board = boardOrigin.slice(0);\n    const fontFactor = layoutConfig.fontSizeEnlargeFactor, importantCount = Math.min(importantWordCount, words.length);\n    let weightStd = 0;\n    if (words.length > importantCount) {\n        weightStd = words.sort(((word0, word1) => word1.weight - word0.weight))[importantCount - 1].weight;\n    }\n    let importantWordSuccessedNum = 0, globalEnlargeFactor = 1, layoutFinish = !1;\n    for (let k = 0; k < regions.length; k++) {\n        const region = regions[k], {words: regionWords, center: center, maxR: maxR, ratio: ratio} = region;\n        let restartTag = !1;\n        for (let i = 0; i < regionWords.length; i++) {\n            measureSprite(canvas, ctx, words, i);\n            const word = regionWords[i];\n            if (word.x = center[0], word.y = center[1], word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) {\n                if (word.hasPlaced = !0, word.weight >= weightStd && importantWordSuccessedNum++, \n                importantWordSuccessedNum >= importantCount && !layoutFinish) {\n                    globalEnlargeFactor *= fontFactor, words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize * fontFactor;\n                    })), board = boardOrigin.slice(0), restartTag = !0, importantWordSuccessedNum = 0;\n                    break;\n                }\n            } else {\n                if (word.weight >= weightStd && globalEnlargeFactor > 1) {\n                    words.forEach((word => {\n                        word.hasText = !1, word.sprite = null, word.fontSize = word.fontSize / fontFactor;\n                    })), globalEnlargeFactor /= fontFactor, layoutFinish = !0, board = boardOrigin.slice(0), \n                    restartTag = !0;\n                    break;\n                }\n                if (word.weight >= weightStd) return layoutGlobalShrink(words, layoutConfig, segmentationOutput);\n            }\n        }\n        restartTag && (k = -1);\n    }\n    for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {\n        const failedWords = words.filter((word => (word.hasPlaced || (word.hasText = !1, \n        word.sprite = null, word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize)), \n        !word.hasPlaced)));\n        if (0 === failedWords.length) break;\n        for (let i = 0; i < failedWords.length; i++) {\n            const word = failedWords[i];\n            measureSprite(canvas, ctx, failedWords, i), word.x = shapeCenter[0], word.y = shapeCenter[1], \n            word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor) && (word.hasPlaced = !0);\n        }\n    }\n    layoutConfig.board = board;\n}\n\nfunction place(board, word, maxR, ratio, size, boardSize, stepFactor) {\n    const startX = word.x, startY = word.y, spiral = archimedeanSpiral(ratio), dt = 1 * stepFactor;\n    let dxdy, dx, dy, t = -dt;\n    for (;dxdy = spiral(t += dt); ) {\n        const {wordSize: wordSize, bounds: {dTop: dTop, dBottom: dBottom, dLeft: dLeft, dRight: dRight}} = word;\n        if (dx = dxdy[0], dy = dxdy[1], Math.min(Math.abs(dx), Math.abs(dy)) >= maxR) break;\n        if (word.x = ~~(startX + dx), word.y = ~~(startY + dy), !(word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1] || isCollideWithBoard(word, board, boardSize))) return placeWordOnBoard(word, board, boardSize), \n        !0;\n    }\n    return !1;\n}\n\nfunction placeWordOnBoard(word, board, boardSize) {\n    const {wordSize: wordSize} = word, sprite = word.sprite, w = wordSize[0] >> 5, sw = boardSize[0] >> 5, lx = word.x - (w << 4), sx = lx % 32, msx = 32 - sx, h = wordSize[1];\n    let last, x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);\n    if (0 === sx) for (let j = 0; j < h; j++) {\n        for (let i = 0; i < w; i++) board[x + i] |= sprite[j * w + i];\n        x += sw;\n    } else for (let j = 0; j < h; j++) {\n        last = 0;\n        for (let i = 0; i <= w; i++) board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n        x += sw;\n    }\n}\n\nfunction isCollideWithBoard(word, board, boardSize) {\n    const {sprite: sprite, wordSize: wordSize} = word, sw = boardSize[0] >> 5, w = wordSize[0] >> 5, lx = word.x - (w << 4), sx = lx % 32, msx = 32 - sx, h = wordSize[1];\n    let last, x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);\n    if (0 === sx) for (let j = 0; j < h; j++) {\n        for (let i = 0; i < w; i++) if (board[x + i] & sprite[j * w + i]) return !0;\n        x += sw;\n    } else for (let j = 0; j < h; j++) {\n        last = 0;\n        for (let i = 0; i <= w; i++) if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return !0;\n        x += sw;\n    }\n    return !1;\n}\n\nfunction archimedeanSpiral(ratio) {\n    return function(t) {\n        return [ ratio * (t *= .1) * Math.cos(t), t * Math.sin(t) ];\n    };\n}\n\nfunction measureSprite(canvas, ctx, words, wi) {\n    if (words[wi].sprite || 0 === words[wi].fontSize) return;\n    const cw = 2048, radians = Math.PI / 180, n = words.length;\n    canvas.width = cw, canvas.height = 2048, ctx.clearRect(0, 0, cw, 2048), ctx.textAlign = \"center\";\n    let wordW, wordH, x = 0, y = 0, maxHeight = 0, yMax = 0;\n    const wiDist = wi;\n    for (--wi; ++wi < n; ) {\n        const word = words[wi], fontSize = Math.max(word.fontSize, 2);\n        if (ctx.save(), ctx.font = word.fontStyle + \" \" + word.fontWeight + \" \" + fontSize + \"px \" + word.fontFamily, \n        wordW = ctx.measureText(word.text + \"m\").width + 2 * word.padding, wordH = 2 * fontSize + 2 * word.padding, \n        0 !== word.rotate) {\n            const sr = Math.sin(word.rotate * radians), cr = Math.cos(word.rotate * radians), wcr = wordW * cr, wsr = wordW * sr, hcr = wordH * cr, hsr = wordH * sr;\n            wordW = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)), wordH = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n        }\n        if (wordW = wordW + 31 >> 5 << 5, wordH = Math.ceil(wordH), wordH > maxHeight && (maxHeight = wordH), \n        x + wordW >= cw && (x = 0, y += maxHeight, maxHeight = wordH), y + wordH >= 2048) {\n            if (0 === y) {\n                word.hasText = !1;\n                continue;\n            }\n            break;\n        }\n        y + wordH >= yMax && (yMax = y + wordH), ctx.translate(x + (wordW >> 1), y + (wordH >> 1)), \n        0 !== word.rotate && ctx.rotate(word.rotate * radians), ctx.fillText(word.text, 0, 0), \n        word.padding && (ctx.lineWidth = 2 * word.padding, ctx.strokeText(word.text, 0, 0)), \n        ctx.restore(), word.LT = [ x, y ], word.wordSize = [ wordW, wordH ], word.hasText = !0, \n        x += wordW;\n    }\n    if (0 === yMax) return;\n    const pixels = ctx.getImageData(0, 0, cw, yMax).data;\n    let i, j;\n    for (;--wi >= wiDist; ) {\n        const word = words[wi];\n        if (!word.hasText) {\n            word.bounds = {\n                dTop: 1 / 0,\n                dBottom: -1 / 0,\n                dLeft: 1 / 0,\n                dRight: -1 / 0\n            };\n            break;\n        }\n        const {LT: LT = [ 0, 0 ], wordSize: wordSize} = word;\n        [x, y] = LT;\n        const w32 = wordSize[0] >> 5, sprite = new Array(w32 * wordSize[1]).fill(0);\n        let [dTop, dBottom, dLeft, dRight] = [ 1 / 0, -1 / 0, 1 / 0, -1 / 0 ];\n        for (j = 0; j < wordSize[1]; j++) {\n            let seen;\n            for (i = 0; i < wordSize[0]; i++) if (pixels[4 * ((y + j) * cw + (x + i)) + 3] > 0) {\n                const m = 1 << 31 - i % 32;\n                sprite[w32 * j + (i >> 5)] |= m, i < dLeft && (dLeft = i), i > dRight && (dRight = i), \n                seen |= m;\n            }\n            seen && (j < dTop && (dTop = j), j > dBottom && (dBottom = j));\n        }\n        word.bounds = {\n            dTop: (wordSize[1] >> 1) - dTop,\n            dBottom: dBottom - (wordSize[1] >> 1),\n            dLeft: (wordSize[0] >> 1) - dLeft,\n            dRight: dRight - (wordSize[0] >> 1)\n        }, word.sprite = sprite, delete word.LT;\n    }\n}\n\nfunction initBoardWithShape(segmentationOutput) {\n    const {segmentation: {labels: labels}, boardSize: boardSize, size: size} = segmentationOutput, w32 = boardSize[0] >> 5, board = new Array(w32 * size[1]).fill(0);\n    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {\n        if (0 === labels[i * size[0] + j]) {\n            const m = 1 << 31 - j % 32;\n            board[w32 * i + (j >> 5)] |= m;\n        }\n    }\n    if (boardSize[0] > size[0]) {\n        const m = (1 << boardSize[0] - size[0]) - 1;\n        for (let y = 0; y < size[1]; y++) {\n            board[w32 * y + w32 - 1] |= m;\n        }\n    }\n    return board;\n}\n//# sourceMappingURL=wordle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3dvcmRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU87QUFDUCxXQUFXLG9DQUFvQyxpQkFBaUIsZUFBZSxpQkFBaUIsb0hBQW9IO0FBQ3BOO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSw4REFBOEQ7QUFDN0Usd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxXQUFXLG9DQUFvQyxpQkFBaUIsZUFBZSxpQkFBaUIsNENBQTRDO0FBQzVJO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSw4REFBOEQ7QUFDN0U7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSwwS0FBMEs7QUFDMUs7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsV0FBVyxvR0FBb0csaUJBQWlCLDJCQUEyQixpQkFBaUIsb0hBQW9IO0FBQ2hTO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDLG9DQUFvQyw4REFBOEQ7QUFDbEc7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQSx3TEFBd0w7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxXQUFXLDRFQUE0RSxpQkFBaUIsZUFBZSxpQkFBaUIsb0hBQW9IO0FBQzVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QyxvQ0FBb0MsOERBQThEO0FBQ2xHO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEMsZUFBZSw2QkFBNkIsNkRBQTZEO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0Esa0NBQWtDLE9BQU87QUFDekMsd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxNQUFNLHFCQUFxQixPQUFPO0FBQ2xDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBOztBQUVPO0FBQ1AsV0FBVyxvQ0FBb0M7QUFDL0M7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qyx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLE1BQU0scUJBQXFCLE9BQU87QUFDbEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZSxlQUFlLG9DQUFvQztBQUM3RSxvQkFBb0IsYUFBYSxxQkFBcUIsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2FjdG9yLW5leHQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXdvcmRjbG91ZC1zaGFwZUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItd29yZGNsb3VkLXNoYXBlL2VzL3dvcmRsZS5qcz81OThiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBsYXlvdXQod29yZHMsIGxheW91dENvbmZpZywgc2VnbWVudGF0aW9uT3V0cHV0KSB7XG4gICAgY29uc3Qge3NpemU6IHNpemUsIHN0ZXBGYWN0b3I6IHN0ZXBGYWN0b3J9ID0gbGF5b3V0Q29uZmlnLCB7c2VnbWVudGF0aW9uOiB7cmVnaW9uczogcmVnaW9uc30sIHRlbXBDYW52YXM6IGNhbnZhcywgYm9hcmRTaXplOiBib2FyZFNpemUsIHNoYXBlQ2VudGVyOiBzaGFwZUNlbnRlciwgc2hhcGVNYXhSOiBzaGFwZU1heFIsIHNoYXBlUmF0aW86IHNoYXBlUmF0aW99ID0gc2VnbWVudGF0aW9uT3V0cHV0LCBib2FyZCA9IGluaXRCb2FyZFdpdGhTaGFwZShzZWdtZW50YXRpb25PdXRwdXQpLCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgcmVnaW9uIG9mIHJlZ2lvbnMpIHtcbiAgICAgICAgY29uc3Qge3dvcmRzOiByZWdpb25Xb3JkcywgY2VudGVyOiBjZW50ZXIsIG1heFI6IG1heFIsIHJhdGlvOiByYXRpb30gPSByZWdpb247XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVnaW9uV29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1lYXN1cmVTcHJpdGUoY2FudmFzLCBjdHgsIHdvcmRzLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmQgPSByZWdpb25Xb3Jkc1tpXTtcbiAgICAgICAgICAgIHdvcmQueCA9IGNlbnRlclswXSwgd29yZC55ID0gY2VudGVyWzFdLCB3b3JkLmhhc1RleHQgJiYgd29yZC5zcHJpdGUgJiYgcGxhY2UoYm9hcmQsIHdvcmQsIG1heFIsIHJhdGlvLCBzaXplLCBib2FyZFNpemUsIHN0ZXBGYWN0b3IpICYmICh3b3JkLmhhc1BsYWNlZCA9ICEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBfID0gMDsgXyA8IGxheW91dENvbmZpZy50ZXh0TGF5b3V0VGltZXM7IF8rKykge1xuICAgICAgICBjb25zdCBmYWlsZWRXb3JkcyA9IHdvcmRzLmZpbHRlcigod29yZCA9PiAod29yZC5oYXNQbGFjZWQgfHwgKHdvcmQuaGFzVGV4dCA9ICExLCBcbiAgICAgICAgd29yZC5zcHJpdGUgPSBudWxsLCB3b3JkLmZvbnRTaXplID0gTWF0aC5tYXgofn4od29yZC5mb250U2l6ZSAqIGxheW91dENvbmZpZy5mb250U2l6ZVNocmlua0ZhY3RvciksIGxheW91dENvbmZpZy5taW5Gb250U2l6ZSkpLCBcbiAgICAgICAgIXdvcmQuaGFzUGxhY2VkKSkpO1xuICAgICAgICBpZiAoMCA9PT0gZmFpbGVkV29yZHMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWlsZWRXb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IGZhaWxlZFdvcmRzW2ldO1xuICAgICAgICAgICAgbWVhc3VyZVNwcml0ZShjYW52YXMsIGN0eCwgZmFpbGVkV29yZHMsIGkpLCB3b3JkLnggPSBzaGFwZUNlbnRlclswXSwgd29yZC55ID0gc2hhcGVDZW50ZXJbMV0sIFxuICAgICAgICAgICAgd29yZC5oYXNUZXh0ICYmIHBsYWNlKGJvYXJkLCB3b3JkLCBzaGFwZU1heFIsIHNoYXBlUmF0aW8sIHNpemUsIGJvYXJkU2l6ZSwgc3RlcEZhY3RvcikgJiYgKHdvcmQuaGFzUGxhY2VkID0gITApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxheW91dENvbmZpZy5ib2FyZCA9IGJvYXJkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF5b3V0U2VsZlNocmluayh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBjb25zdCB7c2l6ZTogc2l6ZSwgc3RlcEZhY3Rvcjogc3RlcEZhY3Rvcn0gPSBsYXlvdXRDb25maWcsIHtzZWdtZW50YXRpb246IHtyZWdpb25zOiByZWdpb25zfSwgdGVtcENhbnZhczogY2FudmFzLCBib2FyZFNpemU6IGJvYXJkU2l6ZX0gPSBzZWdtZW50YXRpb25PdXRwdXQsIGJvYXJkID0gaW5pdEJvYXJkV2l0aFNoYXBlKHNlZ21lbnRhdGlvbk91dHB1dCksIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCByZWdpb24gb2YgcmVnaW9ucykge1xuICAgICAgICBjb25zdCB7d29yZHM6IHJlZ2lvbldvcmRzLCBjZW50ZXI6IGNlbnRlciwgbWF4UjogbWF4UiwgcmF0aW86IHJhdGlvfSA9IHJlZ2lvbjtcbiAgICAgICAgbGV0IGZvbnRGYWN0b3IgPSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2lvbldvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCB3b3JkcywgaSk7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gcmVnaW9uV29yZHNbaV07XG4gICAgICAgICAgICBpZiAod29yZC54ID0gY2VudGVyWzBdLCB3b3JkLnkgPSBjZW50ZXJbMV0sIHdvcmQuaGFzVGV4dCAmJiB3b3JkLnNwcml0ZSAmJiBwbGFjZShib2FyZCwgd29yZCwgbWF4UiwgcmF0aW8sIHNpemUsIGJvYXJkU2l6ZSwgc3RlcEZhY3RvcikpIHdvcmQuaGFzUGxhY2VkID0gITA7IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvbnRGYWN0b3IgKj0gbGF5b3V0Q29uZmlnLmZvbnRTaXplU2hyaW5rRmFjdG9yO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgcmVnaW9uV29yZHMubGVuZ3RoOyBqKyspIHdvcmQuaGFzVGV4dCA9ICExLCB3b3JkLnNwcml0ZSA9IG51bGwsIFxuICAgICAgICAgICAgICAgIHdvcmQuZm9udFNpemUgPSBNYXRoLm1heCh+fih3b3JkLmZvbnRTaXplICogZm9udEZhY3RvciksIGxheW91dENvbmZpZy5taW5Gb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxheW91dENvbmZpZy5ib2FyZCA9IGJvYXJkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF5b3V0R2xvYmFsU2hyaW5rKHdvcmRzLCBsYXlvdXRDb25maWcsIHNlZ21lbnRhdGlvbk91dHB1dCkge1xuICAgIGNvbnN0IHtzdGVwRmFjdG9yOiBzdGVwRmFjdG9yLCBpbXBvcnRhbnRXb3JkQ291bnQ6IGltcG9ydGFudFdvcmRDb3VudCwgZ2xvYmFsU2hpbmtMaW1pdDogZ2xvYmFsU2hpbmtMaW1pdH0gPSBsYXlvdXRDb25maWcsIHtzaXplOiBzaXplLCBzZWdtZW50YXRpb246IHtyZWdpb25zOiByZWdpb25zfSwgdGVtcENhbnZhczogY2FudmFzLCBib2FyZFNpemU6IGJvYXJkU2l6ZSwgc2hhcGVDZW50ZXI6IHNoYXBlQ2VudGVyLCBzaGFwZU1heFI6IHNoYXBlTWF4Uiwgc2hhcGVSYXRpbzogc2hhcGVSYXRpb30gPSBzZWdtZW50YXRpb25PdXRwdXQsIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG4gICAgfSksIGJvYXJkT3JpZ2luID0gaW5pdEJvYXJkV2l0aFNoYXBlKHNlZ21lbnRhdGlvbk91dHB1dCk7XG4gICAgbGV0IGJvYXJkID0gYm9hcmRPcmlnaW4uc2xpY2UoMCk7XG4gICAgY29uc3QgZm9udEZhY3RvciA9IGxheW91dENvbmZpZy5mb250U2l6ZVNocmlua0ZhY3RvcjtcbiAgICBsZXQgaWQgPSBudWxsLCBpZEludGlhbEZhY3RvciA9IDEsIGdsb2JhbFNoaW5rRmFjdG9yID0gMTtcbiAgICBjb25zdCBpbXBvcnRhbnRDb3VudCA9IGltcG9ydGFudFdvcmRDb3VudDtcbiAgICBsZXQgd2VpZ2h0U3RkID0gMDtcbiAgICBpZiAod29yZHMubGVuZ3RoID4gaW1wb3J0YW50Q291bnQpIHtcbiAgICAgICAgd2VpZ2h0U3RkID0gd29yZHMuc29ydCgoKHdvcmQwLCB3b3JkMSkgPT4gd29yZDEud2VpZ2h0IC0gd29yZDAud2VpZ2h0KSlbaW1wb3J0YW50Q291bnRdLndlaWdodDtcbiAgICB9XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCByZWdpb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbnNba10sIHt3b3JkczogcmVnaW9uV29yZHMsIGNlbnRlcjogY2VudGVyLCBtYXhSOiBtYXhSLCByYXRpbzogcmF0aW99ID0gcmVnaW9uO1xuICAgICAgICBsZXQgcmVzdGFydFRhZyA9ICExO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2lvbldvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCB3b3JkcywgaSk7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gcmVnaW9uV29yZHNbaV07XG4gICAgICAgICAgICBpZiAod29yZC54ID0gY2VudGVyWzBdLCB3b3JkLnkgPSBjZW50ZXJbMV0sICF3b3JkLnNraXAgJiYgd29yZC5oYXNUZXh0ICYmIHdvcmQuc3ByaXRlICYmIHBsYWNlKGJvYXJkLCB3b3JkLCBtYXhSLCByYXRpbywgc2l6ZSwgYm9hcmRTaXplLCBzdGVwRmFjdG9yKSkgd29yZC5oYXNQbGFjZWQgPSAhMDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkLnNraXAgJiYgd29yZC53ZWlnaHQgPiB3ZWlnaHRTdGQgJiYgZ2xvYmFsU2hpbmtGYWN0b3IgPiBnbG9iYWxTaGlua0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRJZCA9IHdvcmQuZGF0dW1bU3ltYm9sLmZvcihcInZHcmFtbWFyX2lkXCIpXTtcbiAgICAgICAgICAgICAgICAgICAgd29yZElkICE9PSBpZCAmJiAoaWQgPSB3b3JkSWQsIGlkSW50aWFsRmFjdG9yID0gZ2xvYmFsU2hpbmtGYWN0b3IpLCBnbG9iYWxTaGlua0ZhY3RvciAqPSBmb250RmFjdG9yLCBcbiAgICAgICAgICAgICAgICAgICAgd29yZHMuZm9yRWFjaCgod29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkLmhhc1RleHQgPSAhMSwgd29yZC5zcHJpdGUgPSBudWxsLCB3b3JkLmZvbnRTaXplID0gd29yZC5mb250U2l6ZSAqIGZvbnRGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIH0pKSwgYm9hcmQgPSBib2FyZE9yaWdpbi5zbGljZSgwKSwgcmVzdGFydFRhZyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkLnNraXAgJiYgd29yZC5kYXR1bVtTeW1ib2wuZm9yKFwidkdyYW1tYXJfaWRcIildID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICB3b3Jkcy5mb3JFYWNoKCh3b3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQuaGFzVGV4dCA9ICExLCB3b3JkLnNwcml0ZSA9IG51bGwsIHdvcmQuZm9udFNpemUgPSB3b3JkLmZvbnRTaXplIC8gZ2xvYmFsU2hpbmtGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIH0pKSwgd29yZC5za2lwID0gITAsIGdsb2JhbFNoaW5rRmFjdG9yID0gaWRJbnRpYWxGYWN0b3IsIGlkID0gbnVsbCwgYm9hcmQgPSBib2FyZE9yaWdpbi5zbGljZSgwKSwgXG4gICAgICAgICAgICAgICAgICAgIHJlc3RhcnRUYWcgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnRUYWcgJiYgKGsgPSAtMSk7XG4gICAgfVxuICAgIGZvciAobGV0IF8gPSAwOyBfIDwgbGF5b3V0Q29uZmlnLnRleHRMYXlvdXRUaW1lczsgXysrKSB7XG4gICAgICAgIGNvbnN0IGZhaWxlZFdvcmRzID0gd29yZHMuZmlsdGVyKCh3b3JkID0+ICh3b3JkLmhhc1BsYWNlZCB8fCAod29yZC5oYXNUZXh0ID0gITEsIFxuICAgICAgICB3b3JkLnNwcml0ZSA9IG51bGwsIHdvcmQuZm9udFNpemUgPSBNYXRoLm1heCh+fih3b3JkLmZvbnRTaXplICogbGF5b3V0Q29uZmlnLmZvbnRTaXplU2hyaW5rRmFjdG9yKSwgbGF5b3V0Q29uZmlnLm1pbkZvbnRTaXplKSksIFxuICAgICAgICAhd29yZC5oYXNQbGFjZWQpKSk7XG4gICAgICAgIGlmICgwID09PSBmYWlsZWRXb3Jkcy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhaWxlZFdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gZmFpbGVkV29yZHNbaV07XG4gICAgICAgICAgICBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCBmYWlsZWRXb3JkcywgaSksIHdvcmQueCA9IHNoYXBlQ2VudGVyWzBdLCB3b3JkLnkgPSBzaGFwZUNlbnRlclsxXSwgXG4gICAgICAgICAgICB3b3JkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIHdvcmQsIHNoYXBlTWF4Uiwgc2hhcGVSYXRpbywgc2l6ZSwgYm9hcmRTaXplLCBzdGVwRmFjdG9yKSAmJiAod29yZC5oYXNQbGFjZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF5b3V0Q29uZmlnLmJvYXJkID0gYm9hcmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXRTZWxmRW5sYXJnZSh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBjb25zdCB7c2l6ZTogc2l6ZSwgc3RlcEZhY3Rvcjogc3RlcEZhY3RvciwgaW1wb3J0YW50V29yZENvdW50OiBpbXBvcnRhbnRXb3JkQ291bnR9ID0gbGF5b3V0Q29uZmlnLCB7c2VnbWVudGF0aW9uOiB7cmVnaW9uczogcmVnaW9uc30sIHRlbXBDYW52YXM6IGNhbnZhcywgYm9hcmRTaXplOiBib2FyZFNpemUsIHNoYXBlQ2VudGVyOiBzaGFwZUNlbnRlciwgc2hhcGVNYXhSOiBzaGFwZU1heFIsIHNoYXBlUmF0aW86IHNoYXBlUmF0aW99ID0gc2VnbWVudGF0aW9uT3V0cHV0LCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxuICAgIH0pLCBib2FyZE9yaWdpbiA9IGluaXRCb2FyZFdpdGhTaGFwZShzZWdtZW50YXRpb25PdXRwdXQpO1xuICAgIGxldCBib2FyZCA9IGJvYXJkT3JpZ2luLnNsaWNlKDApO1xuICAgIGNvbnN0IGZvbnRGYWN0b3IgPSBsYXlvdXRDb25maWcuZm9udFNpemVFbmxhcmdlRmFjdG9yLCBpbXBvcnRhbnRDb3VudCA9IE1hdGgubWluKGltcG9ydGFudFdvcmRDb3VudCwgd29yZHMubGVuZ3RoKTtcbiAgICBsZXQgd2VpZ2h0U3RkID0gMDtcbiAgICBpZiAod29yZHMubGVuZ3RoID4gaW1wb3J0YW50Q291bnQpIHtcbiAgICAgICAgd2VpZ2h0U3RkID0gd29yZHMuc29ydCgoKHdvcmQwLCB3b3JkMSkgPT4gd29yZDEud2VpZ2h0IC0gd29yZDAud2VpZ2h0KSlbaW1wb3J0YW50Q291bnQgLSAxXS53ZWlnaHQ7XG4gICAgfVxuICAgIGxldCBpbXBvcnRhbnRXb3JkU3VjY2Vzc2VkTnVtID0gMCwgZ2xvYmFsRW5sYXJnZUZhY3RvciA9IDEsIGxheW91dEZpbmlzaCA9ICExO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmVnaW9ucy5sZW5ndGg7IGsrKykge1xuICAgICAgICBjb25zdCByZWdpb24gPSByZWdpb25zW2tdLCB7d29yZHM6IHJlZ2lvbldvcmRzLCBjZW50ZXI6IGNlbnRlciwgbWF4UjogbWF4UiwgcmF0aW86IHJhdGlvfSA9IHJlZ2lvbjtcbiAgICAgICAgbGV0IHJlc3RhcnRUYWcgPSAhMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWdpb25Xb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbWVhc3VyZVNwcml0ZShjYW52YXMsIGN0eCwgd29yZHMsIGkpO1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHJlZ2lvbldvcmRzW2ldO1xuICAgICAgICAgICAgaWYgKHdvcmQueCA9IGNlbnRlclswXSwgd29yZC55ID0gY2VudGVyWzFdLCB3b3JkLmhhc1RleHQgJiYgd29yZC5zcHJpdGUgJiYgcGxhY2UoYm9hcmQsIHdvcmQsIG1heFIsIHJhdGlvLCBzaXplLCBib2FyZFNpemUsIHN0ZXBGYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmQuaGFzUGxhY2VkID0gITAsIHdvcmQud2VpZ2h0ID49IHdlaWdodFN0ZCAmJiBpbXBvcnRhbnRXb3JkU3VjY2Vzc2VkTnVtKyssIFxuICAgICAgICAgICAgICAgIGltcG9ydGFudFdvcmRTdWNjZXNzZWROdW0gPj0gaW1wb3J0YW50Q291bnQgJiYgIWxheW91dEZpbmlzaCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFbmxhcmdlRmFjdG9yICo9IGZvbnRGYWN0b3IsIHdvcmRzLmZvckVhY2goKHdvcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZC5oYXNUZXh0ID0gITEsIHdvcmQuc3ByaXRlID0gbnVsbCwgd29yZC5mb250U2l6ZSA9IHdvcmQuZm9udFNpemUgKiBmb250RmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB9KSksIGJvYXJkID0gYm9hcmRPcmlnaW4uc2xpY2UoMCksIHJlc3RhcnRUYWcgPSAhMCwgaW1wb3J0YW50V29yZFN1Y2Nlc3NlZE51bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmQud2VpZ2h0ID49IHdlaWdodFN0ZCAmJiBnbG9iYWxFbmxhcmdlRmFjdG9yID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB3b3Jkcy5mb3JFYWNoKCh3b3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQuaGFzVGV4dCA9ICExLCB3b3JkLnNwcml0ZSA9IG51bGwsIHdvcmQuZm9udFNpemUgPSB3b3JkLmZvbnRTaXplIC8gZm9udEZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBnbG9iYWxFbmxhcmdlRmFjdG9yIC89IGZvbnRGYWN0b3IsIGxheW91dEZpbmlzaCA9ICEwLCBib2FyZCA9IGJvYXJkT3JpZ2luLnNsaWNlKDApLCBcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydFRhZyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdvcmQud2VpZ2h0ID49IHdlaWdodFN0ZCkgcmV0dXJuIGxheW91dEdsb2JhbFNocmluayh3b3JkcywgbGF5b3V0Q29uZmlnLCBzZWdtZW50YXRpb25PdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnRUYWcgJiYgKGsgPSAtMSk7XG4gICAgfVxuICAgIGZvciAobGV0IF8gPSAwOyBfIDwgbGF5b3V0Q29uZmlnLnRleHRMYXlvdXRUaW1lczsgXysrKSB7XG4gICAgICAgIGNvbnN0IGZhaWxlZFdvcmRzID0gd29yZHMuZmlsdGVyKCh3b3JkID0+ICh3b3JkLmhhc1BsYWNlZCB8fCAod29yZC5oYXNUZXh0ID0gITEsIFxuICAgICAgICB3b3JkLnNwcml0ZSA9IG51bGwsIHdvcmQuZm9udFNpemUgPSBNYXRoLm1heCh+fih3b3JkLmZvbnRTaXplICogbGF5b3V0Q29uZmlnLmZvbnRTaXplU2hyaW5rRmFjdG9yKSwgbGF5b3V0Q29uZmlnLm1pbkZvbnRTaXplKSksIFxuICAgICAgICAhd29yZC5oYXNQbGFjZWQpKSk7XG4gICAgICAgIGlmICgwID09PSBmYWlsZWRXb3Jkcy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhaWxlZFdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gZmFpbGVkV29yZHNbaV07XG4gICAgICAgICAgICBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCBmYWlsZWRXb3JkcywgaSksIHdvcmQueCA9IHNoYXBlQ2VudGVyWzBdLCB3b3JkLnkgPSBzaGFwZUNlbnRlclsxXSwgXG4gICAgICAgICAgICB3b3JkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIHdvcmQsIHNoYXBlTWF4Uiwgc2hhcGVSYXRpbywgc2l6ZSwgYm9hcmRTaXplLCBzdGVwRmFjdG9yKSAmJiAod29yZC5oYXNQbGFjZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF5b3V0Q29uZmlnLmJvYXJkID0gYm9hcmQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlKGJvYXJkLCB3b3JkLCBtYXhSLCByYXRpbywgc2l6ZSwgYm9hcmRTaXplLCBzdGVwRmFjdG9yKSB7XG4gICAgY29uc3Qgc3RhcnRYID0gd29yZC54LCBzdGFydFkgPSB3b3JkLnksIHNwaXJhbCA9IGFyY2hpbWVkZWFuU3BpcmFsKHJhdGlvKSwgZHQgPSAxICogc3RlcEZhY3RvcjtcbiAgICBsZXQgZHhkeSwgZHgsIGR5LCB0ID0gLWR0O1xuICAgIGZvciAoO2R4ZHkgPSBzcGlyYWwodCArPSBkdCk7ICkge1xuICAgICAgICBjb25zdCB7d29yZFNpemU6IHdvcmRTaXplLCBib3VuZHM6IHtkVG9wOiBkVG9wLCBkQm90dG9tOiBkQm90dG9tLCBkTGVmdDogZExlZnQsIGRSaWdodDogZFJpZ2h0fX0gPSB3b3JkO1xuICAgICAgICBpZiAoZHggPSBkeGR5WzBdLCBkeSA9IGR4ZHlbMV0sIE1hdGgubWluKE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSA+PSBtYXhSKSBicmVhaztcbiAgICAgICAgaWYgKHdvcmQueCA9IH5+KHN0YXJ0WCArIGR4KSwgd29yZC55ID0gfn4oc3RhcnRZICsgZHkpLCAhKHdvcmQueCAtIGRMZWZ0IDwgMCB8fCB3b3JkLnggKyBkUmlnaHQgPiBzaXplWzBdIHx8IHdvcmQueSAtIGRUb3AgPCAwIHx8IHdvcmQueSArIGRCb3R0b20gPiBzaXplWzFdIHx8IGlzQ29sbGlkZVdpdGhCb2FyZCh3b3JkLCBib2FyZCwgYm9hcmRTaXplKSkpIHJldHVybiBwbGFjZVdvcmRPbkJvYXJkKHdvcmQsIGJvYXJkLCBib2FyZFNpemUpLCBcbiAgICAgICAgITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBsYWNlV29yZE9uQm9hcmQod29yZCwgYm9hcmQsIGJvYXJkU2l6ZSkge1xuICAgIGNvbnN0IHt3b3JkU2l6ZTogd29yZFNpemV9ID0gd29yZCwgc3ByaXRlID0gd29yZC5zcHJpdGUsIHcgPSB3b3JkU2l6ZVswXSA+PiA1LCBzdyA9IGJvYXJkU2l6ZVswXSA+PiA1LCBseCA9IHdvcmQueCAtICh3IDw8IDQpLCBzeCA9IGx4ICUgMzIsIG1zeCA9IDMyIC0gc3gsIGggPSB3b3JkU2l6ZVsxXTtcbiAgICBsZXQgbGFzdCwgeCA9ICh3b3JkLnkgLSAod29yZFNpemVbMV0gPj4gMSkpICogc3cgKyAobHggPj4gNSk7XG4gICAgaWYgKDAgPT09IHN4KSBmb3IgKGxldCBqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykgYm9hcmRbeCArIGldIHw9IHNwcml0ZVtqICogdyArIGldO1xuICAgICAgICB4ICs9IHN3O1xuICAgIH0gZWxzZSBmb3IgKGxldCBqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgICBsYXN0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdzsgaSsrKSBib2FyZFt4ICsgaV0gfD0gbGFzdCA8PCBtc3ggfCAoaSA8IHcgPyAobGFzdCA9IHNwcml0ZVtqICogdyArIGldKSA+Pj4gc3ggOiAwKTtcbiAgICAgICAgeCArPSBzdztcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbGxpZGVXaXRoQm9hcmQod29yZCwgYm9hcmQsIGJvYXJkU2l6ZSkge1xuICAgIGNvbnN0IHtzcHJpdGU6IHNwcml0ZSwgd29yZFNpemU6IHdvcmRTaXplfSA9IHdvcmQsIHN3ID0gYm9hcmRTaXplWzBdID4+IDUsIHcgPSB3b3JkU2l6ZVswXSA+PiA1LCBseCA9IHdvcmQueCAtICh3IDw8IDQpLCBzeCA9IGx4ICUgMzIsIG1zeCA9IDMyIC0gc3gsIGggPSB3b3JkU2l6ZVsxXTtcbiAgICBsZXQgbGFzdCwgeCA9ICh3b3JkLnkgLSAod29yZFNpemVbMV0gPj4gMSkpICogc3cgKyAobHggPj4gNSk7XG4gICAgaWYgKDAgPT09IHN4KSBmb3IgKGxldCBqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykgaWYgKGJvYXJkW3ggKyBpXSAmIHNwcml0ZVtqICogdyArIGldKSByZXR1cm4gITA7XG4gICAgICAgIHggKz0gc3c7XG4gICAgfSBlbHNlIGZvciAobGV0IGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgIGxhc3QgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB3OyBpKyspIGlmICgobGFzdCA8PCBtc3ggfCAoaSA8IHcgPyAobGFzdCA9IHNwcml0ZVtqICogdyArIGldKSA+Pj4gc3ggOiAwKSkgJiBib2FyZFt4ICsgaV0pIHJldHVybiAhMDtcbiAgICAgICAgeCArPSBzdztcbiAgICB9XG4gICAgcmV0dXJuICExO1xufVxuXG5mdW5jdGlvbiBhcmNoaW1lZGVhblNwaXJhbChyYXRpbykge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbIHJhdGlvICogKHQgKj0gLjEpICogTWF0aC5jb3ModCksIHQgKiBNYXRoLnNpbih0KSBdO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlU3ByaXRlKGNhbnZhcywgY3R4LCB3b3Jkcywgd2kpIHtcbiAgICBpZiAod29yZHNbd2ldLnNwcml0ZSB8fCAwID09PSB3b3Jkc1t3aV0uZm9udFNpemUpIHJldHVybjtcbiAgICBjb25zdCBjdyA9IDIwNDgsIHJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLCBuID0gd29yZHMubGVuZ3RoO1xuICAgIGNhbnZhcy53aWR0aCA9IGN3LCBjYW52YXMuaGVpZ2h0ID0gMjA0OCwgY3R4LmNsZWFyUmVjdCgwLCAwLCBjdywgMjA0OCksIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgIGxldCB3b3JkVywgd29yZEgsIHggPSAwLCB5ID0gMCwgbWF4SGVpZ2h0ID0gMCwgeU1heCA9IDA7XG4gICAgY29uc3Qgd2lEaXN0ID0gd2k7XG4gICAgZm9yICgtLXdpOyArK3dpIDwgbjsgKSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1t3aV0sIGZvbnRTaXplID0gTWF0aC5tYXgod29yZC5mb250U2l6ZSwgMik7XG4gICAgICAgIGlmIChjdHguc2F2ZSgpLCBjdHguZm9udCA9IHdvcmQuZm9udFN0eWxlICsgXCIgXCIgKyB3b3JkLmZvbnRXZWlnaHQgKyBcIiBcIiArIGZvbnRTaXplICsgXCJweCBcIiArIHdvcmQuZm9udEZhbWlseSwgXG4gICAgICAgIHdvcmRXID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmQudGV4dCArIFwibVwiKS53aWR0aCArIDIgKiB3b3JkLnBhZGRpbmcsIHdvcmRIID0gMiAqIGZvbnRTaXplICsgMiAqIHdvcmQucGFkZGluZywgXG4gICAgICAgIDAgIT09IHdvcmQucm90YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzciA9IE1hdGguc2luKHdvcmQucm90YXRlICogcmFkaWFucyksIGNyID0gTWF0aC5jb3Mod29yZC5yb3RhdGUgKiByYWRpYW5zKSwgd2NyID0gd29yZFcgKiBjciwgd3NyID0gd29yZFcgKiBzciwgaGNyID0gd29yZEggKiBjciwgaHNyID0gd29yZEggKiBzcjtcbiAgICAgICAgICAgIHdvcmRXID0gTWF0aC5tYXgoTWF0aC5hYnMod2NyICsgaHNyKSwgTWF0aC5hYnMod2NyIC0gaHNyKSksIHdvcmRIID0gfn5NYXRoLm1heChNYXRoLmFicyh3c3IgKyBoY3IpLCBNYXRoLmFicyh3c3IgLSBoY3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZFcgPSB3b3JkVyArIDMxID4+IDUgPDwgNSwgd29yZEggPSBNYXRoLmNlaWwod29yZEgpLCB3b3JkSCA+IG1heEhlaWdodCAmJiAobWF4SGVpZ2h0ID0gd29yZEgpLCBcbiAgICAgICAgeCArIHdvcmRXID49IGN3ICYmICh4ID0gMCwgeSArPSBtYXhIZWlnaHQsIG1heEhlaWdodCA9IHdvcmRIKSwgeSArIHdvcmRIID49IDIwNDgpIHtcbiAgICAgICAgICAgIGlmICgwID09PSB5KSB7XG4gICAgICAgICAgICAgICAgd29yZC5oYXNUZXh0ID0gITE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB5ICsgd29yZEggPj0geU1heCAmJiAoeU1heCA9IHkgKyB3b3JkSCksIGN0eC50cmFuc2xhdGUoeCArICh3b3JkVyA+PiAxKSwgeSArICh3b3JkSCA+PiAxKSksIFxuICAgICAgICAwICE9PSB3b3JkLnJvdGF0ZSAmJiBjdHgucm90YXRlKHdvcmQucm90YXRlICogcmFkaWFucyksIGN0eC5maWxsVGV4dCh3b3JkLnRleHQsIDAsIDApLCBcbiAgICAgICAgd29yZC5wYWRkaW5nICYmIChjdHgubGluZVdpZHRoID0gMiAqIHdvcmQucGFkZGluZywgY3R4LnN0cm9rZVRleHQod29yZC50ZXh0LCAwLCAwKSksIFxuICAgICAgICBjdHgucmVzdG9yZSgpLCB3b3JkLkxUID0gWyB4LCB5IF0sIHdvcmQud29yZFNpemUgPSBbIHdvcmRXLCB3b3JkSCBdLCB3b3JkLmhhc1RleHQgPSAhMCwgXG4gICAgICAgIHggKz0gd29yZFc7XG4gICAgfVxuICAgIGlmICgwID09PSB5TWF4KSByZXR1cm47XG4gICAgY29uc3QgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjdywgeU1heCkuZGF0YTtcbiAgICBsZXQgaSwgajtcbiAgICBmb3IgKDstLXdpID49IHdpRGlzdDsgKSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1t3aV07XG4gICAgICAgIGlmICghd29yZC5oYXNUZXh0KSB7XG4gICAgICAgICAgICB3b3JkLmJvdW5kcyA9IHtcbiAgICAgICAgICAgICAgICBkVG9wOiAxIC8gMCxcbiAgICAgICAgICAgICAgICBkQm90dG9tOiAtMSAvIDAsXG4gICAgICAgICAgICAgICAgZExlZnQ6IDEgLyAwLFxuICAgICAgICAgICAgICAgIGRSaWdodDogLTEgLyAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge0xUOiBMVCA9IFsgMCwgMCBdLCB3b3JkU2l6ZTogd29yZFNpemV9ID0gd29yZDtcbiAgICAgICAgW3gsIHldID0gTFQ7XG4gICAgICAgIGNvbnN0IHczMiA9IHdvcmRTaXplWzBdID4+IDUsIHNwcml0ZSA9IG5ldyBBcnJheSh3MzIgKiB3b3JkU2l6ZVsxXSkuZmlsbCgwKTtcbiAgICAgICAgbGV0IFtkVG9wLCBkQm90dG9tLCBkTGVmdCwgZFJpZ2h0XSA9IFsgMSAvIDAsIC0xIC8gMCwgMSAvIDAsIC0xIC8gMCBdO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgd29yZFNpemVbMV07IGorKykge1xuICAgICAgICAgICAgbGV0IHNlZW47XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd29yZFNpemVbMF07IGkrKykgaWYgKHBpeGVsc1s0ICogKCh5ICsgaikgKiBjdyArICh4ICsgaSkpICsgM10gPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IDEgPDwgMzEgLSBpICUgMzI7XG4gICAgICAgICAgICAgICAgc3ByaXRlW3czMiAqIGogKyAoaSA+PiA1KV0gfD0gbSwgaSA8IGRMZWZ0ICYmIChkTGVmdCA9IGkpLCBpID4gZFJpZ2h0ICYmIChkUmlnaHQgPSBpKSwgXG4gICAgICAgICAgICAgICAgc2VlbiB8PSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlbiAmJiAoaiA8IGRUb3AgJiYgKGRUb3AgPSBqKSwgaiA+IGRCb3R0b20gJiYgKGRCb3R0b20gPSBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgd29yZC5ib3VuZHMgPSB7XG4gICAgICAgICAgICBkVG9wOiAod29yZFNpemVbMV0gPj4gMSkgLSBkVG9wLFxuICAgICAgICAgICAgZEJvdHRvbTogZEJvdHRvbSAtICh3b3JkU2l6ZVsxXSA+PiAxKSxcbiAgICAgICAgICAgIGRMZWZ0OiAod29yZFNpemVbMF0gPj4gMSkgLSBkTGVmdCxcbiAgICAgICAgICAgIGRSaWdodDogZFJpZ2h0IC0gKHdvcmRTaXplWzBdID4+IDEpXG4gICAgICAgIH0sIHdvcmQuc3ByaXRlID0gc3ByaXRlLCBkZWxldGUgd29yZC5MVDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRCb2FyZFdpdGhTaGFwZShzZWdtZW50YXRpb25PdXRwdXQpIHtcbiAgICBjb25zdCB7c2VnbWVudGF0aW9uOiB7bGFiZWxzOiBsYWJlbHN9LCBib2FyZFNpemU6IGJvYXJkU2l6ZSwgc2l6ZTogc2l6ZX0gPSBzZWdtZW50YXRpb25PdXRwdXQsIHczMiA9IGJvYXJkU2l6ZVswXSA+PiA1LCBib2FyZCA9IG5ldyBBcnJheSh3MzIgKiBzaXplWzFdKS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZVsxXTsgaSsrKSBmb3IgKGxldCBqID0gMDsgaiA8IHNpemVbMF07IGorKykge1xuICAgICAgICBpZiAoMCA9PT0gbGFiZWxzW2kgKiBzaXplWzBdICsgal0pIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAxIDw8IDMxIC0gaiAlIDMyO1xuICAgICAgICAgICAgYm9hcmRbdzMyICogaSArIChqID4+IDUpXSB8PSBtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChib2FyZFNpemVbMF0gPiBzaXplWzBdKSB7XG4gICAgICAgIGNvbnN0IG0gPSAoMSA8PCBib2FyZFNpemVbMF0gLSBzaXplWzBdKSAtIDE7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZVsxXTsgeSsrKSB7XG4gICAgICAgICAgICBib2FyZFt3MzIgKiB5ICsgdzMyIC0gMV0gfD0gbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm9hcmQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-wordcloud-shape@0.16.11/node_modules/@visactor/vgrammar-wordcloud-shape/es/wordle.js\n");

/***/ })

};
;