"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@visactor+vgrammar-sankey@0.16.11";
exports.ids = ["vendor-chunks/@visactor+vgrammar-sankey@0.16.11"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/format.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/format.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatLinkPath: () => (/* binding */ formatLinkPath),\n/* harmony export */   formatLinkPolygon: () => (/* binding */ formatLinkPolygon),\n/* harmony export */   formatNodeRect: () => (/* binding */ formatNodeRect),\n/* harmony export */   getAlignEndTexts: () => (/* binding */ getAlignEndTexts),\n/* harmony export */   getAlignStartTexts: () => (/* binding */ getAlignStartTexts),\n/* harmony export */   getBoundsOfNodes: () => (/* binding */ getBoundsOfNodes)\n/* harmony export */ });\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isNil.js\");\n\n\nconst formatNodeRect = nodes => nodes.map((node => Object.assign({}, node, {\n    x: node.x0,\n    y: node.y0,\n    width: node.x1 - node.x0,\n    height: node.y1 - node.y0\n})));\n\nconst formatLinkPolygon = links => {\n    var _a;\n    return !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(null === (_a = null == links ? void 0 : links[0]) || void 0 === _a ? void 0 : _a.vertical) ? links.map((link => {\n        const half = link.thickness / 2, points = [ {\n            x: link.x0 - half,\n            y: link.y0\n        }, {\n            x: link.x1 - half,\n            y: link.y1\n        }, {\n            x: link.x1 + half,\n            y: link.y1\n        }, {\n            x: link.x0 + half,\n            y: link.y0\n        } ];\n        return Object.assign({}, link, {\n            points: points\n        });\n    })) : links.map((link => {\n        const half = link.thickness / 2, points = [ {\n            x: link.x0,\n            y: link.y0 - half\n        }, {\n            x: link.x1,\n            y: link.y1 - half\n        }, {\n            x: link.x1,\n            y: link.y1 + half\n        }, {\n            x: link.x0,\n            y: link.y0 + half\n        } ];\n        return Object.assign({}, link, {\n            points: points\n        });\n    }));\n};\n\nconst formatLinkPath = (links, round = !0) => {\n    var _a;\n    return !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(null === (_a = null == links ? void 0 : links[0]) || void 0 === _a ? void 0 : _a.vertical) ? links.map((link => {\n        const half = link.thickness / 2;\n        let y0 = link.y0, y1 = link.y1, midY = (y0 + y1) / 2, x00 = link.x0 - half, x01 = link.x0 + half, x10 = link.x1 - half, x11 = link.x1 + half;\n        return round && (y0 = Math.round(y0), y1 = Math.round(y1), midY = Math.round(midY), \n        x00 = Math.round(x00), x01 = Math.round(x01), x10 = Math.round(x10), x11 = Math.round(x11)), \n        Object.assign({}, link, {\n            path: `\\n            M${x00},${y0}\\n            C${x00},${midY},${x10},${midY},${x10},${y1}\\n            L${x11},${y1}\\n            C${x11},${midY},${x01},${midY},${x01},${y0}\\n            Z\\n            `\n        });\n    })) : links.map((link => {\n        const half = link.thickness / 2;\n        let x0 = link.x0, x1 = link.x1, midX = (x0 + x1) / 2, y00 = link.y0 - half, y01 = link.y0 + half, y10 = link.y1 - half, y11 = link.y1 + half;\n        return round && (x0 = Math.round(x0), x1 = Math.round(x1), midX = Math.round(midX), \n        y00 = Math.round(y00), y01 = Math.round(y01), y10 = Math.round(y10), y11 = Math.round(y11)), \n        Object.assign({}, link, {\n            path: `\\n          M${x0},${y00}\\n          C${midX},${y00},${midX},${y10},${x1},${y10}\\n          L${x1},${y11}\\n          C${midX},${y11},${midX},${y01},${x0},${y01}\\n          Z`\n        });\n    }));\n};\n\nconst getBoundsOfNodes = nodes => {\n    let x0 = 1 / 0, x1 = -1 / 0, y0 = 1 / 0, y1 = -1 / 0;\n    return nodes.forEach((node => {\n        x0 = Math.min(node.x0, x0), x1 = Math.max(node.x1, x1), y0 = Math.min(node.y0, y0), \n        y1 = Math.max(node.y1, y1);\n    })), {\n        x0: x0,\n        x1: x1,\n        y0: y0,\n        y1: y1,\n        width: x1 - x0,\n        height: y1 - y0\n    };\n};\n\nconst isNodeVertical = node => node.sourceLinks && node.sourceLinks.length ? !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node.sourceLinks[0].x0) : !(!node.targetLinks || !node.targetLinks.length) && !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node.targetLinks[0].x0);\n\nconst getAlignStartTexts = (nodes, offset = 0) => isNodeVertical(nodes[0]) ? nodes.map((node => ({\n    y: node.y1,\n    x: (node.x0 + node.x1) / 2,\n    datum: node.datum,\n    key: node.key\n}))) : nodes.map((node => ({\n    x: node.x1,\n    y: (node.y0 + node.y1) / 2,\n    datum: node.datum,\n    key: node.key\n})));\n\nconst getAlignEndTexts = (nodes, offset = 0) => isNodeVertical(nodes[0]) ? nodes.map((node => ({\n    y: node.y1 - offset,\n    x: (node.x0 + node.x1) / 2,\n    datum: node.datum,\n    key: node.key\n}))) : nodes.map((node => ({\n    x: node.x0 - offset,\n    y: (node.y0 + node.y1) / 2,\n    datum: node.datum,\n    key: node.key\n})));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXNhbmtleUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItc2Fua2V5L2VzL2Zvcm1hdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlDOztBQUVsQyxtRUFBbUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQSxZQUFZLDREQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDViwrQkFBK0I7QUFDL0I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDViwrQkFBK0I7QUFDL0I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVPO0FBQ1A7QUFDQSxZQUFZLDREQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLG9DQUFvQyxJQUFJLEdBQUcsR0FBRyxpQkFBaUIsSUFBSSxHQUFHLEtBQUssR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFHLElBQUksR0FBRyxHQUFHLGlCQUFpQixJQUFJLEdBQUcsR0FBRyxpQkFBaUIsSUFBSSxHQUFHLEtBQUssR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFHLElBQUksR0FBRyxHQUFHO0FBQzNMLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsa0NBQWtDLEdBQUcsR0FBRyxJQUFJLGVBQWUsS0FBSyxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLGVBQWUsR0FBRyxHQUFHLElBQUksZUFBZSxLQUFLLEdBQUcsSUFBSSxHQUFHLEtBQUssR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUk7QUFDbkwsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFLDREQUFLLGdGQUFnRiw0REFBSzs7QUFFaks7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci1zYW5rZXlAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXNhbmtleS9lcy9mb3JtYXQuanM/ODFiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05pbCB9IGZyb20gXCJAdmlzYWN0b3IvdnV0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBmb3JtYXROb2RlUmVjdCA9IG5vZGVzID0+IG5vZGVzLm1hcCgobm9kZSA9PiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7XG4gICAgeDogbm9kZS54MCxcbiAgICB5OiBub2RlLnkwLFxuICAgIHdpZHRoOiBub2RlLngxIC0gbm9kZS54MCxcbiAgICBoZWlnaHQ6IG5vZGUueTEgLSBub2RlLnkwXG59KSkpO1xuXG5leHBvcnQgY29uc3QgZm9ybWF0TGlua1BvbHlnb24gPSBsaW5rcyA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhaXNOaWwobnVsbCA9PT0gKF9hID0gbnVsbCA9PSBsaW5rcyA/IHZvaWQgMCA6IGxpbmtzWzBdKSB8fCB2b2lkIDAgPT09IF9hID8gdm9pZCAwIDogX2EudmVydGljYWwpID8gbGlua3MubWFwKChsaW5rID0+IHtcbiAgICAgICAgY29uc3QgaGFsZiA9IGxpbmsudGhpY2tuZXNzIC8gMiwgcG9pbnRzID0gWyB7XG4gICAgICAgICAgICB4OiBsaW5rLngwIC0gaGFsZixcbiAgICAgICAgICAgIHk6IGxpbmsueTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogbGluay54MSAtIGhhbGYsXG4gICAgICAgICAgICB5OiBsaW5rLnkxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IGxpbmsueDEgKyBoYWxmLFxuICAgICAgICAgICAgeTogbGluay55MVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBsaW5rLngwICsgaGFsZixcbiAgICAgICAgICAgIHk6IGxpbmsueTBcbiAgICAgICAgfSBdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbGluaywge1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgfSk7XG4gICAgfSkpIDogbGlua3MubWFwKChsaW5rID0+IHtcbiAgICAgICAgY29uc3QgaGFsZiA9IGxpbmsudGhpY2tuZXNzIC8gMiwgcG9pbnRzID0gWyB7XG4gICAgICAgICAgICB4OiBsaW5rLngwLFxuICAgICAgICAgICAgeTogbGluay55MCAtIGhhbGZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogbGluay54MSxcbiAgICAgICAgICAgIHk6IGxpbmsueTEgLSBoYWxmXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IGxpbmsueDEsXG4gICAgICAgICAgICB5OiBsaW5rLnkxICsgaGFsZlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBsaW5rLngwLFxuICAgICAgICAgICAgeTogbGluay55MCArIGhhbGZcbiAgICAgICAgfSBdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbGluaywge1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdExpbmtQYXRoID0gKGxpbmtzLCByb3VuZCA9ICEwKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhaXNOaWwobnVsbCA9PT0gKF9hID0gbnVsbCA9PSBsaW5rcyA/IHZvaWQgMCA6IGxpbmtzWzBdKSB8fCB2b2lkIDAgPT09IF9hID8gdm9pZCAwIDogX2EudmVydGljYWwpID8gbGlua3MubWFwKChsaW5rID0+IHtcbiAgICAgICAgY29uc3QgaGFsZiA9IGxpbmsudGhpY2tuZXNzIC8gMjtcbiAgICAgICAgbGV0IHkwID0gbGluay55MCwgeTEgPSBsaW5rLnkxLCBtaWRZID0gKHkwICsgeTEpIC8gMiwgeDAwID0gbGluay54MCAtIGhhbGYsIHgwMSA9IGxpbmsueDAgKyBoYWxmLCB4MTAgPSBsaW5rLngxIC0gaGFsZiwgeDExID0gbGluay54MSArIGhhbGY7XG4gICAgICAgIHJldHVybiByb3VuZCAmJiAoeTAgPSBNYXRoLnJvdW5kKHkwKSwgeTEgPSBNYXRoLnJvdW5kKHkxKSwgbWlkWSA9IE1hdGgucm91bmQobWlkWSksIFxuICAgICAgICB4MDAgPSBNYXRoLnJvdW5kKHgwMCksIHgwMSA9IE1hdGgucm91bmQoeDAxKSwgeDEwID0gTWF0aC5yb3VuZCh4MTApLCB4MTEgPSBNYXRoLnJvdW5kKHgxMSkpLCBcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbGluaywge1xuICAgICAgICAgICAgcGF0aDogYFxcbiAgICAgICAgICAgIE0ke3gwMH0sJHt5MH1cXG4gICAgICAgICAgICBDJHt4MDB9LCR7bWlkWX0sJHt4MTB9LCR7bWlkWX0sJHt4MTB9LCR7eTF9XFxuICAgICAgICAgICAgTCR7eDExfSwke3kxfVxcbiAgICAgICAgICAgIEMke3gxMX0sJHttaWRZfSwke3gwMX0sJHttaWRZfSwke3gwMX0sJHt5MH1cXG4gICAgICAgICAgICBaXFxuICAgICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICB9KSkgOiBsaW5rcy5tYXAoKGxpbmsgPT4ge1xuICAgICAgICBjb25zdCBoYWxmID0gbGluay50aGlja25lc3MgLyAyO1xuICAgICAgICBsZXQgeDAgPSBsaW5rLngwLCB4MSA9IGxpbmsueDEsIG1pZFggPSAoeDAgKyB4MSkgLyAyLCB5MDAgPSBsaW5rLnkwIC0gaGFsZiwgeTAxID0gbGluay55MCArIGhhbGYsIHkxMCA9IGxpbmsueTEgLSBoYWxmLCB5MTEgPSBsaW5rLnkxICsgaGFsZjtcbiAgICAgICAgcmV0dXJuIHJvdW5kICYmICh4MCA9IE1hdGgucm91bmQoeDApLCB4MSA9IE1hdGgucm91bmQoeDEpLCBtaWRYID0gTWF0aC5yb3VuZChtaWRYKSwgXG4gICAgICAgIHkwMCA9IE1hdGgucm91bmQoeTAwKSwgeTAxID0gTWF0aC5yb3VuZCh5MDEpLCB5MTAgPSBNYXRoLnJvdW5kKHkxMCksIHkxMSA9IE1hdGgucm91bmQoeTExKSksIFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBsaW5rLCB7XG4gICAgICAgICAgICBwYXRoOiBgXFxuICAgICAgICAgIE0ke3gwfSwke3kwMH1cXG4gICAgICAgICAgQyR7bWlkWH0sJHt5MDB9LCR7bWlkWH0sJHt5MTB9LCR7eDF9LCR7eTEwfVxcbiAgICAgICAgICBMJHt4MX0sJHt5MTF9XFxuICAgICAgICAgIEMke21pZFh9LCR7eTExfSwke21pZFh9LCR7eTAxfSwke3gwfSwke3kwMX1cXG4gICAgICAgICAgWmBcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEJvdW5kc09mTm9kZXMgPSBub2RlcyA9PiB7XG4gICAgbGV0IHgwID0gMSAvIDAsIHgxID0gLTEgLyAwLCB5MCA9IDEgLyAwLCB5MSA9IC0xIC8gMDtcbiAgICByZXR1cm4gbm9kZXMuZm9yRWFjaCgobm9kZSA9PiB7XG4gICAgICAgIHgwID0gTWF0aC5taW4obm9kZS54MCwgeDApLCB4MSA9IE1hdGgubWF4KG5vZGUueDEsIHgxKSwgeTAgPSBNYXRoLm1pbihub2RlLnkwLCB5MCksIFxuICAgICAgICB5MSA9IE1hdGgubWF4KG5vZGUueTEsIHkxKTtcbiAgICB9KSksIHtcbiAgICAgICAgeDA6IHgwLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkwOiB5MCxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB3aWR0aDogeDEgLSB4MCxcbiAgICAgICAgaGVpZ2h0OiB5MSAtIHkwXG4gICAgfTtcbn07XG5cbmNvbnN0IGlzTm9kZVZlcnRpY2FsID0gbm9kZSA9PiBub2RlLnNvdXJjZUxpbmtzICYmIG5vZGUuc291cmNlTGlua3MubGVuZ3RoID8gIWlzTmlsKG5vZGUuc291cmNlTGlua3NbMF0ueDApIDogISghbm9kZS50YXJnZXRMaW5rcyB8fCAhbm9kZS50YXJnZXRMaW5rcy5sZW5ndGgpICYmICFpc05pbChub2RlLnRhcmdldExpbmtzWzBdLngwKTtcblxuZXhwb3J0IGNvbnN0IGdldEFsaWduU3RhcnRUZXh0cyA9IChub2Rlcywgb2Zmc2V0ID0gMCkgPT4gaXNOb2RlVmVydGljYWwobm9kZXNbMF0pID8gbm9kZXMubWFwKChub2RlID0+ICh7XG4gICAgeTogbm9kZS55MSxcbiAgICB4OiAobm9kZS54MCArIG5vZGUueDEpIC8gMixcbiAgICBkYXR1bTogbm9kZS5kYXR1bSxcbiAgICBrZXk6IG5vZGUua2V5XG59KSkpIDogbm9kZXMubWFwKChub2RlID0+ICh7XG4gICAgeDogbm9kZS54MSxcbiAgICB5OiAobm9kZS55MCArIG5vZGUueTEpIC8gMixcbiAgICBkYXR1bTogbm9kZS5kYXR1bSxcbiAgICBrZXk6IG5vZGUua2V5XG59KSkpO1xuXG5leHBvcnQgY29uc3QgZ2V0QWxpZ25FbmRUZXh0cyA9IChub2Rlcywgb2Zmc2V0ID0gMCkgPT4gaXNOb2RlVmVydGljYWwobm9kZXNbMF0pID8gbm9kZXMubWFwKChub2RlID0+ICh7XG4gICAgeTogbm9kZS55MSAtIG9mZnNldCxcbiAgICB4OiAobm9kZS54MCArIG5vZGUueDEpIC8gMixcbiAgICBkYXR1bTogbm9kZS5kYXR1bSxcbiAgICBrZXk6IG5vZGUua2V5XG59KSkpIDogbm9kZXMubWFwKChub2RlID0+ICh7XG4gICAgeDogbm9kZS54MCAtIG9mZnNldCxcbiAgICB5OiAobm9kZS55MCArIG5vZGUueTEpIC8gMixcbiAgICBkYXR1bTogbm9kZS5kYXR1bSxcbiAgICBrZXk6IG5vZGUua2V5XG59KSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/hierarchy.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/hierarchy.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateNodeValue: () => (/* binding */ calculateNodeValue)\n/* harmony export */ });\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isNil.js\");\n\n\nconst calculateNodeValue = subTree => {\n    let sum = 0;\n    return subTree.forEach(((node, index) => {\n        var _a;\n        (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node.value) && ((null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? node.value = calculateNodeValue(node.children) : node.value = 0), \n        sum += Math.abs(node.value);\n    })), sum;\n};\n//# sourceMappingURL=hierarchy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXNhbmtleUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItc2Fua2V5L2VzL2hpZXJhcmNoeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5Qzs7QUFFbEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFLO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2FjdG9yLW5leHQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXNhbmtleUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItc2Fua2V5L2VzL2hpZXJhcmNoeS5qcz8zZDg5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTmlsIH0gZnJvbSBcIkB2aXNhY3Rvci92dXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZU5vZGVWYWx1ZSA9IHN1YlRyZWUgPT4ge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIHJldHVybiBzdWJUcmVlLmZvckVhY2goKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlzTmlsKG5vZGUudmFsdWUpICYmICgobnVsbCA9PT0gKF9hID0gbm9kZS5jaGlsZHJlbikgfHwgdm9pZCAwID09PSBfYSA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPyBub2RlLnZhbHVlID0gY2FsY3VsYXRlTm9kZVZhbHVlKG5vZGUuY2hpbGRyZW4pIDogbm9kZS52YWx1ZSA9IDApLCBcbiAgICAgICAgc3VtICs9IE1hdGguYWJzKG5vZGUudmFsdWUpO1xuICAgIH0pKSwgc3VtO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpZXJhcmNoeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/hierarchy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/index.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/index.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SankeyLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_0__.SankeyLayout),\n/* harmony export */   formatLinkPath: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_2__.formatLinkPath),\n/* harmony export */   formatLinkPolygon: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_2__.formatLinkPolygon),\n/* harmony export */   formatNodeRect: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_2__.formatNodeRect),\n/* harmony export */   getAlignEndTexts: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_2__.getAlignEndTexts),\n/* harmony export */   getAlignStartTexts: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_2__.getAlignStartTexts),\n/* harmony export */   getBoundsOfNodes: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_2__.getBoundsOfNodes),\n/* harmony export */   registerSankeyHighlight: () => (/* binding */ registerSankeyHighlight),\n/* harmony export */   registerSankeyTransforms: () => (/* binding */ registerSankeyTransforms),\n/* harmony export */   sankeyTransform: () => (/* binding */ sankeyTransform)\n/* harmony export */ });\n/* harmony import */ var _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @visactor/vgrammar-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-core@0.16.11/node_modules/@visactor/vgrammar-core/es/core/factory.js\");\n/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/transform.js\");\n/* harmony import */ var _sankey_highlight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sankey-highlight */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/sankey-highlight.js\");\n/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/layout.js\");\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./format */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/format.js\");\n\n\n\n\n\n\n\n\nconst sankeyTransform = _transform__WEBPACK_IMPORTED_MODULE_1__.transform;\n\n\n\n\n\nconst registerSankeyTransforms = () => {\n    _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_3__.Factory.registerTransform(\"sankey\", {\n        transform: _transform__WEBPACK_IMPORTED_MODULE_1__.transform,\n        markPhase: \"beforeJoin\"\n    }, !0);\n};\n\nconst registerSankeyHighlight = () => {\n    _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_3__.Factory.registerInteraction(_sankey_highlight__WEBPACK_IMPORTED_MODULE_4__.SankeyHighlight.type, _sankey_highlight__WEBPACK_IMPORTED_MODULE_4__.SankeyHighlight);\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXNhbmtleUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItc2Fua2V5L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRDs7QUFFVjs7QUFFYTs7QUFFYjs7QUFFakMsd0JBQXdCLGlEQUFTOztBQUVaOztBQUVIOztBQUVsQjtBQUNQLElBQUksNERBQU87QUFDWCxtQkFBbUIsaURBQVM7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUCxJQUFJLDREQUFPLHFCQUFxQiw4REFBZSxPQUFPLDhEQUFlO0FBQ3JFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci1zYW5rZXlAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXNhbmtleS9lcy9pbmRleC5qcz9jZDhiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZhY3RvcnkgfSBmcm9tIFwiQHZpc2FjdG9yL3ZncmFtbWFyLWNvcmVcIjtcblxuaW1wb3J0IHsgdHJhbnNmb3JtIH0gZnJvbSBcIi4vdHJhbnNmb3JtXCI7XG5cbmltcG9ydCB7IFNhbmtleUhpZ2hsaWdodCB9IGZyb20gXCIuL3NhbmtleS1oaWdobGlnaHRcIjtcblxuZXhwb3J0IHsgU2Fua2V5TGF5b3V0IH0gZnJvbSBcIi4vbGF5b3V0XCI7XG5cbmV4cG9ydCBjb25zdCBzYW5rZXlUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbmV4cG9ydCAqIGZyb20gXCIuL2ludGVyZmFjZVwiO1xuXG5leHBvcnQgKiBmcm9tIFwiLi9mb3JtYXRcIjtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyU2Fua2V5VHJhbnNmb3JtcyA9ICgpID0+IHtcbiAgICBGYWN0b3J5LnJlZ2lzdGVyVHJhbnNmb3JtKFwic2Fua2V5XCIsIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIG1hcmtQaGFzZTogXCJiZWZvcmVKb2luXCJcbiAgICB9LCAhMCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJTYW5rZXlIaWdobGlnaHQgPSAoKSA9PiB7XG4gICAgRmFjdG9yeS5yZWdpc3RlckludGVyYWN0aW9uKFNhbmtleUhpZ2hsaWdodC50eXBlLCBTYW5rZXlIaWdobGlnaHQpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/layout.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/layout.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SankeyLayout: () => (/* binding */ SankeyLayout)\n/* harmony export */ });\n/* harmony import */ var _hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hierarchy */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/hierarchy.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/array.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isNil.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/clamper.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isFunction.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/logger.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/toValidNumber.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/pickWithout.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isString.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/clamp.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/isNumber.js\");\n/* harmony import */ var _visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @visactor/vgrammar-util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-util@0.16.11/node_modules/@visactor/vgrammar-util/es/field.js\");\n/* harmony import */ var _visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @visactor/vgrammar-util */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-util@0.16.11/node_modules/@visactor/vgrammar-util/es/direction.js\");\n\n\n\n\n\n\nfunction left(node) {\n    return node.depth;\n}\n\nfunction right(node, maxDepth) {\n    return maxDepth - 1 - node.endDepth;\n}\n\nfunction justify(node, maxDepth) {\n    return node.sourceLinks.length ? node.depth : maxDepth - 1;\n}\n\nfunction center(node, maxDepth, nodeMap) {\n    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__.minInArray)(node.sourceLinks.map((link => nodeMap[link.target].depth))) - 1 : 0;\n}\n\nconst ascendingNodeBreadth = (a, b) => (null == a ? void 0 : a.y0) - (null == b ? void 0 : b.y0), calcDivideValue = (node, isTarget) => {\n    if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node.value)) return null;\n    const res = (isTarget ? node.targetLinks : node.sourceLinks).reduce(((res, sLink) => ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(sLink.value) ? res.count += 1 : res.sum += sLink.value, \n    res)), {\n        sum: 0,\n        count: 0\n    });\n    return res.count > 0 ? (node.value - res.sum) / res.count : null;\n}, alignFunctions = {\n    left: left,\n    right: right,\n    justify: justify,\n    center: center,\n    start: left,\n    end: right\n}, linkClampe = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_2__.clamper)(0, 1);\n\nclass SankeyLayout {\n    constructor(options) {\n        this._ascendingSourceBreadth = (a, b) => ascendingNodeBreadth(this._nodeMap[a.source], this._nodeMap[b.source]) || a.index - b.index, \n        this._ascendingTargetBreadth = (a, b) => ascendingNodeBreadth(this._nodeMap[a.target], this._nodeMap[b.target]) || a.index - b.index, \n        this.options = Object.assign({}, SankeyLayout.defaultOptions, options);\n        const keyOption = this.options.nodeKey, keyFunc = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(keyOption) ? keyOption : keyOption ? (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_4__.field)(keyOption) : null;\n        this._getNodeKey = keyFunc, this._logger = _visactor_vutils__WEBPACK_IMPORTED_MODULE_5__.Logger.getInstance(), this._alignFunc = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.setNodeLayer) ? node => this.options.setNodeLayer(node.datum) : alignFunctions[this.options.nodeAlign];\n    }\n    layout(data, config) {\n        if (!data) return null;\n        const viewBox = \"width\" in config ? {\n            x0: 0,\n            x1: config.width,\n            y0: 0,\n            y1: config.height,\n            width: config.width,\n            height: config.height\n        } : {\n            x0: Math.min(config.x0, config.x1),\n            x1: Math.max(config.x0, config.x1),\n            y0: Math.min(config.y0, config.y1),\n            y1: Math.max(config.y0, config.y1),\n            width: Math.abs(config.x1 - config.x0),\n            height: Math.abs(config.y1 - config.y0)\n        };\n        (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_6__.isVertical)(this.options.direction) ? this._viewBox = {\n            x0: viewBox.y0,\n            x1: viewBox.y1,\n            y0: viewBox.x0,\n            y1: viewBox.x1,\n            width: viewBox.height,\n            height: viewBox.width\n        } : this._viewBox = viewBox;\n        const result = this.computeNodeLinks(data), nodes = result.nodes;\n        let links = result.links;\n        if (this._nodeMap = result.nodeMap, this.computeNodeValues(nodes), this.computeNodeDepths(nodes), \n        [ \"right\", \"end\", \"justify\" ].includes(this.options.nodeAlign) && this.computeNodeEndDepths(nodes), \n        this._maxDepth <= 0) return null;\n        const columns = this.computeNodeBreadths(nodes);\n        if (this.computeLinkBreadths(nodes), nodes.forEach((node => {\n            node.sourceLinks = node.sourceLinks.filter((link => !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.source) && !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.target))), \n            node.targetLinks = node.targetLinks.filter((link => !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.source) && !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.target)));\n        })), links = links.filter((link => !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.source) && !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.target))), \n        (0,_visactor_vgrammar_util__WEBPACK_IMPORTED_MODULE_6__.isVertical)(this.options.direction)) if (this.options.inverse) {\n            const viewY1 = this._viewBox.x1;\n            nodes.forEach((node => {\n                const {y0: y0, y1: y1, x0: x0, x1: x1} = node;\n                node.y0 = viewY1 - x1, node.y1 = viewY1 - x0, node.x0 = y0, node.x1 = y1;\n            })), links.forEach((link => {\n                link.vertical = !0;\n                const {x0: x0, x1: x1, y0: y0, y1: y1} = link;\n                link.x0 = y0, link.x1 = y1, link.y0 = viewY1 - x0, link.y1 = viewY1 - x1;\n            }));\n        } else nodes.forEach((node => {\n            const {y0: y0, y1: y1} = node;\n            node.y0 = node.x0, node.y1 = node.x1, node.x0 = y0, node.x1 = y1;\n        })), links.forEach((link => {\n            link.vertical = !0;\n            const x0 = link.x0, x1 = link.x1;\n            link.x0 = link.y0, link.x1 = link.y1, link.y0 = x0, link.y1 = x1;\n        })); else this.options.inverse && (nodes.forEach((node => {\n            const {x0: x0, x1: x1} = node;\n            node.x0 = viewBox.x1 - x1, node.x1 = viewBox.x1 - x0;\n        })), links.forEach((link => {\n            link.x0 = viewBox.x1 - link.x0, link.x1 = viewBox.x1 - link.x1;\n        })));\n        return links.forEach((link => {\n            const sourceNode = this._nodeMap[link.source], targetNode = this._nodeMap[link.target];\n            link.sourceRect = {\n                x0: sourceNode.x0,\n                x1: sourceNode.x1,\n                y0: sourceNode.y0,\n                y1: sourceNode.y1\n            }, link.targetRect = {\n                x0: targetNode.x0,\n                x1: targetNode.x1,\n                y1: targetNode.y1,\n                y0: targetNode.y0\n            };\n        })), {\n            nodes: nodes,\n            links: links,\n            columns: columns\n        };\n    }\n    computeHierarchicNodeLinks(originalNodes) {\n        const nodes = [], links = [], nodeMap = {}, linkMap = {}, originalLinks = [];\n        (0,_hierarchy__WEBPACK_IMPORTED_MODULE_7__.calculateNodeValue)(originalNodes);\n        const doSubTree = (subTree, depth, parents) => {\n            subTree.forEach(((node, index) => {\n                const nodeKey = this._getNodeKey ? this._getNodeKey(node) : parents ? `${parents[parents.length - 1].key}-${index}` : `${depth}-${index}`, nodeValue = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node.value) ? 0 : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_8__.toValidNumber)(node.value);\n                if (nodeMap[nodeKey]) nodeMap[nodeKey].value = void 0; else {\n                    const nodeElement = {\n                        depth: depth,\n                        datum: node,\n                        index: index,\n                        key: nodeKey,\n                        value: nodeValue,\n                        sourceLinks: [],\n                        targetLinks: []\n                    };\n                    nodeMap[nodeKey] = nodeElement, nodes.push(nodeElement);\n                }\n                parents && originalLinks.push({\n                    source: parents[parents.length - 1].key,\n                    target: nodeKey,\n                    value: nodeValue,\n                    parents: parents\n                }), node.children && node.children.length && doSubTree(node.children, depth + 1, parents ? parents.concat([ nodeMap[nodeKey] ]) : [ nodeMap[nodeKey] ]);\n            }));\n        };\n        return doSubTree(originalNodes, 0, null), originalLinks.forEach(((link, index) => {\n            const key = `${link.source}-${link.target}`, linkDatum = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(link, [ \"parents\" ]);\n            if (linkDatum.parents = link.parents.map((node => (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(node, [ \"sourceLinks\", \"targetLinks\" ]))), \n            linkMap[key]) return linkMap[key].value += (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_8__.toValidNumber)(link.value), void linkMap[key].datum.push(linkDatum);\n            const linkElement = {\n                index: index,\n                key: `${link.source}-${link.target}`,\n                source: link.source,\n                target: link.target,\n                datum: [ linkDatum ],\n                value: link.value,\n                parents: link.parents.map((parent => parent.key))\n            };\n            links.push(linkElement), nodeMap[link.source].sourceLinks.push(linkElement), nodeMap[link.target].targetLinks.push(linkElement), \n            linkMap[key] = linkElement;\n        })), {\n            nodes: nodes,\n            links: links,\n            nodeMap: nodeMap\n        };\n    }\n    computeSourceTargetNodeLinks(data) {\n        const nodes = [], links = [], nodeMap = {};\n        data.nodes && data.nodes.forEach(((node, index) => {\n            const nodeElement = {\n                depth: -1,\n                datum: node,\n                index: index,\n                key: this._getNodeKey ? this._getNodeKey(node) : index,\n                value: node.value,\n                sourceLinks: [],\n                targetLinks: []\n            };\n            nodeMap[nodeElement.key] = nodeElement, nodes.push(nodeElement);\n        }));\n        const invalidLinks = [];\n        return data.links.forEach(((link, index) => {\n            const hasSource = !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.source), hasTarget = !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.target);\n            if (data.nodes && (!nodeMap[link.source] || !nodeMap[link.target])) return;\n            data.nodes || !hasSource || nodeMap[link.source] || (nodeMap[link.source] = {\n                value: void 0,\n                depth: -1,\n                index: nodes.length,\n                key: link.source,\n                datum: null,\n                sourceLinks: [],\n                targetLinks: []\n            }, nodes.push(nodeMap[link.source])), data.nodes || !hasTarget || nodeMap[link.target] || (nodeMap[link.target] = {\n                value: void 0,\n                depth: -1,\n                index: nodes.length,\n                key: link.target,\n                datum: null,\n                sourceLinks: [],\n                targetLinks: []\n            }, nodes.push(nodeMap[link.target]));\n            const linkElement = {\n                index: index,\n                source: link.source,\n                target: link.target,\n                datum: link,\n                value: link.value\n            };\n            this.options.divideNodeValueToLink && (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(link.value) && invalidLinks.push(linkElement), \n            links.push(linkElement), hasSource && nodeMap[link.source].sourceLinks.push(linkElement), \n            hasTarget && nodeMap[link.target].targetLinks.push(linkElement);\n        })), this.options.divideNodeValueToLink && invalidLinks.length && invalidLinks.forEach((link => {\n            const values = [ calcDivideValue(nodeMap[link.source]), calcDivideValue(nodeMap[link.target], !0) ].filter((entry => !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(entry)));\n            values.length && (link.value = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_0__.minInArray)(values));\n        })), {\n            nodeMap: nodeMap,\n            nodes: nodes,\n            links: links\n        };\n    }\n    computeNodeLinks(data) {\n        let res;\n        \"links\" in data ? res = this.computeSourceTargetNodeLinks(data) : (this._isHierarchic = !0, \n        res = this.computeHierarchicNodeLinks(data.nodes));\n        let nodes = res.nodes;\n        const links = res.links;\n        if (this.options.linkSortBy) for (let i = 0, len = nodes.length; i < len; i++) nodes[i].sourceLinks.sort(this.options.linkSortBy), \n        nodes[i].targetLinks.sort(this.options.linkSortBy);\n        return this.options.dropIsolatedNode && (nodes = nodes.filter((node => node.targetLinks.length || node.sourceLinks.length))), \n        {\n            nodes: nodes,\n            links: links,\n            nodeMap: res.nodeMap\n        };\n    }\n    computeNodeValues(nodes) {\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            node.value = Math.max((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node.value) ? 0 : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_8__.toValidNumber)(node.value), node.sourceLinks.reduce(((sum, link) => {\n                var _a;\n                return sum + (null !== (_a = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_8__.toValidNumber)(link.value)) && void 0 !== _a ? _a : 0);\n            }), 0), node.targetLinks.reduce(((sum, link) => {\n                var _a;\n                return sum + (null !== (_a = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_8__.toValidNumber)(link.value)) && void 0 !== _a ? _a : 0);\n            }), 0));\n        }\n    }\n    computeNodeDepths(nodes) {\n        var _a;\n        const n = nodes.length;\n        let next, nextMap, current = nodes, depth = 0, maxDepth = -1;\n        const setNodeLayer = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.setNodeLayer) ? this.options.setNodeLayer : null;\n        for (;current.length && depth < n; ) {\n            next = [], nextMap = {};\n            for (let i = 0, curLen = current.length; i < curLen; i++) {\n                const node = current[i];\n                if (node && (node.depth = setNodeLayer && null !== (_a = setNodeLayer(node.datum)) && void 0 !== _a ? _a : depth, \n                setNodeLayer && (maxDepth = Math.max(node.depth, maxDepth)), node.sourceLinks && node.sourceLinks.length)) for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {\n                    const link = node.sourceLinks[j];\n                    nextMap[link.target] || (next.push(this._nodeMap[link.target]), nextMap[link.target] = !0);\n                }\n            }\n            current = next, depth += 1;\n        }\n        depth > n && this._logger.warn(\"Error: there is a circular link\"), this._maxDepth = setNodeLayer ? maxDepth + 1 : depth;\n    }\n    computeNodeEndDepths(nodes) {\n        const n = nodes.length;\n        let next, nextMap, current = nodes, depth = 0;\n        for (;current.length && depth < n; ) {\n            next = [], nextMap = {};\n            for (let i = 0, curLen = current.length; i < curLen; i++) {\n                const node = current[i];\n                if (node) {\n                    node.endDepth = depth;\n                    for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {\n                        const link = node.targetLinks[j];\n                        nextMap[link.source] || (next.push(this._nodeMap[link.source]), nextMap[link.source] = !0);\n                    }\n                }\n            }\n            current = next, depth += 1;\n        }\n        depth > n && this._logger.warn(\"Error: there is a circular link\");\n    }\n    computeNodeLayers(nodes) {\n        const nodeWidthOption = this.options.nodeWidth, linkWidthOption = this.options.linkWidth, minStepWidth = this.options.minStepWidth, width = this._viewBox.width;\n        let nodeWidth = null, linkWidth = null, isEvenWidth = !1;\n        if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(nodeWidthOption)) {\n            const ratio = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(parseFloat(nodeWidthOption.replace(\"%\", \"\")) / 100, 0, 1);\n            let stepWidth = width / (this._maxDepth - 1 + ratio);\n            minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), nodeWidth = stepWidth * ratio, \n            linkWidth = stepWidth * (1 - ratio), isEvenWidth = !0;\n        } else if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(nodeWidthOption)) {\n            if (nodeWidth = nodeWidthOption, (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(linkWidthOption)) linkWidth = linkWidthOption; else if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(linkWidthOption)) {\n                let stepWidth = (width - nodeWidthOption) / (this._maxDepth - 1);\n                minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), linkWidth = stepWidth - nodeWidthOption;\n            }\n            isEvenWidth = !0;\n        } else (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(nodeWidthOption) && (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(linkWidthOption) && (linkWidth = linkWidthOption);\n        const columns = [];\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            node.layer = this._isHierarchic ? node.depth : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(Math.floor(this._alignFunc(node, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);\n            const layer = node.layer;\n            layer === this._maxDepth - 1 && (node.isLastLayer = !0), isEvenWidth && (node.x0 = this._viewBox.x0 + layer * (nodeWidth + linkWidth), \n            node.x1 = node.x0 + nodeWidth), columns[layer] ? columns[layer].push(node) : columns[layer] = [ node ];\n        }\n        if (this.options.nodeSortBy) for (let j = 0, colLen = columns.length; j < colLen; j++) columns[j].sort(this.options.nodeSortBy);\n        if (!isEvenWidth && (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(nodeWidthOption)) {\n            let curLayerX = this._viewBox.x0;\n            for (let i = 0; i < this._maxDepth; i++) {\n                const column = columns[i];\n                let maxNodeWidth = 0, maxLinkWidth = 0;\n                for (let j = 0, colLen = column && column.length; j < colLen; j++) {\n                    const node = column[j], curNodeWidth = nodeWidthOption(node);\n                    node.x0 = curLayerX, node.x1 = curLayerX + curNodeWidth, maxNodeWidth = Math.max(nodeWidth, curNodeWidth);\n                    const sourceLinks = node.sourceLinks;\n                    for (let k = 0, linkLen = sourceLinks.length; k < linkLen; k++) {\n                        const link = sourceLinks[k], curLinkWidth = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(linkWidthOption) ? linkWidthOption(link, this._viewBox) : linkWidth;\n                        maxLinkWidth = Math.max(maxLinkWidth, curLinkWidth);\n                    }\n                }\n                curLayerX += maxNodeWidth + maxLinkWidth;\n            }\n        }\n        return columns;\n    }\n    initializeNodeBreadths(columns) {\n        var _a, _b, _c;\n        const minLinkHeight = null !== (_a = this.options.minLinkHeight) && void 0 !== _a ? _a : 0;\n        let minNodeHeight = null !== (_b = this.options.minNodeHeight) && void 0 !== _b ? _b : 0;\n        const maxNodeHeight = null !== (_c = this.options.maxNodeHeight) && void 0 !== _c ? _c : 1 / 0;\n        let maxLinkHeight = this.options.maxLinkHeight;\n        ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(minNodeHeight) || minNodeHeight < minLinkHeight) && (minNodeHeight = minLinkHeight), \n        ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(maxLinkHeight) || maxLinkHeight > maxNodeHeight) && (maxLinkHeight = maxNodeHeight);\n        let ky = 0, getGapY = null, forceNodeHeight = null;\n        if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.nodeGap)) getGapY = this.options.nodeGap, ky = columns.reduce(((val, column) => {\n            const sumValue = column.reduce(((sum, node) => sum + node.value), 0), sumGapY = column.reduce(((sum, node) => sum + this.options.nodeGap(node)), 0);\n            return Math.min(val, (this._viewBox.height - sumGapY) / sumValue);\n        }), 1 / 0); else {\n            const maxRowCount = columns.reduce(((cnt, column) => Math.max(cnt, column.length)), 0), maxStepHeight = this._viewBox.height / maxRowCount;\n            let gapY = Math.min(this.options.nodeGap, maxStepHeight);\n            if (minNodeHeight + gapY > maxStepHeight && (gapY = minNodeHeight >= maxStepHeight ? maxStepHeight / 2 : (maxStepHeight - minNodeHeight) / 2, \n            minNodeHeight = Math.min(maxStepHeight - gapY, minNodeHeight)), getGapY = () => gapY, \n            this._gapY = gapY, this.options.equalNodeHeight) forceNodeHeight = this._viewBox.height / maxRowCount - gapY; else {\n                const calGapY = minNodeHeight > 0 ? Math.max(gapY, minNodeHeight) : gapY;\n                ky = columns.reduce(((val, column) => {\n                    const sumValue = column.reduce(((sum, node) => sum + node.value), 0);\n                    return Math.min(val, (this._viewBox.height - ((column.length - 1) * calGapY + minNodeHeight)) / sumValue);\n                }), 1 / 0);\n            }\n        }\n        const isStartGap = \"start\" === this.options.gapPosition, isMiddleGap = !isStartGap && \"end\" !== this.options.gapPosition, getNodeHeight = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(this.options.nodeHeight) ? node => this.options.nodeHeight : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.nodeHeight) ? this.options.nodeHeight : forceNodeHeight > 0 ? node => forceNodeHeight : node => Math.max(node.value * ky, 0), getLinkHeight = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(this.options.linkHeight) ? () => this.options.linkHeight : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.linkHeight) ? this.options.linkHeight : (link, sourceNode, sourceNodeHeight) => Math.min(Math.max(sourceNode.value ? sourceNodeHeight * linkClampe(link.value / sourceNode.value) : 0, minLinkHeight, 0), maxLinkHeight);\n        for (let i = 0, columnCount = columns.length; i < columnCount; i++) {\n            const nodes = columns[i];\n            if (!nodes || !nodes.length) continue;\n            let y = this._viewBox.y0, gapY = 0, nodeHeight = 0, calculatedNodeHeight = 0;\n            for (let j = 0, len = nodes.length; j < len; j++) {\n                const node = nodes[j];\n                gapY = getGapY(node), isStartGap && (y += gapY), calculatedNodeHeight = getNodeHeight(node), \n                nodeHeight = Math.min(Math.max(calculatedNodeHeight, minNodeHeight), maxNodeHeight), \n                node.y0 = y, node.y1 = y + nodeHeight, y = isStartGap ? node.y1 : node.y1 + gapY;\n                for (let k = 0, linkLen = node.sourceLinks.length; k < linkLen; k++) {\n                    const link = node.sourceLinks[k];\n                    link.thickness = getLinkHeight(link, node, calculatedNodeHeight);\n                }\n            }\n            let deltaY = this._viewBox.y1 - y + (isMiddleGap ? gapY : 0);\n            if (deltaY > 0) if (\"start\" === this.options.crossNodeAlign) ; else if (\"end\" === this.options.crossNodeAlign) for (let j = 0, len = nodes.length; j < len; ++j) {\n                const node = nodes[j];\n                node.y0 += deltaY, node.y1 += deltaY;\n            } else if (\"parent\" === this.options.crossNodeAlign) {\n                const sourceNodes = nodes.reduce(((res, node) => (node.targetLinks && node.targetLinks.length && node.targetLinks.forEach((link => {\n                    res[link.source] = !0;\n                })), res)), {});\n                if (Object.keys(sourceNodes).length && columns[i - 1] && columns[i - 1].length) {\n                    const prevSourceNodes = columns[i - 1].filter((node => sourceNodes[node.key]));\n                    if (prevSourceNodes && prevSourceNodes.length && prevSourceNodes[0].y0 !== nodes[0].y0) {\n                        const newDeltaY = prevSourceNodes[0].y0 - nodes[0].y0;\n                        for (let j = 0, len = nodes.length; j < len; ++j) {\n                            const node = nodes[j];\n                            node.y0 += newDeltaY, node.y1 += newDeltaY;\n                        }\n                    }\n                }\n            } else {\n                deltaY /= nodes.length + 1;\n                for (let j = 0, len = nodes.length; j < len; ++j) {\n                    const node = nodes[j];\n                    node.y0 += deltaY * (j + 1), node.y1 += deltaY * (j + 1);\n                }\n            } else if (deltaY < 0 && nodes.length > 1 && (deltaY /= nodes.length - 1, gapY + deltaY >= 0)) {\n                gapY += deltaY, this._gapY = Math.min(gapY);\n                for (let j = 1, len = nodes.length; j < len; ++j) {\n                    const node = nodes[j];\n                    node.y0 += deltaY * j, node.y1 += deltaY * j;\n                }\n            }\n            this.reorderLinks(nodes);\n        }\n    }\n    computeNodeBreadths(nodes) {\n        const columns = this.computeNodeLayers(nodes);\n        this.initializeNodeBreadths(columns);\n        const iterations = this.options.iterations;\n        if (!this._isHierarchic && !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.setNodeLayer) && !(0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.options.nodeGap)) for (let i = 0; i < iterations; ++i) {\n            const alpha = Math.pow(.99, i), beta = Math.max(1 - alpha, (i + 1) / iterations);\n            this.relaxRightToLeft(columns, alpha, beta), this.relaxLeftToRight(columns, alpha, beta);\n        }\n        return columns;\n    }\n    relaxLeftToRight(columns, alpha, beta) {\n        for (let i = 1, n = columns.length; i < n; ++i) {\n            const column = columns[i];\n            for (let j = 0, colLen = column.length; j < colLen; j++) {\n                const target = column[j];\n                let y = 0, w = 0;\n                for (let k = 0, linkLen = target.targetLinks.length; k < linkLen; k++) {\n                    const link = target.targetLinks[k], v = link.value * (target.layer - this._nodeMap[link.source].layer);\n                    y += this.targetTop(this._nodeMap[link.source], target) * v, w += v;\n                }\n                if (!(w > 0)) continue;\n                const dy = (y / w - target.y0) * alpha;\n                target.y0 += dy, target.y1 += dy, this.reorderNodeLinks(target);\n            }\n            (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.options.nodeSortBy) && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);\n        }\n    }\n    relaxRightToLeft(columns, alpha, beta) {\n        for (let i = columns.length - 2; i >= 0; --i) {\n            const column = columns[i];\n            for (let j = 0, colLen = column.length; j < colLen; j++) {\n                const source = column[j];\n                let y = 0, w = 0;\n                for (let k = 0, linkLen = source.sourceLinks.length; k < linkLen; k++) {\n                    const link = source.sourceLinks[k], v = link.value * (this._nodeMap[link.target].layer - source.layer);\n                    y += this.sourceTop(source, this._nodeMap[link.target]) * v, w += v;\n                }\n                if (!(w > 0)) continue;\n                const dy = (y / w - source.y0) * alpha;\n                source.y0 += dy, source.y1 += dy, this.reorderNodeLinks(source);\n            }\n            void 0 === this.options.nodeSortBy && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);\n        }\n    }\n    resolveCollisions(nodes, alpha) {\n        const i = nodes.length >> 1, subject = nodes[i];\n        this.resolveCollisionsBottomToTop(nodes, subject.y0 - this._gapY, i - 1, alpha), \n        this.resolveCollisionsTopToBottom(nodes, subject.y1 + this._gapY, i + 1, alpha), \n        this.resolveCollisionsBottomToTop(nodes, this._viewBox.y1, nodes.length - 1, alpha), \n        this.resolveCollisionsTopToBottom(nodes, this._viewBox.y0, 0, alpha);\n    }\n    resolveCollisionsTopToBottom(nodes, y, i, alpha) {\n        for (;i < nodes.length; ++i) {\n            const node = nodes[i], dy = (y - node.y0) * alpha;\n            dy > 1e-6 && (node.y0 += dy, node.y1 += dy), y = node.y1 + this._gapY;\n        }\n    }\n    resolveCollisionsBottomToTop(nodes, y, i, alpha) {\n        for (;i >= 0; --i) {\n            const node = nodes[i], dy = (node.y1 - y) * alpha;\n            dy > 1e-6 && (node.y0 -= dy, node.y1 -= dy), y = node.y0 - this._gapY;\n        }\n    }\n    targetTop(source, target) {\n        let i, len, link, y = source.y0 - (source.sourceLinks.length - 1) * this._gapY / 2;\n        for (i = 0, len = source.sourceLinks.length; i < len && (link = source.sourceLinks[i], \n        link.target !== target.key); i++) y += link.thickness + this._gapY;\n        for (i = 0, len = target.targetLinks.length; i < len && (link = target.targetLinks[i], \n        link.source !== source.key); i++) y -= link.thickness;\n        return y;\n    }\n    sourceTop(source, target) {\n        let i, len, link, y = target.y0 - (target.targetLinks.length - 1) * this._gapY / 2;\n        for (i = 0, len = target.targetLinks.length; i < len && (link = target.targetLinks[i], \n        link.source !== source.key); i++) y += link.thickness + this._gapY;\n        for (i = 0, len = source.sourceLinks.length; i < len && (link = source.sourceLinks[i], \n        link.target !== target.key); i++) y -= link.thickness;\n        return y;\n    }\n    computeLinkBreadthsNoOverlap(nodes) {\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            let y0 = node.y0, reachBottom = !1;\n            for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {\n                const link = node.sourceLinks[j];\n                reachBottom || (link.y0 = y0 + link.thickness / 2), link.x0 = node.x1, y0 + link.thickness > node.y1 || reachBottom ? (link.y0 = node.y1 - link.thickness / 2, \n                reachBottom = !0) : y0 += link.thickness;\n            }\n            let y1 = node.y0;\n            reachBottom = !1;\n            for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {\n                const link = node.targetLinks[j];\n                reachBottom || (link.y1 = y1 + link.thickness / 2), link.x1 = node.x0, y1 + link.thickness > node.y1 || reachBottom ? (link.y1 = node.y1 - link.thickness / 2, \n                reachBottom = !0) : y1 += link.thickness;\n            }\n        }\n    }\n    computeLinkBreadthsOverlap(nodes) {\n        const linkOverlap = this.options.linkOverlap;\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i], pos = \"start\" === linkOverlap ? node.y0 : \"end\" === linkOverlap ? node.y1 : (node.y0 + node.y1) / 2, sign = \"start\" === linkOverlap ? .5 : \"end\" === linkOverlap ? -.5 : 0;\n            for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {\n                const link = node.sourceLinks[j];\n                link.y0 = pos + sign * link.thickness, link.x0 = node.x1;\n            }\n            for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {\n                const link = node.targetLinks[j];\n                link.y1 = pos + sign * link.thickness, link.x1 = node.x0;\n            }\n        }\n    }\n    computeLinkBreadths(nodes) {\n        this.options.linkOverlap ? this.computeLinkBreadthsOverlap(nodes) : this.computeLinkBreadthsNoOverlap(nodes);\n    }\n    reorderNodeLinks(node) {\n        if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.options.linkSortBy)) {\n            const targetLinks = node.targetLinks, sourceLinks = node.sourceLinks;\n            for (let j = 0, linkLen = targetLinks.length; j < linkLen; j++) {\n                const link = targetLinks[j];\n                this._nodeMap[link.source].sourceLinks.sort(this._ascendingTargetBreadth);\n            }\n            for (let j = 0, linkLen = sourceLinks.length; j < linkLen; j++) {\n                const link = sourceLinks[j];\n                this._nodeMap[link.target].targetLinks.sort(this._ascendingSourceBreadth);\n            }\n        }\n    }\n    reorderLinks(nodes) {\n        if ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.options.linkSortBy)) for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            node.sourceLinks.sort(this._ascendingTargetBreadth), node.targetLinks.sort(this._ascendingSourceBreadth);\n        }\n    }\n}\n\nSankeyLayout.defaultOptions = {\n    iterations: 6,\n    nodeAlign: \"justify\",\n    direction: \"horizontal\",\n    nodeWidth: 24,\n    nodeGap: 8,\n    crossNodeAlign: \"middle\",\n    dropIsolatedNode: !0\n};\n//# sourceMappingURL=layout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXNhbmtleUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItc2Fua2V5L2VzL2xheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDs7QUFFd0Y7O0FBRTdFOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSw0REFBVTtBQUN0Rjs7QUFFQTtBQUNBLFFBQVEsNERBQUs7QUFDYiwwRkFBMEYsNERBQUs7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZSx5REFBTzs7QUFFaEI7QUFDUDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsMERBQTBELDREQUFVLHNDQUFzQyw4REFBSztBQUMvRyxtREFBbUQsb0RBQU0sa0NBQWtDLDREQUFVO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNERBQUssa0JBQWtCLDREQUFLO0FBQzdGLGlFQUFpRSw0REFBSyxrQkFBa0IsNERBQUs7QUFDN0YsU0FBUyxtQ0FBbUMsNERBQUssa0JBQWtCLDREQUFLO0FBQ3hFLFFBQVEsbUVBQVU7QUFDbEI7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVixtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxRQUFRLDhEQUFrQjtBQUMxQjtBQUNBO0FBQ0EseUZBQXlGLGdDQUFnQyxHQUFHLE1BQU0sT0FBTyxNQUFNLEdBQUcsTUFBTSxlQUFlLDREQUFLLG1CQUFtQiwrREFBYTtBQUM1TSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWSxHQUFHLFlBQVksZUFBZSw0REFBVztBQUNoRiw4REFBOEQsNERBQVc7QUFDekUsdURBQXVELCtEQUFhO0FBQ3BFO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWSxHQUFHLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQiw0REFBSyw0QkFBNEIsNERBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDREQUFLO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0lBQWtJLDREQUFLO0FBQ3ZJLDJDQUEyQyw0REFBVTtBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxTQUFTO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0Esa0NBQWtDLDREQUFLLG1CQUFtQiwrREFBYTtBQUN2RTtBQUNBLDZDQUE2QywrREFBYTtBQUMxRCxhQUFhO0FBQ2I7QUFDQSw2Q0FBNkMsK0RBQWE7QUFDMUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0REFBVTtBQUN2QyxjQUFjLDZCQUE2QjtBQUMzQztBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQSw4S0FBOEssYUFBYTtBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUFRO0FBQ3BCLDBCQUEwQiw2REFBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsNkRBQVE7QUFDM0IsNkNBQTZDLDZEQUFRLGdEQUFnRCxTQUFTLDREQUFLO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLLDREQUFVLHFCQUFxQiw2REFBUTtBQUN0RDtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0EsMkRBQTJELDZEQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFlBQVk7QUFDMUYsNEJBQTRCLDREQUFVO0FBQ3RDO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGFBQWE7QUFDL0Usb0VBQW9FLDREQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFLO0FBQ2QsU0FBUyw0REFBSztBQUNkO0FBQ0EsWUFBWSw0REFBVTtBQUN0QjtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrSkFBa0osNkRBQVEsOERBQThELDREQUFVLDRKQUE0Siw2REFBUSw0REFBNEQsNERBQVU7QUFDNWMsc0RBQXNELGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsb0ZBQW9GLFNBQVM7QUFDeEs7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0REFBVSxnQ0FBZ0MsNERBQVUsd0NBQXdDLGdCQUFnQjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQSxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscUNBQXFDO0FBQ3JDLHFEQUFxRDtBQUNyRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscUNBQXFDO0FBQ3JDLHFEQUFxRDtBQUNyRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQUs7QUFDakI7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFLLCtEQUErRCxTQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci1zYW5rZXlAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXNhbmtleS9lcy9sYXlvdXQuanM/M2FmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxjdWxhdGVOb2RlVmFsdWUgfSBmcm9tIFwiLi9oaWVyYXJjaHlcIjtcblxuaW1wb3J0IHsgaXNOaWwsIGNsYW1wLCBtaW5JbkFycmF5LCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNTdHJpbmcsIExvZ2dlciwgY2xhbXBlciwgdG9WYWxpZE51bWJlciwgcGlja1dpdGhvdXQgfSBmcm9tIFwiQHZpc2FjdG9yL3Z1dGlsc1wiO1xuXG5pbXBvcnQgeyBmaWVsZCwgaXNWZXJ0aWNhbCB9IGZyb20gXCJAdmlzYWN0b3IvdmdyYW1tYXItdXRpbFwiO1xuXG5mdW5jdGlvbiBsZWZ0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5kZXB0aDtcbn1cblxuZnVuY3Rpb24gcmlnaHQobm9kZSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gbWF4RGVwdGggLSAxIC0gbm9kZS5lbmREZXB0aDtcbn1cblxuZnVuY3Rpb24ganVzdGlmeShub2RlLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA/IG5vZGUuZGVwdGggOiBtYXhEZXB0aCAtIDE7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihub2RlLCBtYXhEZXB0aCwgbm9kZU1hcCkge1xuICAgIHJldHVybiBub2RlLnRhcmdldExpbmtzLmxlbmd0aCA/IG5vZGUuZGVwdGggOiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA/IG1pbkluQXJyYXkobm9kZS5zb3VyY2VMaW5rcy5tYXAoKGxpbmsgPT4gbm9kZU1hcFtsaW5rLnRhcmdldF0uZGVwdGgpKSkgLSAxIDogMDtcbn1cblxuY29uc3QgYXNjZW5kaW5nTm9kZUJyZWFkdGggPSAoYSwgYikgPT4gKG51bGwgPT0gYSA/IHZvaWQgMCA6IGEueTApIC0gKG51bGwgPT0gYiA/IHZvaWQgMCA6IGIueTApLCBjYWxjRGl2aWRlVmFsdWUgPSAobm9kZSwgaXNUYXJnZXQpID0+IHtcbiAgICBpZiAoaXNOaWwobm9kZS52YWx1ZSkpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJlcyA9IChpc1RhcmdldCA/IG5vZGUudGFyZ2V0TGlua3MgOiBub2RlLnNvdXJjZUxpbmtzKS5yZWR1Y2UoKChyZXMsIHNMaW5rKSA9PiAoaXNOaWwoc0xpbmsudmFsdWUpID8gcmVzLmNvdW50ICs9IDEgOiByZXMuc3VtICs9IHNMaW5rLnZhbHVlLCBcbiAgICByZXMpKSwge1xuICAgICAgICBzdW06IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcy5jb3VudCA+IDAgPyAobm9kZS52YWx1ZSAtIHJlcy5zdW0pIC8gcmVzLmNvdW50IDogbnVsbDtcbn0sIGFsaWduRnVuY3Rpb25zID0ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGp1c3RpZnk6IGp1c3RpZnksXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgc3RhcnQ6IGxlZnQsXG4gICAgZW5kOiByaWdodFxufSwgbGlua0NsYW1wZSA9IGNsYW1wZXIoMCwgMSk7XG5cbmV4cG9ydCBjbGFzcyBTYW5rZXlMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYXNjZW5kaW5nU291cmNlQnJlYWR0aCA9IChhLCBiKSA9PiBhc2NlbmRpbmdOb2RlQnJlYWR0aCh0aGlzLl9ub2RlTWFwW2Euc291cmNlXSwgdGhpcy5fbm9kZU1hcFtiLnNvdXJjZV0pIHx8IGEuaW5kZXggLSBiLmluZGV4LCBcbiAgICAgICAgdGhpcy5fYXNjZW5kaW5nVGFyZ2V0QnJlYWR0aCA9IChhLCBiKSA9PiBhc2NlbmRpbmdOb2RlQnJlYWR0aCh0aGlzLl9ub2RlTWFwW2EudGFyZ2V0XSwgdGhpcy5fbm9kZU1hcFtiLnRhcmdldF0pIHx8IGEuaW5kZXggLSBiLmluZGV4LCBcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgU2Fua2V5TGF5b3V0LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qga2V5T3B0aW9uID0gdGhpcy5vcHRpb25zLm5vZGVLZXksIGtleUZ1bmMgPSBpc0Z1bmN0aW9uKGtleU9wdGlvbikgPyBrZXlPcHRpb24gOiBrZXlPcHRpb24gPyBmaWVsZChrZXlPcHRpb24pIDogbnVsbDtcbiAgICAgICAgdGhpcy5fZ2V0Tm9kZUtleSA9IGtleUZ1bmMsIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpLCB0aGlzLl9hbGlnbkZ1bmMgPSBpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5zZXROb2RlTGF5ZXIpID8gbm9kZSA9PiB0aGlzLm9wdGlvbnMuc2V0Tm9kZUxheWVyKG5vZGUuZGF0dW0pIDogYWxpZ25GdW5jdGlvbnNbdGhpcy5vcHRpb25zLm5vZGVBbGlnbl07XG4gICAgfVxuICAgIGxheW91dChkYXRhLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3Qgdmlld0JveCA9IFwid2lkdGhcIiBpbiBjb25maWcgPyB7XG4gICAgICAgICAgICB4MDogMCxcbiAgICAgICAgICAgIHgxOiBjb25maWcud2lkdGgsXG4gICAgICAgICAgICB5MDogMCxcbiAgICAgICAgICAgIHkxOiBjb25maWcuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodFxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgeDA6IE1hdGgubWluKGNvbmZpZy54MCwgY29uZmlnLngxKSxcbiAgICAgICAgICAgIHgxOiBNYXRoLm1heChjb25maWcueDAsIGNvbmZpZy54MSksXG4gICAgICAgICAgICB5MDogTWF0aC5taW4oY29uZmlnLnkwLCBjb25maWcueTEpLFxuICAgICAgICAgICAgeTE6IE1hdGgubWF4KGNvbmZpZy55MCwgY29uZmlnLnkxKSxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLmFicyhjb25maWcueDEgLSBjb25maWcueDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhjb25maWcueTEgLSBjb25maWcueTApXG4gICAgICAgIH07XG4gICAgICAgIGlzVmVydGljYWwodGhpcy5vcHRpb25zLmRpcmVjdGlvbikgPyB0aGlzLl92aWV3Qm94ID0ge1xuICAgICAgICAgICAgeDA6IHZpZXdCb3gueTAsXG4gICAgICAgICAgICB4MTogdmlld0JveC55MSxcbiAgICAgICAgICAgIHkwOiB2aWV3Qm94LngwLFxuICAgICAgICAgICAgeTE6IHZpZXdCb3gueDEsXG4gICAgICAgICAgICB3aWR0aDogdmlld0JveC5oZWlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IHZpZXdCb3gud2lkdGhcbiAgICAgICAgfSA6IHRoaXMuX3ZpZXdCb3ggPSB2aWV3Qm94O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbXB1dGVOb2RlTGlua3MoZGF0YSksIG5vZGVzID0gcmVzdWx0Lm5vZGVzO1xuICAgICAgICBsZXQgbGlua3MgPSByZXN1bHQubGlua3M7XG4gICAgICAgIGlmICh0aGlzLl9ub2RlTWFwID0gcmVzdWx0Lm5vZGVNYXAsIHRoaXMuY29tcHV0ZU5vZGVWYWx1ZXMobm9kZXMpLCB0aGlzLmNvbXB1dGVOb2RlRGVwdGhzKG5vZGVzKSwgXG4gICAgICAgIFsgXCJyaWdodFwiLCBcImVuZFwiLCBcImp1c3RpZnlcIiBdLmluY2x1ZGVzKHRoaXMub3B0aW9ucy5ub2RlQWxpZ24pICYmIHRoaXMuY29tcHV0ZU5vZGVFbmREZXB0aHMobm9kZXMpLCBcbiAgICAgICAgdGhpcy5fbWF4RGVwdGggPD0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmNvbXB1dGVOb2RlQnJlYWR0aHMobm9kZXMpO1xuICAgICAgICBpZiAodGhpcy5jb21wdXRlTGlua0JyZWFkdGhzKG5vZGVzKSwgbm9kZXMuZm9yRWFjaCgobm9kZSA9PiB7XG4gICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzID0gbm9kZS5zb3VyY2VMaW5rcy5maWx0ZXIoKGxpbmsgPT4gIWlzTmlsKGxpbmsuc291cmNlKSAmJiAhaXNOaWwobGluay50YXJnZXQpKSksIFxuICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcyA9IG5vZGUudGFyZ2V0TGlua3MuZmlsdGVyKChsaW5rID0+ICFpc05pbChsaW5rLnNvdXJjZSkgJiYgIWlzTmlsKGxpbmsudGFyZ2V0KSkpO1xuICAgICAgICB9KSksIGxpbmtzID0gbGlua3MuZmlsdGVyKChsaW5rID0+ICFpc05pbChsaW5rLnNvdXJjZSkgJiYgIWlzTmlsKGxpbmsudGFyZ2V0KSkpLCBcbiAgICAgICAgaXNWZXJ0aWNhbCh0aGlzLm9wdGlvbnMuZGlyZWN0aW9uKSkgaWYgKHRoaXMub3B0aW9ucy5pbnZlcnNlKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3WTEgPSB0aGlzLl92aWV3Qm94LngxO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qge3kwOiB5MCwgeTE6IHkxLCB4MDogeDAsIHgxOiB4MX0gPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUueTAgPSB2aWV3WTEgLSB4MSwgbm9kZS55MSA9IHZpZXdZMSAtIHgwLCBub2RlLngwID0geTAsIG5vZGUueDEgPSB5MTtcbiAgICAgICAgICAgIH0pKSwgbGlua3MuZm9yRWFjaCgobGluayA9PiB7XG4gICAgICAgICAgICAgICAgbGluay52ZXJ0aWNhbCA9ICEwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHt4MDogeDAsIHgxOiB4MSwgeTA6IHkwLCB5MTogeTF9ID0gbGluaztcbiAgICAgICAgICAgICAgICBsaW5rLngwID0geTAsIGxpbmsueDEgPSB5MSwgbGluay55MCA9IHZpZXdZMSAtIHgwLCBsaW5rLnkxID0gdmlld1kxIC0geDE7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBub2Rlcy5mb3JFYWNoKChub2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHt5MDogeTAsIHkxOiB5MX0gPSBub2RlO1xuICAgICAgICAgICAgbm9kZS55MCA9IG5vZGUueDAsIG5vZGUueTEgPSBub2RlLngxLCBub2RlLngwID0geTAsIG5vZGUueDEgPSB5MTtcbiAgICAgICAgfSkpLCBsaW5rcy5mb3JFYWNoKChsaW5rID0+IHtcbiAgICAgICAgICAgIGxpbmsudmVydGljYWwgPSAhMDtcbiAgICAgICAgICAgIGNvbnN0IHgwID0gbGluay54MCwgeDEgPSBsaW5rLngxO1xuICAgICAgICAgICAgbGluay54MCA9IGxpbmsueTAsIGxpbmsueDEgPSBsaW5rLnkxLCBsaW5rLnkwID0geDAsIGxpbmsueTEgPSB4MTtcbiAgICAgICAgfSkpOyBlbHNlIHRoaXMub3B0aW9ucy5pbnZlcnNlICYmIChub2Rlcy5mb3JFYWNoKChub2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHt4MDogeDAsIHgxOiB4MX0gPSBub2RlO1xuICAgICAgICAgICAgbm9kZS54MCA9IHZpZXdCb3gueDEgLSB4MSwgbm9kZS54MSA9IHZpZXdCb3gueDEgLSB4MDtcbiAgICAgICAgfSkpLCBsaW5rcy5mb3JFYWNoKChsaW5rID0+IHtcbiAgICAgICAgICAgIGxpbmsueDAgPSB2aWV3Qm94LngxIC0gbGluay54MCwgbGluay54MSA9IHZpZXdCb3gueDEgLSBsaW5rLngxO1xuICAgICAgICB9KSkpO1xuICAgICAgICByZXR1cm4gbGlua3MuZm9yRWFjaCgobGluayA9PiB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gdGhpcy5fbm9kZU1hcFtsaW5rLnNvdXJjZV0sIHRhcmdldE5vZGUgPSB0aGlzLl9ub2RlTWFwW2xpbmsudGFyZ2V0XTtcbiAgICAgICAgICAgIGxpbmsuc291cmNlUmVjdCA9IHtcbiAgICAgICAgICAgICAgICB4MDogc291cmNlTm9kZS54MCxcbiAgICAgICAgICAgICAgICB4MTogc291cmNlTm9kZS54MSxcbiAgICAgICAgICAgICAgICB5MDogc291cmNlTm9kZS55MCxcbiAgICAgICAgICAgICAgICB5MTogc291cmNlTm9kZS55MVxuICAgICAgICAgICAgfSwgbGluay50YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgICAgIHgwOiB0YXJnZXROb2RlLngwLFxuICAgICAgICAgICAgICAgIHgxOiB0YXJnZXROb2RlLngxLFxuICAgICAgICAgICAgICAgIHkxOiB0YXJnZXROb2RlLnkxLFxuICAgICAgICAgICAgICAgIHkwOiB0YXJnZXROb2RlLnkwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgICAgIGxpbmtzOiBsaW5rcyxcbiAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcHV0ZUhpZXJhcmNoaWNOb2RlTGlua3Mob3JpZ2luYWxOb2Rlcykge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdLCBsaW5rcyA9IFtdLCBub2RlTWFwID0ge30sIGxpbmtNYXAgPSB7fSwgb3JpZ2luYWxMaW5rcyA9IFtdO1xuICAgICAgICBjYWxjdWxhdGVOb2RlVmFsdWUob3JpZ2luYWxOb2Rlcyk7XG4gICAgICAgIGNvbnN0IGRvU3ViVHJlZSA9IChzdWJUcmVlLCBkZXB0aCwgcGFyZW50cykgPT4ge1xuICAgICAgICAgICAgc3ViVHJlZS5mb3JFYWNoKCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlS2V5ID0gdGhpcy5fZ2V0Tm9kZUtleSA/IHRoaXMuX2dldE5vZGVLZXkobm9kZSkgOiBwYXJlbnRzID8gYCR7cGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdLmtleX0tJHtpbmRleH1gIDogYCR7ZGVwdGh9LSR7aW5kZXh9YCwgbm9kZVZhbHVlID0gaXNOaWwobm9kZS52YWx1ZSkgPyAwIDogdG9WYWxpZE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1hcFtub2RlS2V5XSkgbm9kZU1hcFtub2RlS2V5XS52YWx1ZSA9IHZvaWQgMDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0dW06IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG5vZGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGlua3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGlua3M6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5vZGVNYXBbbm9kZUtleV0gPSBub2RlRWxlbWVudCwgbm9kZXMucHVzaChub2RlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudHMgJiYgb3JpZ2luYWxMaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV0ua2V5LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVLZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHM6IHBhcmVudHNcbiAgICAgICAgICAgICAgICB9KSwgbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiBkb1N1YlRyZWUobm9kZS5jaGlsZHJlbiwgZGVwdGggKyAxLCBwYXJlbnRzID8gcGFyZW50cy5jb25jYXQoWyBub2RlTWFwW25vZGVLZXldIF0pIDogWyBub2RlTWFwW25vZGVLZXldIF0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZG9TdWJUcmVlKG9yaWdpbmFsTm9kZXMsIDAsIG51bGwpLCBvcmlnaW5hbExpbmtzLmZvckVhY2goKChsaW5rLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7bGluay5zb3VyY2V9LSR7bGluay50YXJnZXR9YCwgbGlua0RhdHVtID0gcGlja1dpdGhvdXQobGluaywgWyBcInBhcmVudHNcIiBdKTtcbiAgICAgICAgICAgIGlmIChsaW5rRGF0dW0ucGFyZW50cyA9IGxpbmsucGFyZW50cy5tYXAoKG5vZGUgPT4gcGlja1dpdGhvdXQobm9kZSwgWyBcInNvdXJjZUxpbmtzXCIsIFwidGFyZ2V0TGlua3NcIiBdKSkpLCBcbiAgICAgICAgICAgIGxpbmtNYXBba2V5XSkgcmV0dXJuIGxpbmtNYXBba2V5XS52YWx1ZSArPSB0b1ZhbGlkTnVtYmVyKGxpbmsudmFsdWUpLCB2b2lkIGxpbmtNYXBba2V5XS5kYXR1bS5wdXNoKGxpbmtEYXR1bSk7XG4gICAgICAgICAgICBjb25zdCBsaW5rRWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAga2V5OiBgJHtsaW5rLnNvdXJjZX0tJHtsaW5rLnRhcmdldH1gLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogbGluay5zb3VyY2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBsaW5rLnRhcmdldCxcbiAgICAgICAgICAgICAgICBkYXR1bTogWyBsaW5rRGF0dW0gXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGluay52YWx1ZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRzOiBsaW5rLnBhcmVudHMubWFwKChwYXJlbnQgPT4gcGFyZW50LmtleSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGlua3MucHVzaChsaW5rRWxlbWVudCksIG5vZGVNYXBbbGluay5zb3VyY2VdLnNvdXJjZUxpbmtzLnB1c2gobGlua0VsZW1lbnQpLCBub2RlTWFwW2xpbmsudGFyZ2V0XS50YXJnZXRMaW5rcy5wdXNoKGxpbmtFbGVtZW50KSwgXG4gICAgICAgICAgICBsaW5rTWFwW2tleV0gPSBsaW5rRWxlbWVudDtcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgICAgICBsaW5rczogbGlua3MsXG4gICAgICAgICAgICBub2RlTWFwOiBub2RlTWFwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXB1dGVTb3VyY2VUYXJnZXROb2RlTGlua3MoZGF0YSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdLCBsaW5rcyA9IFtdLCBub2RlTWFwID0ge307XG4gICAgICAgIGRhdGEubm9kZXMgJiYgZGF0YS5ub2Rlcy5mb3JFYWNoKCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiAtMSxcbiAgICAgICAgICAgICAgICBkYXR1bTogbm9kZSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9nZXROb2RlS2V5ID8gdGhpcy5fZ2V0Tm9kZUtleShub2RlKSA6IGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLFxuICAgICAgICAgICAgICAgIHNvdXJjZUxpbmtzOiBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRMaW5rczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTWFwW25vZGVFbGVtZW50LmtleV0gPSBub2RlRWxlbWVudCwgbm9kZXMucHVzaChub2RlRWxlbWVudCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgaW52YWxpZExpbmtzID0gW107XG4gICAgICAgIHJldHVybiBkYXRhLmxpbmtzLmZvckVhY2goKChsaW5rLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFzU291cmNlID0gIWlzTmlsKGxpbmsuc291cmNlKSwgaGFzVGFyZ2V0ID0gIWlzTmlsKGxpbmsudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChkYXRhLm5vZGVzICYmICghbm9kZU1hcFtsaW5rLnNvdXJjZV0gfHwgIW5vZGVNYXBbbGluay50YXJnZXRdKSkgcmV0dXJuO1xuICAgICAgICAgICAgZGF0YS5ub2RlcyB8fCAhaGFzU291cmNlIHx8IG5vZGVNYXBbbGluay5zb3VyY2VdIHx8IChub2RlTWFwW2xpbmsuc291cmNlXSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRlcHRoOiAtMSxcbiAgICAgICAgICAgICAgICBpbmRleDogbm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGtleTogbGluay5zb3VyY2UsXG4gICAgICAgICAgICAgICAgZGF0dW06IG51bGwsXG4gICAgICAgICAgICAgICAgc291cmNlTGlua3M6IFtdLFxuICAgICAgICAgICAgICAgIHRhcmdldExpbmtzOiBbXVxuICAgICAgICAgICAgfSwgbm9kZXMucHVzaChub2RlTWFwW2xpbmsuc291cmNlXSkpLCBkYXRhLm5vZGVzIHx8ICFoYXNUYXJnZXQgfHwgbm9kZU1hcFtsaW5rLnRhcmdldF0gfHwgKG5vZGVNYXBbbGluay50YXJnZXRdID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGVwdGg6IC0xLFxuICAgICAgICAgICAgICAgIGluZGV4OiBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAga2V5OiBsaW5rLnRhcmdldCxcbiAgICAgICAgICAgICAgICBkYXR1bTogbnVsbCxcbiAgICAgICAgICAgICAgICBzb3VyY2VMaW5rczogW10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGlua3M6IFtdXG4gICAgICAgICAgICB9LCBub2Rlcy5wdXNoKG5vZGVNYXBbbGluay50YXJnZXRdKSk7XG4gICAgICAgICAgICBjb25zdCBsaW5rRWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgc291cmNlOiBsaW5rLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGxpbmsudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRhdHVtOiBsaW5rLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaW5rLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpdmlkZU5vZGVWYWx1ZVRvTGluayAmJiBpc05pbChsaW5rLnZhbHVlKSAmJiBpbnZhbGlkTGlua3MucHVzaChsaW5rRWxlbWVudCksIFxuICAgICAgICAgICAgbGlua3MucHVzaChsaW5rRWxlbWVudCksIGhhc1NvdXJjZSAmJiBub2RlTWFwW2xpbmsuc291cmNlXS5zb3VyY2VMaW5rcy5wdXNoKGxpbmtFbGVtZW50KSwgXG4gICAgICAgICAgICBoYXNUYXJnZXQgJiYgbm9kZU1hcFtsaW5rLnRhcmdldF0udGFyZ2V0TGlua3MucHVzaChsaW5rRWxlbWVudCk7XG4gICAgICAgIH0pKSwgdGhpcy5vcHRpb25zLmRpdmlkZU5vZGVWYWx1ZVRvTGluayAmJiBpbnZhbGlkTGlua3MubGVuZ3RoICYmIGludmFsaWRMaW5rcy5mb3JFYWNoKChsaW5rID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFsgY2FsY0RpdmlkZVZhbHVlKG5vZGVNYXBbbGluay5zb3VyY2VdKSwgY2FsY0RpdmlkZVZhbHVlKG5vZGVNYXBbbGluay50YXJnZXRdLCAhMCkgXS5maWx0ZXIoKGVudHJ5ID0+ICFpc05pbChlbnRyeSkpKTtcbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGggJiYgKGxpbmsudmFsdWUgPSBtaW5JbkFycmF5KHZhbHVlcykpO1xuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIG5vZGVNYXA6IG5vZGVNYXAsXG4gICAgICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgICAgICBsaW5rczogbGlua3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcHV0ZU5vZGVMaW5rcyhkYXRhKSB7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIFwibGlua3NcIiBpbiBkYXRhID8gcmVzID0gdGhpcy5jb21wdXRlU291cmNlVGFyZ2V0Tm9kZUxpbmtzKGRhdGEpIDogKHRoaXMuX2lzSGllcmFyY2hpYyA9ICEwLCBcbiAgICAgICAgcmVzID0gdGhpcy5jb21wdXRlSGllcmFyY2hpY05vZGVMaW5rcyhkYXRhLm5vZGVzKSk7XG4gICAgICAgIGxldCBub2RlcyA9IHJlcy5ub2RlcztcbiAgICAgICAgY29uc3QgbGlua3MgPSByZXMubGlua3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGlua1NvcnRCeSkgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSBub2Rlc1tpXS5zb3VyY2VMaW5rcy5zb3J0KHRoaXMub3B0aW9ucy5saW5rU29ydEJ5KSwgXG4gICAgICAgIG5vZGVzW2ldLnRhcmdldExpbmtzLnNvcnQodGhpcy5vcHRpb25zLmxpbmtTb3J0QnkpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRyb3BJc29sYXRlZE5vZGUgJiYgKG5vZGVzID0gbm9kZXMuZmlsdGVyKChub2RlID0+IG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoIHx8IG5vZGUuc291cmNlTGlua3MubGVuZ3RoKSkpLCBcbiAgICAgICAge1xuICAgICAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICAgICAgbGlua3M6IGxpbmtzLFxuICAgICAgICAgICAgbm9kZU1hcDogcmVzLm5vZGVNYXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcHV0ZU5vZGVWYWx1ZXMobm9kZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gTWF0aC5tYXgoaXNOaWwobm9kZS52YWx1ZSkgPyAwIDogdG9WYWxpZE51bWJlcihub2RlLnZhbHVlKSwgbm9kZS5zb3VyY2VMaW5rcy5yZWR1Y2UoKChzdW0sIGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIChudWxsICE9PSAoX2EgPSB0b1ZhbGlkTnVtYmVyKGxpbmsudmFsdWUpKSAmJiB2b2lkIDAgIT09IF9hID8gX2EgOiAwKTtcbiAgICAgICAgICAgIH0pLCAwKSwgbm9kZS50YXJnZXRMaW5rcy5yZWR1Y2UoKChzdW0sIGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIChudWxsICE9PSAoX2EgPSB0b1ZhbGlkTnVtYmVyKGxpbmsudmFsdWUpKSAmJiB2b2lkIDAgIT09IF9hID8gX2EgOiAwKTtcbiAgICAgICAgICAgIH0pLCAwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZU5vZGVEZXB0aHMobm9kZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBsZXQgbmV4dCwgbmV4dE1hcCwgY3VycmVudCA9IG5vZGVzLCBkZXB0aCA9IDAsIG1heERlcHRoID0gLTE7XG4gICAgICAgIGNvbnN0IHNldE5vZGVMYXllciA9IGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnNldE5vZGVMYXllcikgPyB0aGlzLm9wdGlvbnMuc2V0Tm9kZUxheWVyIDogbnVsbDtcbiAgICAgICAgZm9yICg7Y3VycmVudC5sZW5ndGggJiYgZGVwdGggPCBuOyApIHtcbiAgICAgICAgICAgIG5leHQgPSBbXSwgbmV4dE1hcCA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1ckxlbiA9IGN1cnJlbnQubGVuZ3RoOyBpIDwgY3VyTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gY3VycmVudFtpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAobm9kZS5kZXB0aCA9IHNldE5vZGVMYXllciAmJiBudWxsICE9PSAoX2EgPSBzZXROb2RlTGF5ZXIobm9kZS5kYXR1bSkpICYmIHZvaWQgMCAhPT0gX2EgPyBfYSA6IGRlcHRoLCBcbiAgICAgICAgICAgICAgICBzZXROb2RlTGF5ZXIgJiYgKG1heERlcHRoID0gTWF0aC5tYXgobm9kZS5kZXB0aCwgbWF4RGVwdGgpKSwgbm9kZS5zb3VyY2VMaW5rcyAmJiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCkpIGZvciAobGV0IGogPSAwLCBsaW5rTGVuID0gbm9kZS5zb3VyY2VMaW5rcy5sZW5ndGg7IGogPCBsaW5rTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluayA9IG5vZGUuc291cmNlTGlua3Nbal07XG4gICAgICAgICAgICAgICAgICAgIG5leHRNYXBbbGluay50YXJnZXRdIHx8IChuZXh0LnB1c2godGhpcy5fbm9kZU1hcFtsaW5rLnRhcmdldF0pLCBuZXh0TWFwW2xpbmsudGFyZ2V0XSA9ICEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dCwgZGVwdGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCA+IG4gJiYgdGhpcy5fbG9nZ2VyLndhcm4oXCJFcnJvcjogdGhlcmUgaXMgYSBjaXJjdWxhciBsaW5rXCIpLCB0aGlzLl9tYXhEZXB0aCA9IHNldE5vZGVMYXllciA/IG1heERlcHRoICsgMSA6IGRlcHRoO1xuICAgIH1cbiAgICBjb21wdXRlTm9kZUVuZERlcHRocyhub2Rlcykge1xuICAgICAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBsZXQgbmV4dCwgbmV4dE1hcCwgY3VycmVudCA9IG5vZGVzLCBkZXB0aCA9IDA7XG4gICAgICAgIGZvciAoO2N1cnJlbnQubGVuZ3RoICYmIGRlcHRoIDwgbjsgKSB7XG4gICAgICAgICAgICBuZXh0ID0gW10sIG5leHRNYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXJMZW4gPSBjdXJyZW50Lmxlbmd0aDsgaSA8IGN1ckxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGN1cnJlbnRbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5lbmREZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGlua0xlbiA9IG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoOyBqIDwgbGlua0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gbm9kZS50YXJnZXRMaW5rc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNYXBbbGluay5zb3VyY2VdIHx8IChuZXh0LnB1c2godGhpcy5fbm9kZU1hcFtsaW5rLnNvdXJjZV0pLCBuZXh0TWFwW2xpbmsuc291cmNlXSA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0LCBkZXB0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoID4gbiAmJiB0aGlzLl9sb2dnZXIud2FybihcIkVycm9yOiB0aGVyZSBpcyBhIGNpcmN1bGFyIGxpbmtcIik7XG4gICAgfVxuICAgIGNvbXB1dGVOb2RlTGF5ZXJzKG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IG5vZGVXaWR0aE9wdGlvbiA9IHRoaXMub3B0aW9ucy5ub2RlV2lkdGgsIGxpbmtXaWR0aE9wdGlvbiA9IHRoaXMub3B0aW9ucy5saW5rV2lkdGgsIG1pblN0ZXBXaWR0aCA9IHRoaXMub3B0aW9ucy5taW5TdGVwV2lkdGgsIHdpZHRoID0gdGhpcy5fdmlld0JveC53aWR0aDtcbiAgICAgICAgbGV0IG5vZGVXaWR0aCA9IG51bGwsIGxpbmtXaWR0aCA9IG51bGwsIGlzRXZlbldpZHRoID0gITE7XG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlV2lkdGhPcHRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGNsYW1wKHBhcnNlRmxvYXQobm9kZVdpZHRoT3B0aW9uLnJlcGxhY2UoXCIlXCIsIFwiXCIpKSAvIDEwMCwgMCwgMSk7XG4gICAgICAgICAgICBsZXQgc3RlcFdpZHRoID0gd2lkdGggLyAodGhpcy5fbWF4RGVwdGggLSAxICsgcmF0aW8pO1xuICAgICAgICAgICAgbWluU3RlcFdpZHRoID4gMCAmJiAoc3RlcFdpZHRoID0gTWF0aC5tYXgobWluU3RlcFdpZHRoLCBzdGVwV2lkdGgpKSwgbm9kZVdpZHRoID0gc3RlcFdpZHRoICogcmF0aW8sIFxuICAgICAgICAgICAgbGlua1dpZHRoID0gc3RlcFdpZHRoICogKDEgLSByYXRpbyksIGlzRXZlbldpZHRoID0gITA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIobm9kZVdpZHRoT3B0aW9uKSkge1xuICAgICAgICAgICAgaWYgKG5vZGVXaWR0aCA9IG5vZGVXaWR0aE9wdGlvbiwgaXNOdW1iZXIobGlua1dpZHRoT3B0aW9uKSkgbGlua1dpZHRoID0gbGlua1dpZHRoT3B0aW9uOyBlbHNlIGlmIChpc05pbChsaW5rV2lkdGhPcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXBXaWR0aCA9ICh3aWR0aCAtIG5vZGVXaWR0aE9wdGlvbikgLyAodGhpcy5fbWF4RGVwdGggLSAxKTtcbiAgICAgICAgICAgICAgICBtaW5TdGVwV2lkdGggPiAwICYmIChzdGVwV2lkdGggPSBNYXRoLm1heChtaW5TdGVwV2lkdGgsIHN0ZXBXaWR0aCkpLCBsaW5rV2lkdGggPSBzdGVwV2lkdGggLSBub2RlV2lkdGhPcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0V2ZW5XaWR0aCA9ICEwO1xuICAgICAgICB9IGVsc2UgaXNGdW5jdGlvbihub2RlV2lkdGhPcHRpb24pICYmIGlzTnVtYmVyKGxpbmtXaWR0aE9wdGlvbikgJiYgKGxpbmtXaWR0aCA9IGxpbmtXaWR0aE9wdGlvbik7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLmxheWVyID0gdGhpcy5faXNIaWVyYXJjaGljID8gbm9kZS5kZXB0aCA6IGNsYW1wKE1hdGguZmxvb3IodGhpcy5fYWxpZ25GdW5jKG5vZGUsIHRoaXMuX21heERlcHRoLCB0aGlzLl9ub2RlTWFwKSksIDAsIHRoaXMuX21heERlcHRoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IG5vZGUubGF5ZXI7XG4gICAgICAgICAgICBsYXllciA9PT0gdGhpcy5fbWF4RGVwdGggLSAxICYmIChub2RlLmlzTGFzdExheWVyID0gITApLCBpc0V2ZW5XaWR0aCAmJiAobm9kZS54MCA9IHRoaXMuX3ZpZXdCb3gueDAgKyBsYXllciAqIChub2RlV2lkdGggKyBsaW5rV2lkdGgpLCBcbiAgICAgICAgICAgIG5vZGUueDEgPSBub2RlLngwICsgbm9kZVdpZHRoKSwgY29sdW1uc1tsYXllcl0gPyBjb2x1bW5zW2xheWVyXS5wdXNoKG5vZGUpIDogY29sdW1uc1tsYXllcl0gPSBbIG5vZGUgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vZGVTb3J0QnkpIGZvciAobGV0IGogPSAwLCBjb2xMZW4gPSBjb2x1bW5zLmxlbmd0aDsgaiA8IGNvbExlbjsgaisrKSBjb2x1bW5zW2pdLnNvcnQodGhpcy5vcHRpb25zLm5vZGVTb3J0QnkpO1xuICAgICAgICBpZiAoIWlzRXZlbldpZHRoICYmIGlzRnVuY3Rpb24obm9kZVdpZHRoT3B0aW9uKSkge1xuICAgICAgICAgICAgbGV0IGN1ckxheWVyWCA9IHRoaXMuX3ZpZXdCb3gueDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21heERlcHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgICAgIGxldCBtYXhOb2RlV2lkdGggPSAwLCBtYXhMaW5rV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBjb2xMZW4gPSBjb2x1bW4gJiYgY29sdW1uLmxlbmd0aDsgaiA8IGNvbExlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjb2x1bW5bal0sIGN1ck5vZGVXaWR0aCA9IG5vZGVXaWR0aE9wdGlvbihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54MCA9IGN1ckxheWVyWCwgbm9kZS54MSA9IGN1ckxheWVyWCArIGN1ck5vZGVXaWR0aCwgbWF4Tm9kZVdpZHRoID0gTWF0aC5tYXgobm9kZVdpZHRoLCBjdXJOb2RlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VMaW5rcyA9IG5vZGUuc291cmNlTGlua3M7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwLCBsaW5rTGVuID0gc291cmNlTGlua3MubGVuZ3RoOyBrIDwgbGlua0xlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gc291cmNlTGlua3Nba10sIGN1ckxpbmtXaWR0aCA9IGlzRnVuY3Rpb24obGlua1dpZHRoT3B0aW9uKSA/IGxpbmtXaWR0aE9wdGlvbihsaW5rLCB0aGlzLl92aWV3Qm94KSA6IGxpbmtXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heExpbmtXaWR0aCA9IE1hdGgubWF4KG1heExpbmtXaWR0aCwgY3VyTGlua1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJMYXllclggKz0gbWF4Tm9kZVdpZHRoICsgbWF4TGlua1dpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH1cbiAgICBpbml0aWFsaXplTm9kZUJyZWFkdGhzKGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1pbkxpbmtIZWlnaHQgPSBudWxsICE9PSAoX2EgPSB0aGlzLm9wdGlvbnMubWluTGlua0hlaWdodCkgJiYgdm9pZCAwICE9PSBfYSA/IF9hIDogMDtcbiAgICAgICAgbGV0IG1pbk5vZGVIZWlnaHQgPSBudWxsICE9PSAoX2IgPSB0aGlzLm9wdGlvbnMubWluTm9kZUhlaWdodCkgJiYgdm9pZCAwICE9PSBfYiA/IF9iIDogMDtcbiAgICAgICAgY29uc3QgbWF4Tm9kZUhlaWdodCA9IG51bGwgIT09IChfYyA9IHRoaXMub3B0aW9ucy5tYXhOb2RlSGVpZ2h0KSAmJiB2b2lkIDAgIT09IF9jID8gX2MgOiAxIC8gMDtcbiAgICAgICAgbGV0IG1heExpbmtIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4TGlua0hlaWdodDtcbiAgICAgICAgKGlzTmlsKG1pbk5vZGVIZWlnaHQpIHx8IG1pbk5vZGVIZWlnaHQgPCBtaW5MaW5rSGVpZ2h0KSAmJiAobWluTm9kZUhlaWdodCA9IG1pbkxpbmtIZWlnaHQpLCBcbiAgICAgICAgKGlzTmlsKG1heExpbmtIZWlnaHQpIHx8IG1heExpbmtIZWlnaHQgPiBtYXhOb2RlSGVpZ2h0KSAmJiAobWF4TGlua0hlaWdodCA9IG1heE5vZGVIZWlnaHQpO1xuICAgICAgICBsZXQga3kgPSAwLCBnZXRHYXBZID0gbnVsbCwgZm9yY2VOb2RlSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLm5vZGVHYXApKSBnZXRHYXBZID0gdGhpcy5vcHRpb25zLm5vZGVHYXAsIGt5ID0gY29sdW1ucy5yZWR1Y2UoKCh2YWwsIGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VtVmFsdWUgPSBjb2x1bW4ucmVkdWNlKCgoc3VtLCBub2RlKSA9PiBzdW0gKyBub2RlLnZhbHVlKSwgMCksIHN1bUdhcFkgPSBjb2x1bW4ucmVkdWNlKCgoc3VtLCBub2RlKSA9PiBzdW0gKyB0aGlzLm9wdGlvbnMubm9kZUdhcChub2RlKSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHZhbCwgKHRoaXMuX3ZpZXdCb3guaGVpZ2h0IC0gc3VtR2FwWSkgLyBzdW1WYWx1ZSk7XG4gICAgICAgIH0pLCAxIC8gMCk7IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF4Um93Q291bnQgPSBjb2x1bW5zLnJlZHVjZSgoKGNudCwgY29sdW1uKSA9PiBNYXRoLm1heChjbnQsIGNvbHVtbi5sZW5ndGgpKSwgMCksIG1heFN0ZXBIZWlnaHQgPSB0aGlzLl92aWV3Qm94LmhlaWdodCAvIG1heFJvd0NvdW50O1xuICAgICAgICAgICAgbGV0IGdhcFkgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMubm9kZUdhcCwgbWF4U3RlcEhlaWdodCk7XG4gICAgICAgICAgICBpZiAobWluTm9kZUhlaWdodCArIGdhcFkgPiBtYXhTdGVwSGVpZ2h0ICYmIChnYXBZID0gbWluTm9kZUhlaWdodCA+PSBtYXhTdGVwSGVpZ2h0ID8gbWF4U3RlcEhlaWdodCAvIDIgOiAobWF4U3RlcEhlaWdodCAtIG1pbk5vZGVIZWlnaHQpIC8gMiwgXG4gICAgICAgICAgICBtaW5Ob2RlSGVpZ2h0ID0gTWF0aC5taW4obWF4U3RlcEhlaWdodCAtIGdhcFksIG1pbk5vZGVIZWlnaHQpKSwgZ2V0R2FwWSA9ICgpID0+IGdhcFksIFxuICAgICAgICAgICAgdGhpcy5fZ2FwWSA9IGdhcFksIHRoaXMub3B0aW9ucy5lcXVhbE5vZGVIZWlnaHQpIGZvcmNlTm9kZUhlaWdodCA9IHRoaXMuX3ZpZXdCb3guaGVpZ2h0IC8gbWF4Um93Q291bnQgLSBnYXBZOyBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxHYXBZID0gbWluTm9kZUhlaWdodCA+IDAgPyBNYXRoLm1heChnYXBZLCBtaW5Ob2RlSGVpZ2h0KSA6IGdhcFk7XG4gICAgICAgICAgICAgICAga3kgPSBjb2x1bW5zLnJlZHVjZSgoKHZhbCwgY29sdW1uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bVZhbHVlID0gY29sdW1uLnJlZHVjZSgoKHN1bSwgbm9kZSkgPT4gc3VtICsgbm9kZS52YWx1ZSksIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odmFsLCAodGhpcy5fdmlld0JveC5oZWlnaHQgLSAoKGNvbHVtbi5sZW5ndGggLSAxKSAqIGNhbEdhcFkgKyBtaW5Ob2RlSGVpZ2h0KSkgLyBzdW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSksIDEgLyAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1N0YXJ0R2FwID0gXCJzdGFydFwiID09PSB0aGlzLm9wdGlvbnMuZ2FwUG9zaXRpb24sIGlzTWlkZGxlR2FwID0gIWlzU3RhcnRHYXAgJiYgXCJlbmRcIiAhPT0gdGhpcy5vcHRpb25zLmdhcFBvc2l0aW9uLCBnZXROb2RlSGVpZ2h0ID0gaXNOdW1iZXIodGhpcy5vcHRpb25zLm5vZGVIZWlnaHQpID8gbm9kZSA9PiB0aGlzLm9wdGlvbnMubm9kZUhlaWdodCA6IGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLm5vZGVIZWlnaHQpID8gdGhpcy5vcHRpb25zLm5vZGVIZWlnaHQgOiBmb3JjZU5vZGVIZWlnaHQgPiAwID8gbm9kZSA9PiBmb3JjZU5vZGVIZWlnaHQgOiBub2RlID0+IE1hdGgubWF4KG5vZGUudmFsdWUgKiBreSwgMCksIGdldExpbmtIZWlnaHQgPSBpc051bWJlcih0aGlzLm9wdGlvbnMubGlua0hlaWdodCkgPyAoKSA9PiB0aGlzLm9wdGlvbnMubGlua0hlaWdodCA6IGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmxpbmtIZWlnaHQpID8gdGhpcy5vcHRpb25zLmxpbmtIZWlnaHQgOiAobGluaywgc291cmNlTm9kZSwgc291cmNlTm9kZUhlaWdodCkgPT4gTWF0aC5taW4oTWF0aC5tYXgoc291cmNlTm9kZS52YWx1ZSA/IHNvdXJjZU5vZGVIZWlnaHQgKiBsaW5rQ2xhbXBlKGxpbmsudmFsdWUgLyBzb3VyY2VOb2RlLnZhbHVlKSA6IDAsIG1pbkxpbmtIZWlnaHQsIDApLCBtYXhMaW5rSGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGNvbHVtbnNbaV07XG4gICAgICAgICAgICBpZiAoIW5vZGVzIHx8ICFub2Rlcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLl92aWV3Qm94LnkwLCBnYXBZID0gMCwgbm9kZUhlaWdodCA9IDAsIGNhbGN1bGF0ZWROb2RlSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICBnYXBZID0gZ2V0R2FwWShub2RlKSwgaXNTdGFydEdhcCAmJiAoeSArPSBnYXBZKSwgY2FsY3VsYXRlZE5vZGVIZWlnaHQgPSBnZXROb2RlSGVpZ2h0KG5vZGUpLCBcbiAgICAgICAgICAgICAgICBub2RlSGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5tYXgoY2FsY3VsYXRlZE5vZGVIZWlnaHQsIG1pbk5vZGVIZWlnaHQpLCBtYXhOb2RlSGVpZ2h0KSwgXG4gICAgICAgICAgICAgICAgbm9kZS55MCA9IHksIG5vZGUueTEgPSB5ICsgbm9kZUhlaWdodCwgeSA9IGlzU3RhcnRHYXAgPyBub2RlLnkxIDogbm9kZS55MSArIGdhcFk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDAsIGxpbmtMZW4gPSBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aDsgayA8IGxpbmtMZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gbm9kZS5zb3VyY2VMaW5rc1trXTtcbiAgICAgICAgICAgICAgICAgICAgbGluay50aGlja25lc3MgPSBnZXRMaW5rSGVpZ2h0KGxpbmssIG5vZGUsIGNhbGN1bGF0ZWROb2RlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVsdGFZID0gdGhpcy5fdmlld0JveC55MSAtIHkgKyAoaXNNaWRkbGVHYXAgPyBnYXBZIDogMCk7XG4gICAgICAgICAgICBpZiAoZGVsdGFZID4gMCkgaWYgKFwic3RhcnRcIiA9PT0gdGhpcy5vcHRpb25zLmNyb3NzTm9kZUFsaWduKSA7IGVsc2UgaWYgKFwiZW5kXCIgPT09IHRoaXMub3B0aW9ucy5jcm9zc05vZGVBbGlnbikgZm9yIChsZXQgaiA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgIG5vZGUueTAgKz0gZGVsdGFZLCBub2RlLnkxICs9IGRlbHRhWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJwYXJlbnRcIiA9PT0gdGhpcy5vcHRpb25zLmNyb3NzTm9kZUFsaWduKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZXMgPSBub2Rlcy5yZWR1Y2UoKChyZXMsIG5vZGUpID0+IChub2RlLnRhcmdldExpbmtzICYmIG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoICYmIG5vZGUudGFyZ2V0TGlua3MuZm9yRWFjaCgobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tsaW5rLnNvdXJjZV0gPSAhMDtcbiAgICAgICAgICAgICAgICB9KSksIHJlcykpLCB7fSk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZU5vZGVzKS5sZW5ndGggJiYgY29sdW1uc1tpIC0gMV0gJiYgY29sdW1uc1tpIC0gMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZTb3VyY2VOb2RlcyA9IGNvbHVtbnNbaSAtIDFdLmZpbHRlcigobm9kZSA9PiBzb3VyY2VOb2Rlc1tub2RlLmtleV0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZTb3VyY2VOb2RlcyAmJiBwcmV2U291cmNlTm9kZXMubGVuZ3RoICYmIHByZXZTb3VyY2VOb2Rlc1swXS55MCAhPT0gbm9kZXNbMF0ueTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlbHRhWSA9IHByZXZTb3VyY2VOb2Rlc1swXS55MCAtIG5vZGVzWzBdLnkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueTAgKz0gbmV3RGVsdGFZLCBub2RlLnkxICs9IG5ld0RlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsdGFZIC89IG5vZGVzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS55MCArPSBkZWx0YVkgKiAoaiArIDEpLCBub2RlLnkxICs9IGRlbHRhWSAqIChqICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YVkgPCAwICYmIG5vZGVzLmxlbmd0aCA+IDEgJiYgKGRlbHRhWSAvPSBub2Rlcy5sZW5ndGggLSAxLCBnYXBZICsgZGVsdGFZID49IDApKSB7XG4gICAgICAgICAgICAgICAgZ2FwWSArPSBkZWx0YVksIHRoaXMuX2dhcFkgPSBNYXRoLm1pbihnYXBZKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMSwgbGVuID0gbm9kZXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnkwICs9IGRlbHRhWSAqIGosIG5vZGUueTEgKz0gZGVsdGFZICogajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJMaW5rcyhub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZU5vZGVCcmVhZHRocyhub2Rlcykge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5jb21wdXRlTm9kZUxheWVycyhub2Rlcyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU5vZGVCcmVhZHRocyhjb2x1bW5zKTtcbiAgICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IHRoaXMub3B0aW9ucy5pdGVyYXRpb25zO1xuICAgICAgICBpZiAoIXRoaXMuX2lzSGllcmFyY2hpYyAmJiAhaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuc2V0Tm9kZUxheWVyKSAmJiAhaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMubm9kZUdhcCkpIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IE1hdGgucG93KC45OSwgaSksIGJldGEgPSBNYXRoLm1heCgxIC0gYWxwaGEsIChpICsgMSkgLyBpdGVyYXRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXhSaWdodFRvTGVmdChjb2x1bW5zLCBhbHBoYSwgYmV0YSksIHRoaXMucmVsYXhMZWZ0VG9SaWdodChjb2x1bW5zLCBhbHBoYSwgYmV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfVxuICAgIHJlbGF4TGVmdFRvUmlnaHQoY29sdW1ucywgYWxwaGEsIGJldGEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIG4gPSBjb2x1bW5zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBjb2xMZW4gPSBjb2x1bW4ubGVuZ3RoOyBqIDwgY29sTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBjb2x1bW5bal07XG4gICAgICAgICAgICAgICAgbGV0IHkgPSAwLCB3ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMCwgbGlua0xlbiA9IHRhcmdldC50YXJnZXRMaW5rcy5sZW5ndGg7IGsgPCBsaW5rTGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluayA9IHRhcmdldC50YXJnZXRMaW5rc1trXSwgdiA9IGxpbmsudmFsdWUgKiAodGFyZ2V0LmxheWVyIC0gdGhpcy5fbm9kZU1hcFtsaW5rLnNvdXJjZV0ubGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHRoaXMudGFyZ2V0VG9wKHRoaXMuX25vZGVNYXBbbGluay5zb3VyY2VdLCB0YXJnZXQpICogdiwgdyArPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoISh3ID4gMCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gKHkgLyB3IC0gdGFyZ2V0LnkwKSAqIGFscGhhO1xuICAgICAgICAgICAgICAgIHRhcmdldC55MCArPSBkeSwgdGFyZ2V0LnkxICs9IGR5LCB0aGlzLnJlb3JkZXJOb2RlTGlua3ModGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzTmlsKHRoaXMub3B0aW9ucy5ub2RlU29ydEJ5KSAmJiBjb2x1bW4uc29ydChhc2NlbmRpbmdOb2RlQnJlYWR0aCksIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoY29sdW1uLCBiZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWxheFJpZ2h0VG9MZWZ0KGNvbHVtbnMsIGFscGhhLCBiZXRhKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb2x1bW5zLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGNvbExlbiA9IGNvbHVtbi5sZW5ndGg7IGogPCBjb2xMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGNvbHVtbltqXTtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IDAsIHcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwLCBsaW5rTGVuID0gc291cmNlLnNvdXJjZUxpbmtzLmxlbmd0aDsgayA8IGxpbmtMZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gc291cmNlLnNvdXJjZUxpbmtzW2tdLCB2ID0gbGluay52YWx1ZSAqICh0aGlzLl9ub2RlTWFwW2xpbmsudGFyZ2V0XS5sYXllciAtIHNvdXJjZS5sYXllcik7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gdGhpcy5zb3VyY2VUb3Aoc291cmNlLCB0aGlzLl9ub2RlTWFwW2xpbmsudGFyZ2V0XSkgKiB2LCB3ICs9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHcgPiAwKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZHkgPSAoeSAvIHcgLSBzb3VyY2UueTApICogYWxwaGE7XG4gICAgICAgICAgICAgICAgc291cmNlLnkwICs9IGR5LCBzb3VyY2UueTEgKz0gZHksIHRoaXMucmVvcmRlck5vZGVMaW5rcyhzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCAwID09PSB0aGlzLm9wdGlvbnMubm9kZVNvcnRCeSAmJiBjb2x1bW4uc29ydChhc2NlbmRpbmdOb2RlQnJlYWR0aCksIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoY29sdW1uLCBiZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlQ29sbGlzaW9ucyhub2RlcywgYWxwaGEpIHtcbiAgICAgICAgY29uc3QgaSA9IG5vZGVzLmxlbmd0aCA+PiAxLCBzdWJqZWN0ID0gbm9kZXNbaV07XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnNCb3R0b21Ub1RvcChub2Rlcywgc3ViamVjdC55MCAtIHRoaXMuX2dhcFksIGkgLSAxLCBhbHBoYSksIFxuICAgICAgICB0aGlzLnJlc29sdmVDb2xsaXNpb25zVG9wVG9Cb3R0b20obm9kZXMsIHN1YmplY3QueTEgKyB0aGlzLl9nYXBZLCBpICsgMSwgYWxwaGEpLCBcbiAgICAgICAgdGhpcy5yZXNvbHZlQ29sbGlzaW9uc0JvdHRvbVRvVG9wKG5vZGVzLCB0aGlzLl92aWV3Qm94LnkxLCBub2Rlcy5sZW5ndGggLSAxLCBhbHBoYSksIFxuICAgICAgICB0aGlzLnJlc29sdmVDb2xsaXNpb25zVG9wVG9Cb3R0b20obm9kZXMsIHRoaXMuX3ZpZXdCb3gueTAsIDAsIGFscGhhKTtcbiAgICB9XG4gICAgcmVzb2x2ZUNvbGxpc2lvbnNUb3BUb0JvdHRvbShub2RlcywgeSwgaSwgYWxwaGEpIHtcbiAgICAgICAgZm9yICg7aSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV0sIGR5ID0gKHkgLSBub2RlLnkwKSAqIGFscGhhO1xuICAgICAgICAgICAgZHkgPiAxZS02ICYmIChub2RlLnkwICs9IGR5LCBub2RlLnkxICs9IGR5KSwgeSA9IG5vZGUueTEgKyB0aGlzLl9nYXBZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVDb2xsaXNpb25zQm90dG9tVG9Ub3Aobm9kZXMsIHksIGksIGFscGhhKSB7XG4gICAgICAgIGZvciAoO2kgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV0sIGR5ID0gKG5vZGUueTEgLSB5KSAqIGFscGhhO1xuICAgICAgICAgICAgZHkgPiAxZS02ICYmIChub2RlLnkwIC09IGR5LCBub2RlLnkxIC09IGR5KSwgeSA9IG5vZGUueTAgLSB0aGlzLl9nYXBZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhcmdldFRvcChzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICBsZXQgaSwgbGVuLCBsaW5rLCB5ID0gc291cmNlLnkwIC0gKHNvdXJjZS5zb3VyY2VMaW5rcy5sZW5ndGggLSAxKSAqIHRoaXMuX2dhcFkgLyAyO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzb3VyY2Uuc291cmNlTGlua3MubGVuZ3RoOyBpIDwgbGVuICYmIChsaW5rID0gc291cmNlLnNvdXJjZUxpbmtzW2ldLCBcbiAgICAgICAgbGluay50YXJnZXQgIT09IHRhcmdldC5rZXkpOyBpKyspIHkgKz0gbGluay50aGlja25lc3MgKyB0aGlzLl9nYXBZO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0YXJnZXQudGFyZ2V0TGlua3MubGVuZ3RoOyBpIDwgbGVuICYmIChsaW5rID0gdGFyZ2V0LnRhcmdldExpbmtzW2ldLCBcbiAgICAgICAgbGluay5zb3VyY2UgIT09IHNvdXJjZS5rZXkpOyBpKyspIHkgLT0gbGluay50aGlja25lc3M7XG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgICBzb3VyY2VUb3Aoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IGksIGxlbiwgbGluaywgeSA9IHRhcmdldC55MCAtICh0YXJnZXQudGFyZ2V0TGlua3MubGVuZ3RoIC0gMSkgKiB0aGlzLl9nYXBZIC8gMjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGFyZ2V0LnRhcmdldExpbmtzLmxlbmd0aDsgaSA8IGxlbiAmJiAobGluayA9IHRhcmdldC50YXJnZXRMaW5rc1tpXSwgXG4gICAgICAgIGxpbmsuc291cmNlICE9PSBzb3VyY2Uua2V5KTsgaSsrKSB5ICs9IGxpbmsudGhpY2tuZXNzICsgdGhpcy5fZ2FwWTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc291cmNlLnNvdXJjZUxpbmtzLmxlbmd0aDsgaSA8IGxlbiAmJiAobGluayA9IHNvdXJjZS5zb3VyY2VMaW5rc1tpXSwgXG4gICAgICAgIGxpbmsudGFyZ2V0ICE9PSB0YXJnZXQua2V5KTsgaSsrKSB5IC09IGxpbmsudGhpY2tuZXNzO1xuICAgICAgICByZXR1cm4geTtcbiAgICB9XG4gICAgY29tcHV0ZUxpbmtCcmVhZHRoc05vT3ZlcmxhcChub2Rlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGxldCB5MCA9IG5vZGUueTAsIHJlYWNoQm90dG9tID0gITE7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGlua0xlbiA9IG5vZGUuc291cmNlTGlua3MubGVuZ3RoOyBqIDwgbGlua0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluayA9IG5vZGUuc291cmNlTGlua3Nbal07XG4gICAgICAgICAgICAgICAgcmVhY2hCb3R0b20gfHwgKGxpbmsueTAgPSB5MCArIGxpbmsudGhpY2tuZXNzIC8gMiksIGxpbmsueDAgPSBub2RlLngxLCB5MCArIGxpbmsudGhpY2tuZXNzID4gbm9kZS55MSB8fCByZWFjaEJvdHRvbSA/IChsaW5rLnkwID0gbm9kZS55MSAtIGxpbmsudGhpY2tuZXNzIC8gMiwgXG4gICAgICAgICAgICAgICAgcmVhY2hCb3R0b20gPSAhMCkgOiB5MCArPSBsaW5rLnRoaWNrbmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB5MSA9IG5vZGUueTA7XG4gICAgICAgICAgICByZWFjaEJvdHRvbSA9ICExO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxpbmtMZW4gPSBub2RlLnRhcmdldExpbmtzLmxlbmd0aDsgaiA8IGxpbmtMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBub2RlLnRhcmdldExpbmtzW2pdO1xuICAgICAgICAgICAgICAgIHJlYWNoQm90dG9tIHx8IChsaW5rLnkxID0geTEgKyBsaW5rLnRoaWNrbmVzcyAvIDIpLCBsaW5rLngxID0gbm9kZS54MCwgeTEgKyBsaW5rLnRoaWNrbmVzcyA+IG5vZGUueTEgfHwgcmVhY2hCb3R0b20gPyAobGluay55MSA9IG5vZGUueTEgLSBsaW5rLnRoaWNrbmVzcyAvIDIsIFxuICAgICAgICAgICAgICAgIHJlYWNoQm90dG9tID0gITApIDogeTEgKz0gbGluay50aGlja25lc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUxpbmtCcmVhZHRoc092ZXJsYXAobm9kZXMpIHtcbiAgICAgICAgY29uc3QgbGlua092ZXJsYXAgPSB0aGlzLm9wdGlvbnMubGlua092ZXJsYXA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldLCBwb3MgPSBcInN0YXJ0XCIgPT09IGxpbmtPdmVybGFwID8gbm9kZS55MCA6IFwiZW5kXCIgPT09IGxpbmtPdmVybGFwID8gbm9kZS55MSA6IChub2RlLnkwICsgbm9kZS55MSkgLyAyLCBzaWduID0gXCJzdGFydFwiID09PSBsaW5rT3ZlcmxhcCA/IC41IDogXCJlbmRcIiA9PT0gbGlua092ZXJsYXAgPyAtLjUgOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxpbmtMZW4gPSBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aDsgaiA8IGxpbmtMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBub2RlLnNvdXJjZUxpbmtzW2pdO1xuICAgICAgICAgICAgICAgIGxpbmsueTAgPSBwb3MgKyBzaWduICogbGluay50aGlja25lc3MsIGxpbmsueDAgPSBub2RlLngxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxpbmtMZW4gPSBub2RlLnRhcmdldExpbmtzLmxlbmd0aDsgaiA8IGxpbmtMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBub2RlLnRhcmdldExpbmtzW2pdO1xuICAgICAgICAgICAgICAgIGxpbmsueTEgPSBwb3MgKyBzaWduICogbGluay50aGlja25lc3MsIGxpbmsueDEgPSBub2RlLngwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVMaW5rQnJlYWR0aHMobm9kZXMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpbmtPdmVybGFwID8gdGhpcy5jb21wdXRlTGlua0JyZWFkdGhzT3ZlcmxhcChub2RlcykgOiB0aGlzLmNvbXB1dGVMaW5rQnJlYWR0aHNOb092ZXJsYXAobm9kZXMpO1xuICAgIH1cbiAgICByZW9yZGVyTm9kZUxpbmtzKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzTmlsKHRoaXMub3B0aW9ucy5saW5rU29ydEJ5KSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0TGlua3MgPSBub2RlLnRhcmdldExpbmtzLCBzb3VyY2VMaW5rcyA9IG5vZGUuc291cmNlTGlua3M7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGlua0xlbiA9IHRhcmdldExpbmtzLmxlbmd0aDsgaiA8IGxpbmtMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0YXJnZXRMaW5rc1tqXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlTWFwW2xpbmsuc291cmNlXS5zb3VyY2VMaW5rcy5zb3J0KHRoaXMuX2FzY2VuZGluZ1RhcmdldEJyZWFkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxpbmtMZW4gPSBzb3VyY2VMaW5rcy5sZW5ndGg7IGogPCBsaW5rTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gc291cmNlTGlua3Nbal07XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZU1hcFtsaW5rLnRhcmdldF0udGFyZ2V0TGlua3Muc29ydCh0aGlzLl9hc2NlbmRpbmdTb3VyY2VCcmVhZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW9yZGVyTGlua3Mobm9kZXMpIHtcbiAgICAgICAgaWYgKGlzTmlsKHRoaXMub3B0aW9ucy5saW5rU29ydEJ5KSkgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzLnNvcnQodGhpcy5fYXNjZW5kaW5nVGFyZ2V0QnJlYWR0aCksIG5vZGUudGFyZ2V0TGlua3Muc29ydCh0aGlzLl9hc2NlbmRpbmdTb3VyY2VCcmVhZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuU2Fua2V5TGF5b3V0LmRlZmF1bHRPcHRpb25zID0ge1xuICAgIGl0ZXJhdGlvbnM6IDYsXG4gICAgbm9kZUFsaWduOiBcImp1c3RpZnlcIixcbiAgICBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgIG5vZGVXaWR0aDogMjQsXG4gICAgbm9kZUdhcDogOCxcbiAgICBjcm9zc05vZGVBbGlnbjogXCJtaWRkbGVcIixcbiAgICBkcm9wSXNvbGF0ZWROb2RlOiAhMFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/sankey-highlight.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/sankey-highlight.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SankeyHighlight: () => (/* binding */ SankeyHighlight)\n/* harmony export */ });\n/* harmony import */ var _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @visactor/vgrammar-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-core@0.16.11/node_modules/@visactor/vgrammar-core/es/interactions/base.js\");\n/* harmony import */ var _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @visactor/vgrammar-core */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-core@0.16.11/node_modules/@visactor/vgrammar-core/es/graph/enums.js\");\n/* harmony import */ var _visactor_vutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @visactor/vutils */ \"(ssr)/./node_modules/.pnpm/@visactor+vutils@0.19.7/node_modules/@visactor/vutils/es/common/array.js\");\n\n\n\n\nclass SankeyHighlight extends _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_0__.BaseInteraction {\n    constructor(view, options) {\n        var _a, _b;\n        super(view, options), this.type = SankeyHighlight.type, this.highlightAdjacentElement = (element, isNode) => {\n            var _a, _b;\n            const datum = element.getDatum(), allLinkElements = null !== (_b = null === (_a = this._linkMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [], highlightNodes = isNode ? [ datum.key ] : [ datum.source, datum.target ], getIsHighlight = isNode ? linkDatum => linkDatum.target === datum.key || linkDatum.source === datum.key : linkDatum => linkDatum.source === datum.source && linkDatum.target === datum.target;\n            return allLinkElements.forEach((linkEl => {\n                const linkDatum = linkEl.getDatum();\n                getIsHighlight(linkDatum) ? (linkEl.removeState(this.options.blurState), linkEl.addState(this.options.highlightState, {\n                    ratio: 1\n                }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), \n                highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), \n                linkEl.addState(this.options.blurState));\n            })), highlightNodes;\n        }, this.highlightRelatedBySourceTarget = (element, isNode) => {\n            var _a, _b, _c, _d, _e, _f;\n            if (!isNode) return this.highlightAdjacentElement(element, isNode);\n            const datum = element.getDatum(), allNodeElements = null !== (_b = null === (_a = this._nodeMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [], highlightNodes = [], allLinkElements = null !== (_d = null === (_c = this._linkMark) || void 0 === _c ? void 0 : _c.elements) && void 0 !== _d ? _d : [], highlightLinks = [], allNodes = allNodeElements.reduce(((res, nodeEl) => {\n                const nodeDatum = nodeEl.getDatum();\n                return res[null == nodeDatum ? void 0 : nodeDatum.key] = {\n                    datum: nodeDatum,\n                    el: nodeEl\n                }, res;\n            }), {}), downNodes = [ datum ], upNodes = [ datum ];\n            for (;downNodes.length; ) {\n                const first = downNodes.pop();\n                (null === (_e = null == first ? void 0 : first.sourceLinks) || void 0 === _e ? void 0 : _e.length) && first.sourceLinks.forEach((link => {\n                    highlightLinks.push(link), allNodes[link.target] && downNodes.push(allNodes[link.target].datum);\n                }));\n            }\n            for (;upNodes.length; ) {\n                const first = upNodes.pop();\n                (null === (_f = null == first ? void 0 : first.targetLinks) || void 0 === _f ? void 0 : _f.length) && first.targetLinks.forEach((link => {\n                    highlightLinks.push(link), allNodes[link.source] && upNodes.push(allNodes[link.source].datum);\n                }));\n            }\n            return allLinkElements.forEach((linkEl => {\n                const linkDatum = linkEl.getDatum();\n                highlightLinks.some((link => link.source === linkDatum.source && link.target === linkDatum.target)) ? (linkEl.removeState(this.options.blurState), \n                linkEl.addState(this.options.highlightState, {\n                    ratio: 1\n                }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), \n                highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), \n                linkEl.addState(this.options.blurState));\n            })), highlightNodes;\n        }, this.highlightRelatedElement = (element, isNode) => {\n            var _a, _b, _c, _d, _e;\n            const allLinkElements = null !== (_b = null === (_a = this._linkMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [];\n            if (!!!(null === (_e = null === (_d = null === (_c = allLinkElements[0]) || void 0 === _c ? void 0 : _c.getDatum) || void 0 === _d ? void 0 : _d.call(_c)) || void 0 === _e ? void 0 : _e.parents)) return this.highlightRelatedBySourceTarget(element, isNode);\n            const datum = element.getDatum(), highlightNodes = isNode ? [ datum.key ] : [ datum.source, datum.target ], upstreamLinks = this.parseUpstreamLinks(element, isNode);\n            return allLinkElements.forEach((linkEl => {\n                const linkDatum = linkEl.getDatum(), originalDatum = (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__.array)(linkDatum.datum);\n                if (!isNode && linkDatum.source === datum.source && linkDatum.target === datum.target) return linkEl.removeState(this.options.blurState), \n                void linkEl.addState(this.options.highlightState, {\n                    ratio: 1\n                });\n                const selectedDatum = isNode ? originalDatum.filter((entry => {\n                    var _a;\n                    return (null !== (_a = entry.parents) && void 0 !== _a ? _a : []).some((par => par.key === datum.key));\n                })) : originalDatum.filter((entry => {\n                    var _a;\n                    return (null !== (_a = entry.parents) && void 0 !== _a ? _a : []).some((par => par.key === datum.target));\n                }));\n                if (selectedDatum && selectedDatum.length) {\n                    highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), \n                    highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);\n                    const ratio = selectedDatum.reduce(((sum, d) => sum + d.value), 0) / linkDatum.value;\n                    return linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {\n                        ratio: ratio\n                    });\n                }\n                const upSelectedLink = upstreamLinks.find((upLink => upLink.source === linkDatum.source && upLink.target === linkDatum.target));\n                if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), \n                highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), \n                linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {\n                    ratio: upSelectedLink.value / linkDatum.value\n                });\n                linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState);\n            })), highlightNodes;\n        }, this.highlightElement = (element, isNode) => {\n            var _a, _b;\n            const allNodeElements = null !== (_b = null === (_a = this._nodeMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [], highlightNodes = \"related\" === this.options.effect ? this.highlightRelatedElement(element, isNode) : this.highlightAdjacentElement(element, isNode);\n            allNodeElements.forEach((el => {\n                highlightNodes.includes(el.getDatum().key) ? (el.removeState(this.options.blurState), \n                el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), \n                el.addState(this.options.blurState));\n            }));\n        }, this.handleStart = e => {\n            e.element && (e.element.mark === this._nodeMark ? (this._activeElement = e.element, \n            this.highlightElement(e.element, !0)) : e.element.mark === this._linkMark && (this._activeElement = e.element, \n            this.highlightElement(e.element, !1)));\n        }, this.handleReset = e => {\n            e.element && e.element === this._activeElement && this.clearPrevElements();\n        }, this.options = Object.assign({}, SankeyHighlight.defaultOptions, options), this._nodeMark = null === (_a = view.getMarksBySelector(this.options.nodeSelector)) || void 0 === _a ? void 0 : _a[0], \n        this._linkMark = null === (_b = view.getMarksBySelector(this.options.linkSelector)) || void 0 === _b ? void 0 : _b[0];\n    }\n    getEvents() {\n        return [ {\n            type: this.options.trigger,\n            handler: this.handleStart\n        }, {\n            type: this.options.triggerOff,\n            handler: this.handleReset\n        } ];\n    }\n    clearPrevElements() {\n        [ this._linkMark, this._nodeMark ].forEach((mark => {\n            mark && mark.elements.forEach((el => {\n                el.hasState(this.options.highlightState) && el.removeState(this.options.highlightState), \n                el.hasState(this.options.blurState) && el.removeState(this.options.blurState);\n            }));\n        }));\n    }\n    parseUpstreamLinks(element, isNode) {\n        const datum = element.getDatum();\n        return (isNode ? datum.targetLinks : (0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__.array)(datum)).reduce(((res, link) => ((0,_visactor_vutils__WEBPACK_IMPORTED_MODULE_1__.array)(link.datum).forEach((dividedLink => {\n            var _a;\n            const parents = null !== (_a = dividedLink.parents) && void 0 !== _a ? _a : [ {\n                key: dividedLink.source\n            } ], len = isNode ? parents.length : parents.length - 1;\n            for (let i = 0; i < len; i++) {\n                const source = parents[i].key, target = parents[i + 1] ? parents[i + 1].key : datum.key, value = dividedLink.value, existingItem = res.find((item => item.source === source && item.target === target));\n                existingItem ? existingItem.value += value : res.push({\n                    source: source,\n                    target: target,\n                    value: value\n                });\n            }\n        })), res)), []);\n    }\n}\n\nSankeyHighlight.type = \"sankey-highlight\", SankeyHighlight.defaultOptions = {\n    highlightState: _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_2__.InteractionStateEnum.highlight,\n    blurState: _visactor_vgrammar_core__WEBPACK_IMPORTED_MODULE_2__.InteractionStateEnum.blur,\n    trigger: \"pointerover\",\n    triggerOff: \"pointerout\",\n    effect: \"related\"\n};\n//# sourceMappingURL=sankey-highlight.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXNhbmtleUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItc2Fua2V5L2VzL3NhbmtleS1oaWdobGlnaHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRjs7QUFFdkM7O0FBRWxDLDhCQUE4QixvRUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxLQUFLO0FBQ2xCLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsdURBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxpQ0FBaUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdURBQUssaUNBQWlDLHVEQUFLO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IseUVBQW9CO0FBQ3hDLGVBQWUseUVBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci1zYW5rZXlAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXNhbmtleS9lcy9zYW5rZXktaGlnaGxpZ2h0LmpzPzBjNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50ZXJhY3Rpb25TdGF0ZUVudW0sIEJhc2VJbnRlcmFjdGlvbiB9IGZyb20gXCJAdmlzYWN0b3IvdmdyYW1tYXItY29yZVwiO1xuXG5pbXBvcnQgeyBhcnJheSB9IGZyb20gXCJAdmlzYWN0b3IvdnV0aWxzXCI7XG5cbmV4cG9ydCBjbGFzcyBTYW5rZXlIaWdobGlnaHQgZXh0ZW5kcyBCYXNlSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIodmlldywgb3B0aW9ucyksIHRoaXMudHlwZSA9IFNhbmtleUhpZ2hsaWdodC50eXBlLCB0aGlzLmhpZ2hsaWdodEFkamFjZW50RWxlbWVudCA9IChlbGVtZW50LCBpc05vZGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBkYXR1bSA9IGVsZW1lbnQuZ2V0RGF0dW0oKSwgYWxsTGlua0VsZW1lbnRzID0gbnVsbCAhPT0gKF9iID0gbnVsbCA9PT0gKF9hID0gdGhpcy5fbGlua01hcmspIHx8IHZvaWQgMCA9PT0gX2EgPyB2b2lkIDAgOiBfYS5lbGVtZW50cykgJiYgdm9pZCAwICE9PSBfYiA/IF9iIDogW10sIGhpZ2hsaWdodE5vZGVzID0gaXNOb2RlID8gWyBkYXR1bS5rZXkgXSA6IFsgZGF0dW0uc291cmNlLCBkYXR1bS50YXJnZXQgXSwgZ2V0SXNIaWdobGlnaHQgPSBpc05vZGUgPyBsaW5rRGF0dW0gPT4gbGlua0RhdHVtLnRhcmdldCA9PT0gZGF0dW0ua2V5IHx8IGxpbmtEYXR1bS5zb3VyY2UgPT09IGRhdHVtLmtleSA6IGxpbmtEYXR1bSA9PiBsaW5rRGF0dW0uc291cmNlID09PSBkYXR1bS5zb3VyY2UgJiYgbGlua0RhdHVtLnRhcmdldCA9PT0gZGF0dW0udGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIGFsbExpbmtFbGVtZW50cy5mb3JFYWNoKChsaW5rRWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtEYXR1bSA9IGxpbmtFbC5nZXREYXR1bSgpO1xuICAgICAgICAgICAgICAgIGdldElzSGlnaGxpZ2h0KGxpbmtEYXR1bSkgPyAobGlua0VsLnJlbW92ZVN0YXRlKHRoaXMub3B0aW9ucy5ibHVyU3RhdGUpLCBsaW5rRWwuYWRkU3RhdGUodGhpcy5vcHRpb25zLmhpZ2hsaWdodFN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIHJhdGlvOiAxXG4gICAgICAgICAgICAgICAgfSksIGhpZ2hsaWdodE5vZGVzLmluY2x1ZGVzKGxpbmtEYXR1bS5zb3VyY2UpIHx8IGhpZ2hsaWdodE5vZGVzLnB1c2gobGlua0RhdHVtLnNvdXJjZSksIFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodE5vZGVzLmluY2x1ZGVzKGxpbmtEYXR1bS50YXJnZXQpIHx8IGhpZ2hsaWdodE5vZGVzLnB1c2gobGlua0RhdHVtLnRhcmdldCkpIDogKGxpbmtFbC5yZW1vdmVTdGF0ZSh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0U3RhdGUpLCBcbiAgICAgICAgICAgICAgICBsaW5rRWwuYWRkU3RhdGUodGhpcy5vcHRpb25zLmJsdXJTdGF0ZSkpO1xuICAgICAgICAgICAgfSkpLCBoaWdobGlnaHROb2RlcztcbiAgICAgICAgfSwgdGhpcy5oaWdobGlnaHRSZWxhdGVkQnlTb3VyY2VUYXJnZXQgPSAoZWxlbWVudCwgaXNOb2RlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmICghaXNOb2RlKSByZXR1cm4gdGhpcy5oaWdobGlnaHRBZGphY2VudEVsZW1lbnQoZWxlbWVudCwgaXNOb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdHVtID0gZWxlbWVudC5nZXREYXR1bSgpLCBhbGxOb2RlRWxlbWVudHMgPSBudWxsICE9PSAoX2IgPSBudWxsID09PSAoX2EgPSB0aGlzLl9ub2RlTWFyaykgfHwgdm9pZCAwID09PSBfYSA/IHZvaWQgMCA6IF9hLmVsZW1lbnRzKSAmJiB2b2lkIDAgIT09IF9iID8gX2IgOiBbXSwgaGlnaGxpZ2h0Tm9kZXMgPSBbXSwgYWxsTGlua0VsZW1lbnRzID0gbnVsbCAhPT0gKF9kID0gbnVsbCA9PT0gKF9jID0gdGhpcy5fbGlua01hcmspIHx8IHZvaWQgMCA9PT0gX2MgPyB2b2lkIDAgOiBfYy5lbGVtZW50cykgJiYgdm9pZCAwICE9PSBfZCA/IF9kIDogW10sIGhpZ2hsaWdodExpbmtzID0gW10sIGFsbE5vZGVzID0gYWxsTm9kZUVsZW1lbnRzLnJlZHVjZSgoKHJlcywgbm9kZUVsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZURhdHVtID0gbm9kZUVsLmdldERhdHVtKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc1tudWxsID09IG5vZGVEYXR1bSA/IHZvaWQgMCA6IG5vZGVEYXR1bS5rZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXR1bTogbm9kZURhdHVtLFxuICAgICAgICAgICAgICAgICAgICBlbDogbm9kZUVsXG4gICAgICAgICAgICAgICAgfSwgcmVzO1xuICAgICAgICAgICAgfSksIHt9KSwgZG93bk5vZGVzID0gWyBkYXR1bSBdLCB1cE5vZGVzID0gWyBkYXR1bSBdO1xuICAgICAgICAgICAgZm9yICg7ZG93bk5vZGVzLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkb3duTm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKG51bGwgPT09IChfZSA9IG51bGwgPT0gZmlyc3QgPyB2b2lkIDAgOiBmaXJzdC5zb3VyY2VMaW5rcykgfHwgdm9pZCAwID09PSBfZSA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgJiYgZmlyc3Quc291cmNlTGlua3MuZm9yRWFjaCgobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodExpbmtzLnB1c2gobGluayksIGFsbE5vZGVzW2xpbmsudGFyZ2V0XSAmJiBkb3duTm9kZXMucHVzaChhbGxOb2Rlc1tsaW5rLnRhcmdldF0uZGF0dW0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoO3VwTm9kZXMubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IHVwTm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKG51bGwgPT09IChfZiA9IG51bGwgPT0gZmlyc3QgPyB2b2lkIDAgOiBmaXJzdC50YXJnZXRMaW5rcykgfHwgdm9pZCAwID09PSBfZiA/IHZvaWQgMCA6IF9mLmxlbmd0aCkgJiYgZmlyc3QudGFyZ2V0TGlua3MuZm9yRWFjaCgobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodExpbmtzLnB1c2gobGluayksIGFsbE5vZGVzW2xpbmsuc291cmNlXSAmJiB1cE5vZGVzLnB1c2goYWxsTm9kZXNbbGluay5zb3VyY2VdLmRhdHVtKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsTGlua0VsZW1lbnRzLmZvckVhY2goKGxpbmtFbCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua0RhdHVtID0gbGlua0VsLmdldERhdHVtKCk7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0TGlua3Muc29tZSgobGluayA9PiBsaW5rLnNvdXJjZSA9PT0gbGlua0RhdHVtLnNvdXJjZSAmJiBsaW5rLnRhcmdldCA9PT0gbGlua0RhdHVtLnRhcmdldCkpID8gKGxpbmtFbC5yZW1vdmVTdGF0ZSh0aGlzLm9wdGlvbnMuYmx1clN0YXRlKSwgXG4gICAgICAgICAgICAgICAgbGlua0VsLmFkZFN0YXRlKHRoaXMub3B0aW9ucy5oaWdobGlnaHRTdGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICByYXRpbzogMVxuICAgICAgICAgICAgICAgIH0pLCBoaWdobGlnaHROb2Rlcy5pbmNsdWRlcyhsaW5rRGF0dW0uc291cmNlKSB8fCBoaWdobGlnaHROb2Rlcy5wdXNoKGxpbmtEYXR1bS5zb3VyY2UpLCBcbiAgICAgICAgICAgICAgICBoaWdobGlnaHROb2Rlcy5pbmNsdWRlcyhsaW5rRGF0dW0udGFyZ2V0KSB8fCBoaWdobGlnaHROb2Rlcy5wdXNoKGxpbmtEYXR1bS50YXJnZXQpKSA6IChsaW5rRWwucmVtb3ZlU3RhdGUodGhpcy5vcHRpb25zLmhpZ2hsaWdodFN0YXRlKSwgXG4gICAgICAgICAgICAgICAgbGlua0VsLmFkZFN0YXRlKHRoaXMub3B0aW9ucy5ibHVyU3RhdGUpKTtcbiAgICAgICAgICAgIH0pKSwgaGlnaGxpZ2h0Tm9kZXM7XG4gICAgICAgIH0sIHRoaXMuaGlnaGxpZ2h0UmVsYXRlZEVsZW1lbnQgPSAoZWxlbWVudCwgaXNOb2RlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgY29uc3QgYWxsTGlua0VsZW1lbnRzID0gbnVsbCAhPT0gKF9iID0gbnVsbCA9PT0gKF9hID0gdGhpcy5fbGlua01hcmspIHx8IHZvaWQgMCA9PT0gX2EgPyB2b2lkIDAgOiBfYS5lbGVtZW50cykgJiYgdm9pZCAwICE9PSBfYiA/IF9iIDogW107XG4gICAgICAgICAgICBpZiAoISEhKG51bGwgPT09IChfZSA9IG51bGwgPT09IChfZCA9IG51bGwgPT09IChfYyA9IGFsbExpbmtFbGVtZW50c1swXSkgfHwgdm9pZCAwID09PSBfYyA/IHZvaWQgMCA6IF9jLmdldERhdHVtKSB8fCB2b2lkIDAgPT09IF9kID8gdm9pZCAwIDogX2QuY2FsbChfYykpIHx8IHZvaWQgMCA9PT0gX2UgPyB2b2lkIDAgOiBfZS5wYXJlbnRzKSkgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0UmVsYXRlZEJ5U291cmNlVGFyZ2V0KGVsZW1lbnQsIGlzTm9kZSk7XG4gICAgICAgICAgICBjb25zdCBkYXR1bSA9IGVsZW1lbnQuZ2V0RGF0dW0oKSwgaGlnaGxpZ2h0Tm9kZXMgPSBpc05vZGUgPyBbIGRhdHVtLmtleSBdIDogWyBkYXR1bS5zb3VyY2UsIGRhdHVtLnRhcmdldCBdLCB1cHN0cmVhbUxpbmtzID0gdGhpcy5wYXJzZVVwc3RyZWFtTGlua3MoZWxlbWVudCwgaXNOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBhbGxMaW5rRWxlbWVudHMuZm9yRWFjaCgobGlua0VsID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rRGF0dW0gPSBsaW5rRWwuZ2V0RGF0dW0oKSwgb3JpZ2luYWxEYXR1bSA9IGFycmF5KGxpbmtEYXR1bS5kYXR1bSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUgJiYgbGlua0RhdHVtLnNvdXJjZSA9PT0gZGF0dW0uc291cmNlICYmIGxpbmtEYXR1bS50YXJnZXQgPT09IGRhdHVtLnRhcmdldCkgcmV0dXJuIGxpbmtFbC5yZW1vdmVTdGF0ZSh0aGlzLm9wdGlvbnMuYmx1clN0YXRlKSwgXG4gICAgICAgICAgICAgICAgdm9pZCBsaW5rRWwuYWRkU3RhdGUodGhpcy5vcHRpb25zLmhpZ2hsaWdodFN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIHJhdGlvOiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWREYXR1bSA9IGlzTm9kZSA/IG9yaWdpbmFsRGF0dW0uZmlsdGVyKChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChudWxsICE9PSAoX2EgPSBlbnRyeS5wYXJlbnRzKSAmJiB2b2lkIDAgIT09IF9hID8gX2EgOiBbXSkuc29tZSgocGFyID0+IHBhci5rZXkgPT09IGRhdHVtLmtleSkpO1xuICAgICAgICAgICAgICAgIH0pKSA6IG9yaWdpbmFsRGF0dW0uZmlsdGVyKChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChudWxsICE9PSAoX2EgPSBlbnRyeS5wYXJlbnRzKSAmJiB2b2lkIDAgIT09IF9hID8gX2EgOiBbXSkuc29tZSgocGFyID0+IHBhci5rZXkgPT09IGRhdHVtLnRhcmdldCkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWREYXR1bSAmJiBzZWxlY3RlZERhdHVtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHROb2Rlcy5pbmNsdWRlcyhsaW5rRGF0dW0uc291cmNlKSB8fCBoaWdobGlnaHROb2Rlcy5wdXNoKGxpbmtEYXR1bS5zb3VyY2UpLCBcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0Tm9kZXMuaW5jbHVkZXMobGlua0RhdHVtLnRhcmdldCkgfHwgaGlnaGxpZ2h0Tm9kZXMucHVzaChsaW5rRGF0dW0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBzZWxlY3RlZERhdHVtLnJlZHVjZSgoKHN1bSwgZCkgPT4gc3VtICsgZC52YWx1ZSksIDApIC8gbGlua0RhdHVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlua0VsLnJlbW92ZVN0YXRlKHRoaXMub3B0aW9ucy5ibHVyU3RhdGUpLCB2b2lkIGxpbmtFbC5hZGRTdGF0ZSh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0U3RhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvOiByYXRpb1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdXBTZWxlY3RlZExpbmsgPSB1cHN0cmVhbUxpbmtzLmZpbmQoKHVwTGluayA9PiB1cExpbmsuc291cmNlID09PSBsaW5rRGF0dW0uc291cmNlICYmIHVwTGluay50YXJnZXQgPT09IGxpbmtEYXR1bS50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICBpZiAodXBTZWxlY3RlZExpbmspIHJldHVybiBoaWdobGlnaHROb2Rlcy5pbmNsdWRlcyhsaW5rRGF0dW0uc291cmNlKSB8fCBoaWdobGlnaHROb2Rlcy5wdXNoKGxpbmtEYXR1bS5zb3VyY2UpLCBcbiAgICAgICAgICAgICAgICBoaWdobGlnaHROb2Rlcy5pbmNsdWRlcyhsaW5rRGF0dW0udGFyZ2V0KSB8fCBoaWdobGlnaHROb2Rlcy5wdXNoKGxpbmtEYXR1bS50YXJnZXQpLCBcbiAgICAgICAgICAgICAgICBsaW5rRWwucmVtb3ZlU3RhdGUodGhpcy5vcHRpb25zLmJsdXJTdGF0ZSksIHZvaWQgbGlua0VsLmFkZFN0YXRlKHRoaXMub3B0aW9ucy5oaWdobGlnaHRTdGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICByYXRpbzogdXBTZWxlY3RlZExpbmsudmFsdWUgLyBsaW5rRGF0dW0udmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaW5rRWwucmVtb3ZlU3RhdGUodGhpcy5vcHRpb25zLmhpZ2hsaWdodFN0YXRlKSwgbGlua0VsLmFkZFN0YXRlKHRoaXMub3B0aW9ucy5ibHVyU3RhdGUpO1xuICAgICAgICAgICAgfSkpLCBoaWdobGlnaHROb2RlcztcbiAgICAgICAgfSwgdGhpcy5oaWdobGlnaHRFbGVtZW50ID0gKGVsZW1lbnQsIGlzTm9kZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGFsbE5vZGVFbGVtZW50cyA9IG51bGwgIT09IChfYiA9IG51bGwgPT09IChfYSA9IHRoaXMuX25vZGVNYXJrKSB8fCB2b2lkIDAgPT09IF9hID8gdm9pZCAwIDogX2EuZWxlbWVudHMpICYmIHZvaWQgMCAhPT0gX2IgPyBfYiA6IFtdLCBoaWdobGlnaHROb2RlcyA9IFwicmVsYXRlZFwiID09PSB0aGlzLm9wdGlvbnMuZWZmZWN0ID8gdGhpcy5oaWdobGlnaHRSZWxhdGVkRWxlbWVudChlbGVtZW50LCBpc05vZGUpIDogdGhpcy5oaWdobGlnaHRBZGphY2VudEVsZW1lbnQoZWxlbWVudCwgaXNOb2RlKTtcbiAgICAgICAgICAgIGFsbE5vZGVFbGVtZW50cy5mb3JFYWNoKChlbCA9PiB7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0Tm9kZXMuaW5jbHVkZXMoZWwuZ2V0RGF0dW0oKS5rZXkpID8gKGVsLnJlbW92ZVN0YXRlKHRoaXMub3B0aW9ucy5ibHVyU3RhdGUpLCBcbiAgICAgICAgICAgICAgICBlbC5hZGRTdGF0ZSh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0U3RhdGUpKSA6IChlbC5yZW1vdmVTdGF0ZSh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0U3RhdGUpLCBcbiAgICAgICAgICAgICAgICBlbC5hZGRTdGF0ZSh0aGlzLm9wdGlvbnMuYmx1clN0YXRlKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sIHRoaXMuaGFuZGxlU3RhcnQgPSBlID0+IHtcbiAgICAgICAgICAgIGUuZWxlbWVudCAmJiAoZS5lbGVtZW50Lm1hcmsgPT09IHRoaXMuX25vZGVNYXJrID8gKHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBlLmVsZW1lbnQsIFxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRFbGVtZW50KGUuZWxlbWVudCwgITApKSA6IGUuZWxlbWVudC5tYXJrID09PSB0aGlzLl9saW5rTWFyayAmJiAodGhpcy5fYWN0aXZlRWxlbWVudCA9IGUuZWxlbWVudCwgXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEVsZW1lbnQoZS5lbGVtZW50LCAhMSkpKTtcbiAgICAgICAgfSwgdGhpcy5oYW5kbGVSZXNldCA9IGUgPT4ge1xuICAgICAgICAgICAgZS5lbGVtZW50ICYmIGUuZWxlbWVudCA9PT0gdGhpcy5fYWN0aXZlRWxlbWVudCAmJiB0aGlzLmNsZWFyUHJldkVsZW1lbnRzKCk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIFNhbmtleUhpZ2hsaWdodC5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyksIHRoaXMuX25vZGVNYXJrID0gbnVsbCA9PT0gKF9hID0gdmlldy5nZXRNYXJrc0J5U2VsZWN0b3IodGhpcy5vcHRpb25zLm5vZGVTZWxlY3RvcikpIHx8IHZvaWQgMCA9PT0gX2EgPyB2b2lkIDAgOiBfYVswXSwgXG4gICAgICAgIHRoaXMuX2xpbmtNYXJrID0gbnVsbCA9PT0gKF9iID0gdmlldy5nZXRNYXJrc0J5U2VsZWN0b3IodGhpcy5vcHRpb25zLmxpbmtTZWxlY3RvcikpIHx8IHZvaWQgMCA9PT0gX2IgPyB2b2lkIDAgOiBfYlswXTtcbiAgICB9XG4gICAgZ2V0RXZlbnRzKCkge1xuICAgICAgICByZXR1cm4gWyB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMudHJpZ2dlcixcbiAgICAgICAgICAgIGhhbmRsZXI6IHRoaXMuaGFuZGxlU3RhcnRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnRyaWdnZXJPZmYsXG4gICAgICAgICAgICBoYW5kbGVyOiB0aGlzLmhhbmRsZVJlc2V0XG4gICAgICAgIH0gXTtcbiAgICB9XG4gICAgY2xlYXJQcmV2RWxlbWVudHMoKSB7XG4gICAgICAgIFsgdGhpcy5fbGlua01hcmssIHRoaXMuX25vZGVNYXJrIF0uZm9yRWFjaCgobWFyayA9PiB7XG4gICAgICAgICAgICBtYXJrICYmIG1hcmsuZWxlbWVudHMuZm9yRWFjaCgoZWwgPT4ge1xuICAgICAgICAgICAgICAgIGVsLmhhc1N0YXRlKHRoaXMub3B0aW9ucy5oaWdobGlnaHRTdGF0ZSkgJiYgZWwucmVtb3ZlU3RhdGUodGhpcy5vcHRpb25zLmhpZ2hsaWdodFN0YXRlKSwgXG4gICAgICAgICAgICAgICAgZWwuaGFzU3RhdGUodGhpcy5vcHRpb25zLmJsdXJTdGF0ZSkgJiYgZWwucmVtb3ZlU3RhdGUodGhpcy5vcHRpb25zLmJsdXJTdGF0ZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcGFyc2VVcHN0cmVhbUxpbmtzKGVsZW1lbnQsIGlzTm9kZSkge1xuICAgICAgICBjb25zdCBkYXR1bSA9IGVsZW1lbnQuZ2V0RGF0dW0oKTtcbiAgICAgICAgcmV0dXJuIChpc05vZGUgPyBkYXR1bS50YXJnZXRMaW5rcyA6IGFycmF5KGRhdHVtKSkucmVkdWNlKCgocmVzLCBsaW5rKSA9PiAoYXJyYXkobGluay5kYXR1bSkuZm9yRWFjaCgoZGl2aWRlZExpbmsgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50cyA9IG51bGwgIT09IChfYSA9IGRpdmlkZWRMaW5rLnBhcmVudHMpICYmIHZvaWQgMCAhPT0gX2EgPyBfYSA6IFsge1xuICAgICAgICAgICAgICAgIGtleTogZGl2aWRlZExpbmsuc291cmNlXG4gICAgICAgICAgICB9IF0sIGxlbiA9IGlzTm9kZSA/IHBhcmVudHMubGVuZ3RoIDogcGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHBhcmVudHNbaV0ua2V5LCB0YXJnZXQgPSBwYXJlbnRzW2kgKyAxXSA/IHBhcmVudHNbaSArIDFdLmtleSA6IGRhdHVtLmtleSwgdmFsdWUgPSBkaXZpZGVkTGluay52YWx1ZSwgZXhpc3RpbmdJdGVtID0gcmVzLmZpbmQoKGl0ZW0gPT4gaXRlbS5zb3VyY2UgPT09IHNvdXJjZSAmJiBpdGVtLnRhcmdldCA9PT0gdGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJdGVtID8gZXhpc3RpbmdJdGVtLnZhbHVlICs9IHZhbHVlIDogcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSksIHJlcykpLCBbXSk7XG4gICAgfVxufVxuXG5TYW5rZXlIaWdobGlnaHQudHlwZSA9IFwic2Fua2V5LWhpZ2hsaWdodFwiLCBTYW5rZXlIaWdobGlnaHQuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0U3RhdGU6IEludGVyYWN0aW9uU3RhdGVFbnVtLmhpZ2hsaWdodCxcbiAgICBibHVyU3RhdGU6IEludGVyYWN0aW9uU3RhdGVFbnVtLmJsdXIsXG4gICAgdHJpZ2dlcjogXCJwb2ludGVyb3ZlclwiLFxuICAgIHRyaWdnZXJPZmY6IFwicG9pbnRlcm91dFwiLFxuICAgIGVmZmVjdDogXCJyZWxhdGVkXCJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW5rZXktaGlnaGxpZ2h0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/sankey-highlight.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/transform.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/transform.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transform: () => (/* binding */ transform)\n/* harmony export */ });\n/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ \"(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/layout.js\");\n\n\nconst transform = (options, upstreamData) => {\n    const res = new _layout__WEBPACK_IMPORTED_MODULE_0__.SankeyLayout(options).layout(Array.isArray(upstreamData) ? upstreamData[0] : upstreamData, \"width\" in options ? {\n        width: options.width,\n        height: options.height\n    } : {\n        x0: options.x0,\n        x1: options.x1,\n        y0: options.y0,\n        y1: options.y1\n    });\n    return res ? [ res ] : [];\n};\n//# sourceMappingURL=transform.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHZpc2FjdG9yK3ZncmFtbWFyLXNhbmtleUAwLjE2LjExL25vZGVfbW9kdWxlcy9AdmlzYWN0b3IvdmdyYW1tYXItc2Fua2V5L2VzL3RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3Qzs7QUFFakM7QUFDUCxvQkFBb0IsaURBQVk7QUFDaEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNhY3Rvci1uZXh0LXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2aXNhY3Rvcit2Z3JhbW1hci1zYW5rZXlAMC4xNi4xMS9ub2RlX21vZHVsZXMvQHZpc2FjdG9yL3ZncmFtbWFyLXNhbmtleS9lcy90cmFuc2Zvcm0uanM/ZDRlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTYW5rZXlMYXlvdXQgfSBmcm9tIFwiLi9sYXlvdXRcIjtcblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybSA9IChvcHRpb25zLCB1cHN0cmVhbURhdGEpID0+IHtcbiAgICBjb25zdCByZXMgPSBuZXcgU2Fua2V5TGF5b3V0KG9wdGlvbnMpLmxheW91dChBcnJheS5pc0FycmF5KHVwc3RyZWFtRGF0YSkgPyB1cHN0cmVhbURhdGFbMF0gOiB1cHN0cmVhbURhdGEsIFwid2lkdGhcIiBpbiBvcHRpb25zID8ge1xuICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodFxuICAgIH0gOiB7XG4gICAgICAgIHgwOiBvcHRpb25zLngwLFxuICAgICAgICB4MTogb3B0aW9ucy54MSxcbiAgICAgICAgeTA6IG9wdGlvbnMueTAsXG4gICAgICAgIHkxOiBvcHRpb25zLnkxXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcyA/IFsgcmVzIF0gOiBbXTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@visactor+vgrammar-sankey@0.16.11/node_modules/@visactor/vgrammar-sankey/es/transform.js\n");

/***/ })

};
;